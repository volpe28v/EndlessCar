<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ã‚«ãƒ¼ - ãƒ­ãƒ³ãƒ‰ãƒ³å¸‚è¡—åœ°ã‚³ãƒ¼ã‚¹</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: calc(100% - 190px); /* ãƒœã‚¿ãƒ³å¹…ã‚’è€ƒæ…®ã—ã¦èª¿æ•´ */
            z-index: 10;
        }
        #viewButtons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column; /* ç¸¦ã«ä¸¦ã¹ã‚‹ */
            gap: 5px;
            z-index: 100;
            flex-wrap: nowrap; /* æŠ˜ã‚Šè¿”ã—ãªã— */
            justify-content: flex-start;
            max-width: 60px; /* ãƒœã‚¿ãƒ³ã®å¹…ã«åˆã‚ã›ã¦èª¿æ•´ */
        }
        
        /* ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #minimap-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            z-index: 99;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        #minimap {
            width: 100%;
            height: 100%;
        }
        
        #minimap-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }
        
        .viewButton {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-bottom: 3px;
            min-width: 30px;
            text-align: center; /* ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸­å¤®æƒãˆ */
            width: 100%; /* ãƒœã‚¿ãƒ³ã®å¹…ã‚’è¦ªè¦ç´ ã«åˆã‚ã›ã‚‹ */
        }
        .viewButton:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        .viewButton:active {
            transform: scale(0.95);
        }
        .viewButton.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å‘ã‘èª¿æ•´ */
        @media (max-width: 480px) {
            #info {
                max-width: 60%;
                font-size: 12px;
                padding: 6px;
            }
            .viewButton {
                padding: 3px 4px;
                font-size: 10px;
                min-width: 24px;
            }
            #viewButtons {
                gap: 2px;
                max-width: 45px; /* ã‚¹ãƒãƒ›å‘ã‘ã«ã•ã‚‰ã«å°ã•ã */
            }
            
            #minimap-container {
                width: 100px;
                height: 100px;
                right: 55px;
            }
            
            /* ã‚¹ãƒãƒ›å‘ã‘æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ä½ç½®èª¿æ•´ */
            #timeToggle {
                right: 55px;
                top: 160px; /* è¦–ç‚¹ãƒœã‚¿ãƒ³ã®ä¸‹ã«é…ç½® */
            }
            
            /* ã‚¹ãƒãƒ›å‘ã‘å¤©æ°—ãƒœã‚¿ãƒ³ä½ç½®èª¿æ•´ */
            #weatherToggle {
                right: 55px;
                top: 210px; /* æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ä¸‹ã«é…ç½® */
            }
        }
        
        #weatherToggleButton, .weatherOption {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 16px;
            cursor: pointer;
            outline: none;
            transition: background-color 0.3s;
        }
        
        #weatherToggleButton:hover, .weatherOption:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        
        .weatherOption.active {
            background-color: rgba(100, 100, 100, 0.7);
            border-color: #888;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>
<body>
    <div id="viewButtons">
        <button class="viewButton" data-view="0" title="ä¿¯ç°è¦–ç‚¹ (1)">ä¿¯ç°</button>
        <button class="viewButton" data-view="1" title="è¿½å¾“è¦–ç‚¹ (2)">è¿½å¾“</button>
        <button class="viewButton" data-view="2" title="è»Šè¼‰è¦–ç‚¹ (3)">è»Šè¼‰</button>
        <button class="viewButton active" data-view="3" title="æ–œã‚ä¸Šè¦–ç‚¹ (4)">æ–œã‚</button>
        <button class="viewButton" data-view="4" title="å‰æ–¹è¦–ç‚¹ (5)">å‰æ–¹</button>
    </div>
    <div id="timeToggle" style="position: fixed; top: 10px; right: 80px; z-index: 100;">
        <button id="timeToggleButton" title="ç¾åœ¨ã®æ™‚åˆ»ã«é€£å‹•ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰">ğŸ•’</button>
    </div>
    <div id="weatherToggle" style="position: fixed; top: 10px; right: 140px; z-index: 100;">
        <button id="weatherToggleButton" title="å¤©æ°—ã‚’å¤‰æ›´">â˜€ï¸</button>
        <div id="weatherMenu" style="display: none; position: absolute; top: 30px; right: 0; background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; padding: 5px;">
            <button class="weatherOption active" data-weather="sunny" title="æ™´ã‚Œ">â˜€ï¸</button>
            <button class="weatherOption" data-weather="cloudy" title="æ›‡ã‚Š">â˜ï¸</button>
            <button class="weatherOption" data-weather="rain" title="é›¨">ğŸŒ§</button>
            <button class="weatherOption" data-weather="snow" title="é›ª">â„ï¸</button>
        </div>
    </div>
    <div id="minimap-container">
        <canvas id="minimap" width="150" height="120"></canvas>
    </div>
    <script>
        // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
        
        log("ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹");
        
        // åŸºæœ¬è¨­å®š
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x646464); // åˆæœŸã®ç©ºã®è‰²ã‚’è¨­å®š
        document.body.appendChild(renderer.domElement);
        
        log("Three.jsã®åŸºæœ¬è¨­å®šå®Œäº†");

        // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ ã®è¿½åŠ 
        let gameTime = 5.0; // æœ5æ™‚ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
        let timeSpeed = 0.01; // æ™‚é–“ã®é€²ã¿é€Ÿåº¦ (0.01 = ç¾å®Ÿã®100å€é€Ÿ)
        let isNight = false;
        let isNightMode = false;
        let useRealTime = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç¾åœ¨æ™‚åˆ»ãƒ¢ãƒ¼ãƒ‰
        let lastCameraChangeTime = Date.now(); // æœ€å¾Œã«ã‚«ãƒ¡ãƒ©ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚åˆ»
        let cameraChangeInterval = 30000; // ã‚«ãƒ¡ãƒ©å¤‰æ›´ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        let availableCameraModes = [0, 1, 2, 3, 4]; // åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰

        // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®è¿½åŠ 
        let currentWeather = 'sunny'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ™´ã‚Œ
        let rainParticles;
        let snowParticles;
        let cloudParticles; // é›²ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¿½åŠ 
        let driftSmokeParticles; // ãƒ‰ãƒªãƒ•ãƒˆç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        let driftSmokeData; // ãƒ‰ãƒªãƒ•ãƒˆç…™ãƒ‡ãƒ¼ã‚¿
        let isRaining = false;
        let isSnowing = false;
        let isCloudy = false; // æ›‡ã‚Šãƒ•ãƒ©ã‚°è¿½åŠ 
        let lastWeatherChangeTime = Date.now(); // æœ€å¾Œã«å¤©æ°—ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚åˆ»
        let weatherChangeInterval = 30000; // å¤©æ°—å¤‰æ›´ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        let availableWeathers = ['sunny', 'cloudy', 'rain', 'snow']; // åˆ©ç”¨å¯èƒ½ãªå¤©æ°—ã®é…åˆ—
        let currentFrameTime = Date.now(); // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å®šç¾©
        let weatherApiKey = '2416f36c5b6368d2de6d3016e34ae8f8'; // OpenWeatherMap APIã‚­ãƒ¼
        
        // ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let leftHeadlightLight;
        let rightHeadlightLight;
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å¤©æ°—ã®è‰²ã®å½±éŸ¿ã‚’ä¿æŒ
        let weatherSkyColor = new THREE.Color(0x87CEEB); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ™´ã‚Œã®ç©ºã®è‰²

        // æ™‚é–“å¸¯ã«å¿œã˜ãŸç©ºã®è‰²ã¨å…‰ã®è¨­å®š
        function updateDayNightCycle() {
            // æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦æ™‚é–“ã‚’æ›´æ–°
            if (useRealTime) {
                // ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—
                const now = new Date();
                gameTime = now.getHours() + now.getMinutes() / 60;
            } else {
                // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®æ™‚é–“ã‚’æ—©å›ã—ã§é€²ã‚ã‚‹
                gameTime = (gameTime + timeSpeed) % 24;
            }
            
            // æ™‚é–“å¸¯ã«å¿œã˜ãŸç©ºã®è‰²ã®è¨­å®š
            let timeSkyColor;
            let lightIntensity;
            let ambientIntensity;
            let isNight = false;
            
            if (gameTime >= 5 && gameTime < 7) {
                // æœç„¼ã‘ï¼ˆ5æ™‚ï½7æ™‚ï¼‰
                const t = (gameTime - 5) / 2;
                timeSkyColor = new THREE.Color(0xff9966).lerp(new THREE.Color(0x87CEEB), t);
                lightIntensity = 0.5 + t * 0.5;
                ambientIntensity = 0.3 + t * 0.3;
            } else if (gameTime >= 7 && gameTime < 17) {
                // æ˜¼é–“ï¼ˆ7æ™‚ï½17æ™‚ï¼‰
                timeSkyColor = new THREE.Color(0x87CEEB);
                lightIntensity = 1.0;
                ambientIntensity = 0.6;
            } else if (gameTime >= 17 && gameTime < 19) {
                // å¤•ç„¼ã‘ï¼ˆ17æ™‚ï½19æ™‚ï¼‰
                const t = (gameTime - 17) / 2;
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff7733), t);
                lightIntensity = 1.0 - t * 0.5;
                ambientIntensity = 0.6 - t * 0.3;
            } else if (gameTime >= 19 && gameTime < 21) {
                // æ—¥æ²¡å¾Œï¼ˆ19æ™‚ï½21æ™‚ï¼‰
                const t = (gameTime - 19) / 2;
                timeSkyColor = new THREE.Color(0xff7733).lerp(new THREE.Color(0x111133), t);
                lightIntensity = 0.5 - t * 0.4;
                ambientIntensity = 0.3 - t * 0.2;
                isNight = true;
            } else {
                // å¤œé–“ï¼ˆ21æ™‚ï½5æ™‚ï¼‰
                if (gameTime >= 21) {
                    timeSkyColor = new THREE.Color(0x111133);
                } else {
                    // å¤œæ˜ã‘å‰ï¼ˆ0æ™‚ï½5æ™‚ï¼‰
                    const t = gameTime / 5;
                    timeSkyColor = new THREE.Color(0x111133).lerp(new THREE.Color(0xff9966), t);
                }
                lightIntensity = 0.1;
                ambientIntensity = 0.1;
                isNight = true;
            }
            
            // æ™‚é–“å¸¯ã®è‰²ã¨å¤©æ°—ã®è‰²ã‚’åˆæˆ
            let finalColor;
            if (currentWeather === 'sunny') {
                finalColor = timeSkyColor;
            } else {
                // å¤©æ°—ã«ã‚ˆã‚‹è‰²ã®å½±éŸ¿ã‚’å¼·ã‚ã‚‹ï¼ˆ0.7ã¯å¤©æ°—ã®å½±éŸ¿åº¦ï¼‰
                finalColor = timeSkyColor.clone().lerp(weatherSkyColor, 0.7);
            }
            
            // ç©ºã®è‰²ã‚’è¨­å®š
            renderer.setClearColor(finalColor.getHex());
            
            // å…‰æºã®å¼·åº¦ã‚’è¨­å®š
            directionalLight.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            
            // å¤œé–“ã¯è¡—ç¯ã‚’æ˜ã‚‹ã
            updateStreetLights(isNight);
            
            // å¤œé–“ã¯ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆã‚’ã‚ªãƒ³ã€æ˜¼é–“ã¯ã‚ªãƒ•
            if (leftHeadlightLight && rightHeadlightLight) {
                leftHeadlightLight.visible = isNight;
                rightHeadlightLight.visible = isNight;
            }
        }
        
        // è¡—ç¯ã®æ˜ã‚‹ã•ã‚’æ›´æ–°
        function updateStreetLights(isNight) {
            // è¡—ç¯ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
            scene.traverse((object) => {
                if (object.userData && object.userData.isStreetlight) {
                    // è¡—ç¯æœ¬ä½“ã®ç™ºå…‰ã‚’è¨­å®š
                    if (object.material && object.material.emissive) {
                        if (isNight) {
                            // å¤œé–“ã¯æ˜ã‚‹ãç™ºå…‰
                            object.material.emissive.set(0xFFDD99);
                            object.material.emissiveIntensity = 1.0;
                        } else {
                            // æ˜¼é–“ã¯ç™ºå…‰ã‚’å¼±ã‚ã‚‹
                            object.material.emissive.set(0x333333);
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                    
                    // é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•ã‚’è¨­å®š
                    if (object.userData.pointLight) {
                        const pointLight = object.userData.pointLight;
                        if (isNight) {
                            // å¤œé–“ã¯ãƒ©ã‚¤ãƒˆã‚’æ˜ã‚‹ã
                            pointLight.intensity = 2.5;
                            pointLight.distance = 50;
                        } else {
                            // æ˜¼é–“ã¯ãƒ©ã‚¤ãƒˆã‚’å¼±ãï¼ˆå®Œå…¨ã«æ¶ˆã•ãªã„ï¼‰
                            pointLight.intensity = 0.2;
                            pointLight.distance = 10;
                        }
                    }
                }
            });
        }

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        // éƒ½å¸‚ã®åœ°é¢ã‚’ä½œæˆ
        const floorSize = 5000; // åºŠã®ã‚µã‚¤ã‚ºã‚’2500ã‹ã‚‰2.0å€ã®5000ã«æ‹¡å¤§
        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x336633, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5; // åºŠã®ä½ç½®ã‚’ä¸‹ã’ã‚‹
        scene.add(floor);
        
        // èˆ—è£…ã•ã‚ŒãŸé“è·¯ã®å¹…
        const roadWidth = 16; // é“è·¯ã®å¹…ã‚’å…ƒã«æˆ»ã™
        
        // ãƒªãƒƒã‚¸ãƒ¬ãƒ¼ã‚µãƒ¼é¢¨ã®ä¸Šç´šã‚³ãƒ¼ã‚¹å®šç¾©ï¼ˆã™ã¹ã¦åœ°ä¸Šãƒ»é–‰ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
        const trackPoints = [
            // æ–°ã—ã„ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼ˆx, é«˜åº¦, zï¼‰- 2.0å€ã«æ‹¡å¤§ã€é«˜ã•ã¯2å€
            [200 * 2.0, 0, 350 * 2.0],      // 4,7,0
            [50 * 2.0, 0, 350 * 2.0],       // 1,7,0
            [0 * 2.0, 1 * 2, 250 * 2.0],    // 0,5,1
            [25 * 2.0, 2 * 2, 200 * 2.0],   // 0.5,4,2
            [60 * 2.0, 2 * 2, 215 * 2.0],   // 1.2,4.3,2
            [125 * 2.0, 2 * 2, 140 * 2.0],  // 2.5,2.8,2
            [100 * 2.0, 5 * 2, 50 * 2.0],   // 2,1,3
            [135 * 2.0, 3 * 2, 0 * 2.0],    // 2.7,0,2.5
            [200 * 2.0, 0, 50 * 2.0],       // 4,1,0
            [220 * 2.0, 0, 40 * 2.0],       // 4.4,0.8,0
            [295 * 2.0, 0, 90 * 2.0],       // 5.9,1.8,0
            [285 * 2.0, 1 * 2, 105 * 2.0],  // 5.7,2.1,1
            [210 * 2.0, 1 * 2, 110 * 2.0],  // 4.2,2.2,1
            [185 * 2.0, 2 * 2, 145 * 2.0],  // 3.7,2.9,2
            [150 * 2.0, 2 * 2, 235 * 2.0],  // 3,4.7,2
            [170 * 2.0, 1 * 2, 275 * 2.0],  // 3.4,5.5,1
            [220 * 2.0, 1 * 2, 275 * 2.0],  // 4.4,5.5,1
            [270 * 2.0, 2 * 2, 225 * 2.0],  // 5.4,4.5,2
            [285 * 2.0, 2 * 2, 180 * 2.0],  // 5.7,3.6,2
            [365 * 2.0, 1 * 2, 150 * 2.0],  // 7.3,3,1
            [400 * 2.0, 1 * 2, 165 * 2.0],  // 8,3.3,1
            [475 * 2.0, 2 * 2, 175 * 2.0],  // 9.5,3.5,2
            [450 * 2.0, 1 * 2, 250 * 2.0],  // 9,5,1
            [395 * 2.0, 1 * 2, 285 * 2.0],  // 7.9,5.7,1
            [350 * 2.0, 1 * 2, 265 * 2.0],  // 7,5.3,1
            [300 * 2.0, 0, 275 * 2.0],      // 6,5.5,0
            [245 * 2.0, 0, 350 * 2.0],      // 4.9,7,0
            [200 * 2.0, 0, 350 * 2.0]       // 4,7,0
        ];
        
        // é“è·¯ã‚’ä½œæˆ
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);
        
        // 3Dãƒ‘ã‚¹ãƒã‚¤ãƒ³ãƒˆã«å¤‰æ›
        const carPathPoints = [];
        for (let i = 0; i < trackPoints.length; i++) {
            // é«˜ã•æƒ…å ±ï¼ˆYè»¸ï¼‰ã‚’è€ƒæ…®ã—ãŸãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆ
            carPathPoints.push(new THREE.Vector3(trackPoints[i][0], trackPoints[i][1] + 0.3, trackPoints[i][2]));
        }
        
        // ã‚«ãƒˆãƒãƒ«ãƒ»ãƒ­ãƒ ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³ã§æ»‘ã‚‰ã‹ãªæ›²ç·šã‚’ä½œæˆ
        const carPath = new THREE.CatmullRomCurve3(carPathPoints);
        carPath.closed = true; // é–‰ã˜ãŸãƒ«ãƒ¼ãƒ—ã«æˆ»ã™
        
        // ãƒ‘ã‚¹ã®è©³ç´°ãªãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ï¼ˆé“è·¯ç”Ÿæˆç”¨ï¼‰
        const detailedPathPoints = carPath.getPoints(500);
        
        // ã‚¢ã‚¹ãƒ•ã‚¡ãƒ«ãƒˆéƒ¨åˆ†ã‚’ä½œæˆ
        function createRoadSurface() {
            // é“è·¯ã®å·¦å³ã®ã‚¨ãƒƒã‚¸ã‚’è¨ˆç®—
            const leftEdgePoints = [];
            const rightEdgePoints = [];
            
            for (let i = 0; i < detailedPathPoints.length; i++) {
                const point = detailedPathPoints[i];
                const nextPoint = detailedPathPoints[(i + 1) % detailedPathPoints.length];
                
                // é€²è¡Œæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                
                // ä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ³•ç·šï¼‰ã‚’è¨ˆç®—
                // é«˜ã•ã®å¤‰åŒ–ã‚’è€ƒæ…®ã—ãŸæ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ã™ã‚‹ï¼ˆåœ°å½¢ã«æ²¿ã£ãŸé“è·¯ï¼‰
                const up = new THREE.Vector3(0, 1, 0);
                
                // å³å‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã¨ä¸Šå‘ãã®å¤–ç©ï¼‰
                const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                
                // ä¿®æ­£ã—ãŸä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã¨å³å‘ãã®å¤–ç©ï¼‰
                const correctedUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                
                // é“è·¯ã®å·¦å³ã®ã‚¨ãƒƒã‚¸ã‚’è¨ˆç®—ï¼ˆä¿®æ­£ã—ãŸæ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ï¼‰
                const leftEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(roadWidth / 2));
                const rightEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(-roadWidth / 2));
                
                // é«˜ã•ã‚’ç¶­æŒï¼ˆé“è·¯é¢ã®é«˜ã•ã¯æ—¢ã«detailedPathPointsã«å«ã¾ã‚Œã‚‹ï¼‰
                // é“è·¯ã‚’å°‘ã—æµ®ã‹ã›ã‚‹ï¼ˆ0.05ï¼‰
                leftEdge.y += 0.05;
                rightEdge.y += 0.05;
                
                leftEdgePoints.push(leftEdge);
                rightEdgePoints.push(rightEdge);
            }
            
            // é“è·¯ã®è¡¨é¢ã‚’ä¸‰è§’å½¢ãƒ¡ãƒƒã‚·ãƒ¥ã§ä½œæˆ
            const roadGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // ã™ã¹ã¦ã®ãƒã‚¤ãƒ³ãƒˆã‚’é ‚ç‚¹é…åˆ—ã«è¿½åŠ 
            for (let i = 0; i < leftEdgePoints.length; i++) {
                vertices.push(leftEdgePoints[i].x, leftEdgePoints[i].y, leftEdgePoints[i].z);
                vertices.push(rightEdgePoints[i].x, rightEdgePoints[i].y, rightEdgePoints[i].z);
            }
            
            // ä¸‰è§’å½¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
            for (let i = 0; i < leftEdgePoints.length - 1; i++) {
                const v0 = i * 2;
                const v1 = v0 + 1;
                const v2 = v0 + 2;
                const v3 = v0 + 3;
                
                // 2ã¤ã®ä¸‰è§’å½¢ã§å››è§’å½¢ã‚’ä½œæˆ
                indices.push(v0, v1, v2);
                indices.push(v2, v1, v3);
            }
            
            // æœ€å¾Œã®éƒ¨åˆ†ã‚’é–‰ã˜ã‚‹
            const v0 = (leftEdgePoints.length - 1) * 2;
            const v1 = v0 + 1;
            const v2 = 0;
            const v3 = 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
            
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            roadGeometry.setIndex(indices);
            roadGeometry.computeVertexNormals();
            
            const roadMaterial = new THREE.MeshLambertMaterial({
                color: 0x777777, // 0x333333ã‹ã‚‰0x777777ã«å¤‰æ›´ã—ã¦é“è·¯ã‚’è–„ãï¼ˆæ˜ã‚‹ãï¼‰ã™ã‚‹
                side: THREE.DoubleSide
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadGroup.add(roadMesh);
            
            // ç™½ç·šï¼ˆå®Ÿç·šï¼‰ã‚’ä½œæˆ - å‰Šé™¤
            // createRoadLine(detailedPathPoints, 0.05, 0xFFFFFF);
            
            // ç¸çŸ³ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼éƒ¨åˆ†ï¼‰ - å‰Šé™¤
            // createCurbstones();
            
            return roadMesh;
        }
        
        // é“è·¯ã®ç™½ç·šã‚’ä½œæˆ
        function createRoadLine(pathPoints, lineWidth, color) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.y = 0.1; // é“è·¯ã®ä¸Šã«æµ®ã‹ã›ã‚‹
            roadGroup.add(line);
            
            return line;
        }
        
        // ç¸çŸ³ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼éƒ¨åˆ†ï¼‰
        function createCurbstones() {
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®ä½ç½®ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const cornerPositions = [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.85];
            
            for (let i = 0; i < cornerPositions.length; i++) {
                const t = cornerPositions[i];
                const cornerLength = 0.05; // ã‚³ãƒ¼ãƒŠãƒ¼ã®é•·ã•ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
                
                for (let j = 0; j < 10; j++) {
                    const segmentT = t + (j * cornerLength / 10);
                    const point = carPath.getPointAt(segmentT);
                    const tangent = carPath.getTangentAt(segmentT);
                    
                    // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¨å‰ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å‚¾æ–œã‚’è¨ˆç®—
                    const nextT = (segmentT + 0.005) % 1;
                    const prevT = (segmentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ç¸çŸ³ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ï¼‰
                    const curbPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(roadWidth / 2)
                    );
                    
                    // å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—ï¼ˆYè»¸æ–¹å‘ã®å¤‰åŒ–ã‹ã‚‰ï¼‰
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // èµ¤ç™½ã®ç¸çŸ³ï¼ˆäº¤äº’ï¼‰
                    const color = j % 2 === 0 ? 0xff0000 : 0xffffff;
                    
                    const curbGeometry = new THREE.BoxGeometry(1, 0.3, 1);
                    const curbMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                    
                    // ç¸çŸ³ã®ä½ç½®ã‚’é“è·¯ã®é«˜ã•ã«åˆã‚ã›ã‚‹
                    curb.position.copy(curbPosition);
                    curb.position.y = point.y + 0.1; // é“è·¯é¢ã‚ˆã‚Šå°‘ã—æµ®ã‹ã›ã‚‹
                    
                    // é€²è¡Œæ–¹å‘ã‚’å‘ãã‚ˆã†ã«å›è»¢
                    const lookAtPos = new THREE.Vector3().addVectors(
                        curbPosition,
                        tangent
                    );
                    curb.lookAt(lookAtPos);
                    
                    // ä¸Šä¸‹ã®å‚¾æ–œã«åˆã‚ã›ã¦è¿½åŠ ã®å›è»¢
                    curb.rotateX(slope);
                    
                    roadGroup.add(curb);
                }
            }
        }
        
        // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ã‚¹å…¨ä½“ã®å¤–å´ï¼‰
        function createGuardrails() {
            // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é–“éš”ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const railSpacing = 0.005; // ã‚ˆã‚Šå¯†ã«é…ç½®
            const postSpacing = 0.025; // æ”¯æŸ±ã®é–“éš”
            
            // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            const guardrailGroup = new THREE.Group();
            roadGroup.add(guardrailGroup);
            
            // é“è·¯ã®ä¸¡å´ã«ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’è¨­ç½®
            createSideGuardrail(1); // å³å´
            createSideGuardrail(-1); // å·¦å´
            
            // ç‰¹å®šã®å´ï¼ˆå³å´ã¾ãŸã¯å·¦å´ï¼‰ã«ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createSideGuardrail(side) {
                // é€£ç¶šã—ãŸã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æ ¼ç´ã™ã‚‹é…åˆ—
                const railSegments = [];
                const railPosts = [];
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ç”¨ã®é ‚ç‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åé›†
                const railVertices = [];
                const railIndices = [];
                const railUvs = [];
                
                let vertexIndex = 0;
                let currentT = 0;
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                while (currentT < 1) {
                    const point = carPath.getPointAt(currentT);
                    const tangent = carPath.getTangentAt(currentT);
                    
                    // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¨å‰ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å‚¾æ–œã‚’è¨ˆç®—
                    const nextT = (currentT + 0.005) % 1;
                    const prevT = (currentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ã€side=1ã§å³å´ã€side=-1ã§å·¦å´ï¼‰
                    const railPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(side * (roadWidth / 2 + 1.2))
                    );
                    
                    // å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é«˜ã•èª¿æ•´
                    const railHeight = point.y + 0.8; // é“è·¯é¢ã‹ã‚‰å°‘ã—é«˜ã
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä¸Šéƒ¨ã¨ä¸‹éƒ¨ã®é ‚ç‚¹ã‚’è¿½åŠ 
                    const topRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight + 0.4, // ä¸Šéƒ¨ã®é«˜ã•
                        railPosition.z
                    );
                    
                    const bottomRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight, // ä¸‹éƒ¨ã®é«˜ã•
                        railPosition.z
                    );
                    
                    // æ”¯æŸ±ã‚’ä½œæˆï¼ˆä¸€å®šé–“éš”ã”ã¨ï¼‰
                    if (Math.abs(currentT % postSpacing) < railSpacing) {
                        const postGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6);
                        const postMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        
                        // æ”¯æŸ±ã®ä½ç½®ã‚’è¨­å®š
                        post.position.copy(new THREE.Vector3(
                            railPosition.x,
                            point.y + 0.5, // åœ°é¢ã‹ã‚‰ã®é«˜ã•
                            railPosition.z
                        ));
                        
                        // æ”¯æŸ±ã‚’å°‘ã—å†…å´ã«å‚¾ã‘ã‚‹
                        const postLookAt = new THREE.Vector3().addVectors(
                            post.position,
                            normal.clone().multiplyScalar(-0.1 * side) // å†…å´ã«å°‘ã—å‚¾ã‘ã‚‹
                        );
                        post.lookAt(postLookAt);
                        post.rotateX(Math.PI / 2); // æ”¯æŸ±ã®å‘ãã‚’ä¿®æ­£
                        
                        // ä¸Šä¸‹ã®å‚¾æ–œã«åˆã‚ã›ã¦è¿½åŠ ã®å›è»¢
                        post.rotateZ(slope); // Xè»¸ã§ã¯ãªãZè»¸ã§å›è»¢ï¼ˆæ”¯æŸ±ã®å‘ããŒå¤‰ã‚ã£ã¦ã„ã‚‹ãŸã‚ï¼‰
                        
                        guardrailGroup.add(post);
                        railPosts.push(post);
                    }
                    
                    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
                    railVertices.push(
                        topRailPos.x, topRailPos.y, topRailPos.z,
                        bottomRailPos.x, bottomRailPos.y, bottomRailPos.z
                    );
                    
                    // ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã‚’è¿½åŠ 
                    railUvs.push(
                        currentT * 20, 0, // ä¸Šéƒ¨ã®UVåº§æ¨™
                        currentT * 20, 1  // ä¸‹éƒ¨ã®UVåº§æ¨™
                    );
                    
                    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ ï¼ˆå››è§’å½¢ã‚’ä½œæˆï¼‰
                    if (vertexIndex > 0) {
                        // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé–“ã‚’ä¸‰è§’å½¢ã§æ¥ç¶š
                        railIndices.push(
                            vertexIndex * 2 - 2, vertexIndex * 2, vertexIndex * 2 - 1, // æœ€åˆã®ä¸‰è§’å½¢
                            vertexIndex * 2 - 1, vertexIndex * 2, vertexIndex * 2 + 1  // äºŒç•ªç›®ã®ä¸‰è§’å½¢
                        );
                    }
                    
                    vertexIndex++;
                    currentT += railSpacing;
                }
                
                // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨æ¥ç¶šã—ã¦é–‰ã˜ã‚‹
                railIndices.push(
                    (vertexIndex - 1) * 2, 0, (vertexIndex - 1) * 2 + 1, // æœ€åˆã®ä¸‰è§’å½¢
                    (vertexIndex - 1) * 2 + 1, 0, 1  // äºŒç•ªç›®ã®ä¸‰è§’å½¢
                );
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const railGeometry = new THREE.BufferGeometry();
                railGeometry.setAttribute('position', new THREE.Float32BufferAttribute(railVertices, 3));
                railGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(railUvs, 2));
                railGeometry.setIndex(railIndices);
                railGeometry.computeVertexNormals();
                
                // é«˜é€Ÿé“è·¯ã®ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚‰ã—ã„ç´ æ
                const railMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE0E0E0,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
                const railMesh = new THREE.Mesh(railGeometry, railMaterial);
                guardrailGroup.add(railMesh);
            }
        }
        
        // é“è·¯ã®å¯è¦–åŒ–
        createRoadSurface();
        
        // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä½œæˆ
        createGuardrails();
        
        log("é“è·¯ã®ä½œæˆå®Œäº†");
        
        // ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®ï¼ˆãƒ“ãƒ«ã¯å‰Šé™¤ã—ã¦æ˜Ÿç©ºã®ã¿ã«ï¼‰
        function placeEnvironmentObjects() {
            log("ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…ç½®é–‹å§‹");
            
            // è¡—ç¯ã‚’é…ç½®
            createStreetlights();
            
            log("ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…ç½®å®Œäº†");
        }
        
        // è¡—ç¯ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createStreetlights() {
            // è¡—ç¯ã®é–“éš”ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const streetlightSpacing = 0.04; // ã‚³ãƒ¼ã‚¹å…¨ä½“ã§ç´„25æœ¬ã®è¡—ç¯
            
            // è¡—ç¯ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            const streetlightGroup = new THREE.Group();
            roadGroup.add(streetlightGroup);
            
            // ã‚³ãƒ¼ã‚¹å…¨ä½“ã«è¡—ç¯ã‚’é…ç½®
            let currentT = 0;
            while (currentT < 1) {
                // ãƒ‘ã‚¹ä¸Šã®ä½ç½®ã¨æ¥ç·šã‚’å–å¾—
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // é“è·¯ã®å³å´ã«è¡—ç¯ã‚’è¨­ç½®
                createSingleStreetlight(point, normal, 1); // å³å´
                
                currentT += streetlightSpacing;
            }
            
            // 1æœ¬ã®è¡—ç¯ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createSingleStreetlight(point, normal, side) {
                // è¡—ç¯ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ï¼‰
                const lightPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 + 2.0))
                );
                
                // è¡—ç¯ã®æ”¯æŸ±
                const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 8, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                
                // æ”¯æŸ±ã®ä½ç½®ã‚’è¨­å®š
                pole.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 4, // åœ°é¢ã‹ã‚‰ã®é«˜ã•
                    lightPosition.z
                ));
                
                // æ”¯æŸ±ã‚’å‚ç›´ã«ç«‹ã¦ã‚‹
                pole.rotation.x = Math.PI / 2;
                
                streetlightGroup.add(pole);
                
                // è¡—ç¯ã®é ­éƒ¨
                const headGeometry = new THREE.BoxGeometry(1.0, 0.4, 0.4);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0xFFDD99,
                    emissiveIntensity: 0.1 // åˆæœŸå€¤ã¯ä½ã
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // é ­éƒ¨ã®ä½ç½®ã‚’è¨­å®š
                head.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // æ”¯æŸ±ã®ä¸Šéƒ¨
                    lightPosition.z
                ));
                
                // é ­éƒ¨ã‚’é“è·¯ã«å‘ã‘ã‚‹
                head.lookAt(new THREE.Vector3(
                    point.x,
                    point.y + 8,
                    point.z
                ));
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã«è¡—ç¯ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                head.userData.isStreetlight = true;
                
                streetlightGroup.add(head);
                
                // è¡—ç¯ã®ãƒ©ã‚¤ãƒˆ
                const light = new THREE.PointLight(0xFFDD99, 0.2, 10, 2);
                light.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // æ”¯æŸ±ã®ä¸Šéƒ¨
                    lightPosition.z
                ));
                
                // ãƒ©ã‚¤ãƒˆã‚’è¡—ç¯ã®é ­éƒ¨ã«é–¢é€£ä»˜ã‘ã‚‹
                head.userData.pointLight = light;
                
                streetlightGroup.add(light);
            }
        }
        
        // è©³ç´°ãªè»Šã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
        function createDetailedCar() {
            const car = new THREE.Group();
            
            // ã‚«ãƒ©ãƒ¼ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
            const carColors = [
                { name: 'ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ¬ãƒƒãƒ‰', body: 0xFF0000, accent: 0x111111 },
                { name: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ãƒ–ãƒ«ãƒ¼', body: 0x0066CC, accent: 0x111111 },
                { name: 'ã‚¤ã‚¨ãƒ­ãƒ¼', body: 0xFFCC00, accent: 0x111111 },
                { name: 'ãƒ–ãƒªãƒ†ã‚£ãƒƒã‚·ãƒ¥ã‚°ãƒªãƒ¼ãƒ³', body: 0x006633, accent: 0x111111 },
                { name: 'ãƒ‘ãƒ¼ãƒ«ãƒ›ãƒ¯ã‚¤ãƒˆ', body: 0xFFFFFF, accent: 0x111111 }
            ];
            
            // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚«ãƒ©ãƒ¼ã‚’é¸æŠ
            const selectedColor = carColors[Math.floor(Math.random() * carColors.length)];
            log(`é¸æŠã•ã‚ŒãŸã‚«ãƒ©ãƒ¼: ${selectedColor.name}`);
            
            // è»Šä½“ãƒ™ãƒ¼ã‚¹ï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã‚«ãƒ¼é¢¨ã®ä½ãã€å¹…åºƒã„ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
            const carBodyGeometry = new THREE.BoxGeometry(2.4, 0.3, 4.8);
            const carBodyMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body }); // é¸æŠã•ã‚ŒãŸã‚«ãƒ©ãƒ¼
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.55;
            car.add(carBody);

            // ãƒ•ãƒ­ãƒ³ãƒˆãƒãƒ¼ã‚ºï¼ˆå…ˆç«¯ãŒä½ãã€ã‚·ãƒ£ãƒ¼ãƒ—ãªå½¢çŠ¶ï¼‰
            const noseGeometry = new THREE.BoxGeometry(1.8, 0.2, 1.0);
            const noseMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 0.45, -2.2);
            car.add(nose);
            
            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¦ã‚¤ãƒ³ã‚°
            const frontWingGeometry = new THREE.BoxGeometry(2.2, 0.1, 0.4);
            const frontWingMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const frontWing = new THREE.Mesh(frontWingGeometry, frontWingMaterial);
            frontWing.position.set(0, 0.35, -2.4);
            car.add(frontWing);

            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¦ã‚¤ãƒ³ã‚°ã‚¨ãƒ³ãƒ‰ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå·¦ï¼‰
            const frontWingEndPlateLeftGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.6);
            const frontWingEndPlateLeft = new THREE.Mesh(frontWingEndPlateLeftGeometry, frontWingMaterial);
            frontWingEndPlateLeft.position.set(-1.1, 0.4, -2.4);
            car.add(frontWingEndPlateLeft);

            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¦ã‚¤ãƒ³ã‚°ã‚¨ãƒ³ãƒ‰ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå³ï¼‰
            const frontWingEndPlateRight = frontWingEndPlateLeft.clone();
            frontWingEndPlateRight.position.set(1.1, 0.4, -2.4);
            car.add(frontWingEndPlateRight);
            
            // ã‚µã‚¤ãƒ‰ãƒãƒ³ãƒ„ãƒ¼ãƒ³ï¼ˆå·¦ï¼‰
            const sidePodGeometry = new THREE.BoxGeometry(0.4, 0.3, 2.0);
            const sidePodMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const leftSidePod = new THREE.Mesh(sidePodGeometry, sidePodMaterial);
            leftSidePod.position.set(-1.0, 0.5, 0.2);
            car.add(leftSidePod);

            // ã‚µã‚¤ãƒ‰ãƒãƒ³ãƒ„ãƒ¼ãƒ³ï¼ˆå³ï¼‰
            const rightSidePod = leftSidePod.clone();
            rightSidePod.position.set(1.0, 0.5, 0.2);
            car.add(rightSidePod);

            // ã‚¨ã‚¢ãƒœãƒƒã‚¯ã‚¹ï¼ˆã‚¨ãƒ³ã‚¸ãƒ³ä¸Šéƒ¨ã®ç©ºæ°—å–ã‚Šå…¥ã‚Œå£ï¼‰
            const airboxGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.8);
            const airboxMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const airbox = new THREE.Mesh(airboxGeometry, airboxMaterial);
            airbox.position.set(0, 1.0, 0.8);
            car.add(airbox);

            // ãƒªã‚¢ã‚¦ã‚¤ãƒ³ã‚°æœ¬ä½“ï¼ˆã‚ˆã‚Šè–„ãã€å¹…åºƒã«ï¼‰
            const rearWingGeometry = new THREE.BoxGeometry(2.2, 0.08, 0.6);
            const rearWingMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const rearWing = new THREE.Mesh(rearWingGeometry, rearWingMaterial);
            rearWing.position.set(0, 1.2, 2.2);
            car.add(rearWing);

            // ãƒªã‚¢ã‚¦ã‚¤ãƒ³ã‚°ã‚¨ãƒ³ãƒ‰ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå·¦ï¼‰
            const wingEndPlateGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.8);
            const leftWingEndPlate = new THREE.Mesh(wingEndPlateGeometry, rearWingMaterial);
            leftWingEndPlate.position.set(-1.1, 1.2, 2.2);
            car.add(leftWingEndPlate);

            // ãƒªã‚¢ã‚¦ã‚¤ãƒ³ã‚°ã‚¨ãƒ³ãƒ‰ãƒ—ãƒ¬ãƒ¼ãƒˆï¼ˆå³ï¼‰
            const rightWingEndPlate = leftWingEndPlate.clone();
            rightWingEndPlate.position.set(1.1, 1.2, 2.2);
            car.add(rightWingEndPlate);

            // ãƒªã‚¢ã‚¦ã‚¤ãƒ³ã‚°ã‚µãƒãƒ¼ãƒˆï¼ˆå·¦ï¼‰
            const wingPillarGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            const wingPillarMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const leftWingPillar = new THREE.Mesh(wingPillarGeometry, wingPillarMaterial);
            leftWingPillar.position.set(-0.8, 1.0, 2.2);
            car.add(leftWingPillar);

            // ãƒªã‚¢ã‚¦ã‚¤ãƒ³ã‚°ã‚µãƒãƒ¼ãƒˆï¼ˆå³ï¼‰
            const rightWingPillar = leftWingPillar.clone();
            rightWingPillar.position.set(0.8, 1.0, 2.2);
            car.add(rightWingPillar);

            // ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒŠãƒ³ãƒãƒ¼ï¼ˆ3ï¼‰- å·¦å´
            const leftNumberGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const leftNumberMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });
            const leftNumber = new THREE.Mesh(leftNumberGeometry, leftNumberMaterial);
            leftNumber.position.set(-1.21, 0.85, 0);
            leftNumber.rotation.y = Math.PI / 2;
            car.add(leftNumber);

            // ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒŠãƒ³ãƒãƒ¼ï¼ˆ3ï¼‰- å³å´
            const rightNumber = leftNumber.clone();
            rightNumber.position.set(1.21, 0.85, 0);
            rightNumber.rotation.y = -Math.PI / 2;
            car.add(rightNumber);

            // NAMCOãƒ­ã‚´ - å·¦å´
            const leftLogoGeometry = new THREE.PlaneGeometry(1.2, 0.3);
            const leftLogoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });
            const leftLogo = new THREE.Mesh(leftLogoGeometry, leftLogoMaterial);
            leftLogo.position.set(-1.21, 1.0, -0.5);
            leftLogo.rotation.y = Math.PI / 2;
            car.add(leftLogo);

            // NAMCOãƒ­ã‚´ - å³å´
            const rightLogo = leftLogo.clone();
            rightLogo.position.set(1.21, 1.0, -0.5);
            rightLogo.rotation.y = -Math.PI / 2;
            car.add(rightLogo);
            
            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¬ãƒ©ã‚¹ï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°é¢¨ã«ä½ãï¼‰
            const windshieldGeometry = new THREE.BoxGeometry(1.4, 0.25, 1.0);
            const windshieldMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.7
            });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 0.9, -0.4);
            windshield.rotation.x = Math.PI * 0.06;
            car.add(windshield);

            // ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹ãƒˆ
            const headrestGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.3);
            const headrestMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const headrest = new THREE.Mesh(headrestGeometry, headrestMaterial);
            headrest.position.set(0, 0.9, 0.4);
            car.add(headrest);

            // ãƒªã‚¢ãƒ‡ã‚£ãƒ•ãƒ¥ãƒ¼ã‚¶ãƒ¼
            const diffuserGeometry = new THREE.BoxGeometry(2.0, 0.15, 0.6);
            const diffuserMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const diffuser = new THREE.Mesh(diffuserGeometry, diffuserMaterial);
            diffuser.position.set(0, 0.35, 2.3);
            car.add(diffuser);

            // ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°é¢¨ã®å°å‹ãƒ©ã‚¤ãƒˆï¼‰
            const headlightGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.1);
            const headlightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 1.0
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(0.7, 0.65, -2.35);
            car.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(-0.7, 0.65, -2.35);
            car.add(rightHeadlight);
            
            // ãƒ˜ãƒƒãƒ‰ãƒ©ã‚¤ãƒˆã®ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ
            leftHeadlightLight = new THREE.SpotLight(0xFFFFFF, 1.5, 50, Math.PI / 6, 0.3, 1);
            leftHeadlightLight.position.set(0.6, 2.0, -2.0);
            leftHeadlightLight.target.position.set(0.3, 0.0, -20);
            leftHeadlightLight.visible = false;
            car.add(leftHeadlightLight);
            car.add(leftHeadlightLight.target);
            
            rightHeadlightLight = new THREE.SpotLight(0xFFFFFF, 1.5, 50, Math.PI / 6, 0.3, 1);
            rightHeadlightLight.position.set(-0.6, 2.0, -2.0);
            rightHeadlightLight.target.position.set(-0.3, 0.0, -20);
            rightHeadlightLight.visible = false;
            car.add(rightHeadlightLight);
            car.add(rightHeadlightLight.target);

            // ãƒ†ãƒ¼ãƒ«ãƒ©ã‚¤ãƒˆï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°é¢¨ã®ç´°é•·ã„ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
            const taillightGeometry = new THREE.BoxGeometry(1.0, 0.1, 0.1);
            const taillightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            
            const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillight.position.set(0, 0.85, 2.35);
            car.add(taillight);
            
            // ã‚µã‚¤ãƒ‰ã‚¨ã‚¢ã‚¤ãƒ³ãƒ†ãƒ¼ã‚¯ï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã‚«ãƒ¼é¢¨ï¼‰
            const intakeGeometry = new THREE.BoxGeometry(0.1, 0.4, 1.2);
            const intakeMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            
            const leftIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
            leftIntake.position.set(1.15, 0.75, 0.5);
            car.add(leftIntake);
            
            const rightIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
            rightIntake.position.set(-1.15, 0.75, 0.5);
            car.add(rightIntake);
            
            // ã‚¿ã‚¤ãƒ¤ã‚’ä½œæˆã™ã‚‹é–¢æ•°ï¼ˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ›ã‚¤ãƒ¼ãƒ«ï¼‰
            function createWheel(x, z) {
                const wheelGroup = new THREE.Group();
                
                // ã‚¿ã‚¤ãƒ¤æœ¬ä½“ï¼ˆãƒ¯ã‚¤ãƒ‰ã‚¿ã‚¤ãƒ¤ï¼‰
                const wheelGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16);
                const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheelGroup.add(wheel);
                
                // ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ãƒ›ã‚¤ãƒ¼ãƒ«
                const hubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.41, 12);
                const hubMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                hub.rotation.z = Math.PI / 2;
                wheelGroup.add(hub);
                
                // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯é¢¨ã®ã‚­ãƒ£ãƒƒãƒ—
                const capGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.42, 6);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.rotation.z = Math.PI / 2;
                wheelGroup.add(cap);
                
                // ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã‚¹ãƒãƒ¼ã‚¯
                for (let i = 0; i < 6; i++) {
                    const spokeGeometry = new THREE.BoxGeometry(0.04, 0.02, 0.35);
                    const spokeMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.x = (Math.PI * 2 / 6) * i;
                    spoke.position.y = 0;
                    wheelGroup.add(spoke);
                }
                
                wheelGroup.position.set(x, 0.4, z);
                car.add(wheelGroup);
                
                return { wheel, wheelGroup };
            }
            
            // 4ã¤ã®ã‚¿ã‚¤ãƒ¤ã‚’ä½œæˆï¼ˆãƒ¯ã‚¤ãƒ‰ãƒˆãƒ¬ãƒƒãƒ‰ï¼‰
            const frontLeftWheel = createWheel(-1.1, -1.7);
            const frontRightWheel = createWheel(1.1, -1.7);
            const rearLeftWheel = createWheel(-1.1, 1.7);
            const rearRightWheel = createWheel(1.1, 1.7);
            
            const wheels = [
                frontLeftWheel.wheel,
                frontRightWheel.wheel,
                rearLeftWheel.wheel,
                rearRightWheel.wheel
            ];
            
            const wheelGroups = [
                frontLeftWheel.wheelGroup,
                frontRightWheel.wheelGroup,
                rearLeftWheel.wheelGroup,
                rearRightWheel.wheelGroup
            ];
            
            // è»Šã®å‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¸¸ã«ä¸Šæ–¹å‘ï¼‰
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // è»Šã®åˆæœŸä½ç½®ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ï¼‰
            car.position.copy(carPath.getPointAt(0));
            car.position.y = 1.0; // åœ°é¢ã‹ã‚‰ã®é«˜ã•
            
            // è»Šã®åˆæœŸæ–¹å‘
            const initialTangent = carPath.getTangentAt(0);
            const initialDirection = new THREE.Vector3(initialTangent.x, 0, initialTangent.z).normalize();
            
            // è»Šã®å‘ãã‚’è¨­å®šï¼ˆYè»¸ã¯å¸¸ã«ä¸Šï¼‰
            const initialTarget = new THREE.Vector3().addVectors(car.position, initialDirection);
            car.lookAt(initialTarget);
            
            scene.add(car);
            
            return { car, wheels, wheelGroups, upVector };
        }
        
        const { car, wheels, wheelGroups, upVector } = createDetailedCar();
        
        log("è»Šã®ä½œæˆå®Œäº†");
        
        // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ï¼ˆ0: ä¿¯ç°, 1: è¿½å¾“, 2: è»Šè¼‰, 3: æ–œã‚è¦–ç‚¹ï¼‰
        let cameraMode = 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æ–œã‚è¦–ç‚¹ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š
        
        // ã‚«ãƒ¡ãƒ©ä½ç½®ã®åˆæœŸè¨­å®šï¼ˆæ–œã‚è¦–ç‚¹å‘ã‘ï¼‰
        camera.position.set(100, 70, 90); // æ–œã‚è¦–ç‚¹ã®åˆæœŸä½ç½®
        camera.lookAt(car.position);
        
        // è»Šã®ä½ç½®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        let carPosition = 0; // ãƒ‘ã‚¹ä¸Šã®ä½ç½®ï¼ˆ0ã‹ã‚‰1ï¼‰
        let carSpeed = 0.3;  // è»Šã®é€Ÿåº¦ï¼ˆ1åˆ†å‘¨å›ã«èª¿æ•´ï¼‰
        let targetSpeed = 0.3; // ç›®æ¨™é€Ÿåº¦ï¼ˆ1åˆ†å‘¨å›ã«èª¿æ•´ï¼‰
        
        // é€Ÿåº¦ã®ç¯„å›²ã‚’è¨­å®šï¼ˆã‚³ãƒ¼ã‚¹1å‘¨ç´„1åˆ†ã«ãªã‚‹ã‚ˆã†èª¿æ•´ï¼‰
        const MIN_SPEED = 0.25; // æœ€ä½é€Ÿåº¦
        const MAX_SPEED = 0.6; // æœ€é«˜é€Ÿåº¦
        const ACCELERATION_RATE = 0.01; // åŠ é€Ÿç‡ã‚’ä¸Šã’ã‚‹ï¼ˆ0.008ã‹ã‚‰0.01ã«ï¼‰
        const DECELERATION_RATE = 0.02; // æ¸›é€Ÿç‡ã‚‚ä¸Šã’ã‚‹ï¼ˆ0.015ã‹ã‚‰0.02ã«ï¼‰
        
        // å‰å›ã®ä½ç½®ã¨å›è»¢ã‚’ä¿å­˜ï¼ˆã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ç”¨ï¼‰
        let lastCarPosition = new THREE.Vector3();
        let lastCarRotation = new THREE.Quaternion();
        let lastCarUp = new THREE.Vector3(0, 1, 0);
        // å‰å›ã®å‚¾ãè§’åº¦ã‚’ä¿å­˜ï¼ˆæ»‘ã‚‰ã‹ãªå¤‰åŒ–ã®ãŸã‚ï¼‰
        let lastTiltAngle = 0;
        
        // åˆæœŸä½ç½®è¨­å®š
        lastCarPosition.copy(car.position);
        lastCarRotation.copy(car.quaternion);
        
        // ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆ
        window.addEventListener('keydown', (e) => {
            if (e.key === '1' || e.key === 'ï¼‘') {
                cameraMode = 0; // ä¿¯ç°
                log("ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰: ä¿¯ç°");
            } else if (e.key === '2' || e.key === 'ï¼’') {
                cameraMode = 1; // è¿½å¾“
                log("ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰: è¿½å¾“");
            } else if (e.key === '3' || e.key === 'ï¼“') {
                cameraMode = 2; // è»Šè¼‰
                log("ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰: è»Šè¼‰");
            } else if (e.key === '4' || e.key === 'ï¼”') {
                cameraMode = 4; // è»Šå‰æ–¹
                log("ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰: è»Šå‰æ–¹");
            } else if (e.key === '5' || e.key === 'ï¼•') {
                cameraMode = 3; // æ–œã‚ä¸Šè¦–ç‚¹
                log("ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰: æ–œã‚ä¸Šè¦–ç‚¹");
            }
        });
        
        // å¤šç‚¹ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§æ›²ç‡ã‚’è¨ˆç®—ï¼ˆã‚ˆã‚Šå®‰å®šã—ãŸå€¤ã‚’å¾—ã‚‹ãŸã‚ï¼‰
        function calculateCurvature(t, samplePoints = 15, sampleDistance = 0.005) {
            const angles = [];
            
            // è¤‡æ•°ã®ã‚µãƒ³ãƒ—ãƒ«ç‚¹ã§è§’åº¦ã‚’è¨ˆç®—ã—å¹³å‡ã‚’å–ã‚‹
            for (let i = 0; i < samplePoints - 1; i++) {
                const currentPos = (t + i * sampleDistance) % 1;
                const nextPos = (currentPos + sampleDistance) % 1;
                const nextNextPos = (nextPos + sampleDistance) % 1;
                
                const point = carPath.getPointAt(currentPos);
                const nextPoint = carPath.getPointAt(nextPos);
                const nextNextPoint = carPath.getPointAt(nextNextPos);
                
                const v1 = new THREE.Vector2(nextPoint.x - point.x, nextPoint.z - point.z).normalize();
                const v2 = new THREE.Vector2(nextNextPoint.x - nextPoint.x, nextNextPoint.z - nextPoint.z).normalize();
                
                // 2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«é–“ã®è§’åº¦
                const angle = Math.acos(Math.min(1, Math.max(-1, v1.dot(v2))));
                angles.push(angle);
            }
            
            // è§’åº¦ã®å¹³å‡å€¤ã‚’è¨ˆç®—
            const avgAngle = angles.reduce((sum, angle) => sum + angle, 0) / angles.length;
            
            // æ›²ãŒã‚‹æ–¹å‘ã®åˆ¤å®šï¼ˆä¸­å¤®ã®ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¤ãƒ³ãƒˆã§åˆ¤å®šï¼‰
            const middleIndex = Math.floor(samplePoints / 2);
            const currentPos = (t + middleIndex * sampleDistance) % 1;
            const nextPos = (currentPos + sampleDistance) % 1;
            const nextNextPos = (nextPos + sampleDistance) % 1;
            
            const pointStart = carPath.getPointAt(currentPos);
            const pointNext = carPath.getPointAt(nextPos);
            const pointNextNext = carPath.getPointAt(nextNextPos);
            
            const vec1 = new THREE.Vector2(pointNext.x - pointStart.x, pointNext.z - pointStart.z).normalize();
            const vec2 = new THREE.Vector2(pointNextNext.x - pointNext.x, pointNextNext.z - pointNext.z).normalize();
            
            // æ›²ãŒã‚Šæ–¹å‘ã‚’åˆ¤å®šï¼ˆå¤–ç©ï¼‰
            const crossProduct = vec1.x * vec2.y - vec1.y * vec2.x;
            const tiltDirection = Math.sign(crossProduct);
            
            return { angle: avgAngle, direction: tiltDirection };
        }
        
        // å‰æ–¹ã®ã‚«ãƒ¼ãƒ–ã‚’äºˆæ¸¬ã™ã‚‹é–¢æ•°
        function predictUpcomingCurve(currentPosition, lookAheadDistance = 0.05) {
            // ç¾åœ¨ã®ä½ç½®ã‹ã‚‰å°‘ã—å…ˆã®ä½ç½®ã§ã®ã‚«ãƒ¼ãƒ–å¼·åº¦ã‚’å–å¾—
            const upcomingPos = (currentPosition + lookAheadDistance) % 1;
            const curvatureData = calculateCurvature(upcomingPos);
            return curvatureData.angle;
        }
        
        // é€Ÿåº¦ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°ï¼ˆã‚¹ãƒ­ãƒ¼ã‚¤ãƒ³ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã‚¢ã‚¦ãƒˆï¼‰
        function updateSpeed() {
            // ç¾åœ¨ã®ã‚«ãƒ¼ãƒ–å¼·åº¦ã‚’å–å¾—
            const currentCurvature = calculateCurvature(carPosition).angle;
            
            // å‰æ–¹ã®ã‚«ãƒ¼ãƒ–å¼·åº¦ã‚’äºˆæ¸¬
            const upcomingCurvature = predictUpcomingCurve(carPosition, 0.05);
            
            // ã‚«ãƒ¼ãƒ–å¼·åº¦ã«åŸºã¥ã„ã¦ç›®æ¨™é€Ÿåº¦ã‚’è¨ˆç®—
            // æ›²ç‡ãŒå¤§ãã„ã»ã©é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹
            const curvatureThreshold = 0.03; // ã‚«ãƒ¼ãƒ–æ¤œå‡ºã®é–¾å€¤ï¼ˆå°‘ã—ä¸‹ã’ã¦ã‚ˆã‚Šæ—©ãã‚«ãƒ¼ãƒ–ã‚’æ¤œçŸ¥ï¼‰
            
            if (upcomingCurvature > curvatureThreshold) {
                // ã‚«ãƒ¼ãƒ–ãŒè¿‘ã¥ã„ã¦ã„ã‚‹å ´åˆï¼ˆã‚¹ãƒ­ãƒ¼ã‚¤ãƒ³ï¼‰
                // ã‚«ãƒ¼ãƒ–å¼·åº¦ã«å¿œã˜ã¦ç›®æ¨™é€Ÿåº¦ã‚’ä¸‹ã’ã‚‹
                const curveFactor = Math.min(1, upcomingCurvature / 0.08); // ã‚«ãƒ¼ãƒ–å¼·åº¦ã‚’0-1ã®ç¯„å›²ã«æ­£è¦åŒ–ï¼ˆå€¤ã‚’å°ã•ãã—ã¦ã‚ˆã‚Šæ•æ„Ÿã«ï¼‰
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7); // ã¹ãä¹—ã‚’ä½¿ã£ã¦æ€¥æ¿€ãªæ¸›é€Ÿã‚’å®Ÿç¾
            } else if (currentCurvature > curvatureThreshold / 2) {
                // ã‚«ãƒ¼ãƒ–ä¸­ã®å ´åˆ
                const curveFactor = Math.min(1, currentCurvature / 0.08);
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7);
            } else {
                // ã‚«ãƒ¼ãƒ–ã‚’æŠœã‘ãŸå ´åˆï¼ˆãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆã‚¢ã‚¦ãƒˆï¼‰
                targetSpeed = MAX_SPEED;
            }
            
            // ä¸‹ã‚Šå‚ã§ã¯å°‘ã—åŠ é€Ÿã€ä¸Šã‚Šå‚ã§ã¯å°‘ã—æ¸›é€Ÿ
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const point = carPath.getPointAt(carPosition);
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // å‚¾æ–œã‚’è¨ˆç®—
            const slope = Math.atan2(nextPoint.y - prevPoint.y, 
                Math.sqrt(Math.pow(nextPoint.x - prevPoint.x, 2) + Math.pow(nextPoint.z - prevPoint.z, 2)));
            
            // å‚¾æ–œã«å¿œã˜ã¦é€Ÿåº¦ã‚’èª¿æ•´ï¼ˆä¸‹ã‚Šå‚ã§åŠ é€Ÿã€ä¸Šã‚Šå‚ã§æ¸›é€Ÿï¼‰
            if (slope < -0.01) {
                // ä¸‹ã‚Šå‚
                targetSpeed *= (1.0 - slope); // å‚¾æ–œãŒå¤§ãã„ã»ã©åŠ é€Ÿ
            } else if (slope > 0.01) {
                // ä¸Šã‚Šå‚
                targetSpeed *= (1.0 - slope * 0.5); // å‚¾æ–œãŒå¤§ãã„ã»ã©æ¸›é€Ÿ
            }
            
            // ç¾åœ¨ã®é€Ÿåº¦ã‚’ç›®æ¨™é€Ÿåº¦ã«å¾ã€…ã«è¿‘ã¥ã‘ã‚‹ï¼ˆåŠ é€Ÿãƒ»æ¸›é€Ÿï¼‰
            if (carSpeed < targetSpeed) {
                // åŠ é€Ÿï¼ˆã‚†ã£ãã‚Šï¼‰
                carSpeed = Math.min(targetSpeed, carSpeed + ACCELERATION_RATE);
            } else if (carSpeed > targetSpeed) {
                // æ¸›é€Ÿï¼ˆç´ æ—©ãï¼‰
                carSpeed = Math.max(targetSpeed, carSpeed - DECELERATION_RATE);
            }
        }
        
        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã¨ç¾åœ¨ãƒ•ãƒ¬ãƒ¼ãƒ ã®å€¤ã‚’è£œé–“ã™ã‚‹é–¢æ•°
        function smoothValue(current, last, factor) {
            return last * (1 - factor) + current * factor;
        }
        
        // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªEasingè£œé–“ã‚’è¡Œã†é–¢æ•°ï¼ˆ2æ¬¡ã®ãƒ™ã‚¸ã‚§æ›²ç·šã«åŸºã¥ããªã‚ã‚‰ã‹ãªè£œé–“ï¼‰
        function smootherValue(target, current, speed, deltaTime = 1) {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã¯1ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼ˆ60fpsã‚’æƒ³å®šï¼‰
            const delta = (target - current);
            
            // éå¸¸ã«å°ã•ãªå¤‰åŒ–ã¯ç„¡è¦–ã™ã‚‹ï¼ˆãƒã‚¤ã‚ºã«ã‚ˆã‚‹å¾®å°å¤‰å‹•ã‚’é˜²æ­¢ï¼‰
            if (Math.abs(delta) < 0.001) {
                return current;
            }
            
            // ã‚ˆã‚Šè‡ªç„¶ãªå‹•ãã®ãŸã‚ã«3æ¬¡ã®ãƒ™ã‚¸ã‚§æ›²ç·šã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨
            // ã“ã‚Œã«ã‚ˆã‚Šã€ç›®æ¨™å€¤ã«è¿‘ã¥ãã»ã©å¾ã€…ã«æ¸›é€Ÿã™ã‚‹åŠ¹æœãŒå¾—ã‚‰ã‚Œã‚‹
            const easeFactor = Math.min(1.0, speed * deltaTime);
            
            // æ”¹è‰¯ã•ã‚ŒãŸã‚¹ãƒ ãƒ¼ã‚ºã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°ï¼ˆã‚ˆã‚Šé«˜æ¬¡ã®é–¢æ•°ã§æ»‘ã‚‰ã‹ã•ã‚’å‘ä¸Šï¼‰
            const t = Math.max(0, Math.min(1, easeFactor));
            const easeFactorCubic = t * t * (3 - 2 * t);
            const easeFactorQuintic = t * t * t * (t * (t * 6 - 15) + 10); // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãª5æ¬¡é–¢æ•°
            
            // äºŒã¤ã®é–¢æ•°ã‚’ãƒ–ãƒ¬ãƒ³ãƒ‰ï¼ˆå¤§ããªå¤‰åŒ–ã«ã¯5æ¬¡é–¢æ•°ã€å°ã•ãªå¤‰åŒ–ã«ã¯3æ¬¡é–¢æ•°ã‚’é©ç”¨ï¼‰
            const blendFactor = Math.min(1.0, Math.abs(delta) / 0.5);
            const finalEaseFactor = easeFactorCubic * (1 - blendFactor) + easeFactorQuintic * blendFactor;
            
            return current + delta * finalEaseFactor;
        }
        
        // éå»ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹å¤‰æ•°
        let lastFrameTime = Date.now();
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            
            // ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã‚’è¨ˆç®—
            currentFrameTime = Date.now(); // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’æ›´æ–°
            const deltaTime = (currentFrameTime - lastFrameTime) / 16.67; // 60fpsã‚’åŸºæº–ã«ã—ãŸå€¤
            lastFrameTime = currentFrameTime;
            
            // æ™‚é–“ã®æ›´æ–°ã¨æ˜¼å¤œã‚µã‚¤ã‚¯ãƒ«ã®é©ç”¨
            updateDayNightCycle();
            
            // å¤©æ°—ã®æ›´æ–°
            updateWeather(deltaTime);
            
            // é€Ÿåº¦ã‚’æ›´æ–°ï¼ˆã‚«ãƒ¼ãƒ–ã«å¿œã˜ã¦ï¼‰
            updateSpeed();
            
            // è»Šã®ä½ç½®ã‚’æ›´æ–°
            carPosition += carSpeed * 0.001;
            if (carPosition >= 1) carPosition -= 1;
            
            // é“è·¯ä¸Šã®ä½ç½®ã‚’å³å¯†ã«å–å¾—
            const point = carPath.getPointAt(carPosition);
            
            // ãƒ‘ã‚¹ã®æ¥ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’å–å¾—ï¼ˆé€²è¡Œæ–¹å‘ï¼‰
            const tangent = carPath.getTangentAt(carPosition).normalize();
            // XZå¹³é¢ä¸Šã®æ¥ç·šãƒ™ã‚¯ãƒˆãƒ«ï¼ˆé«˜ã•ã‚’ç„¡è¦–ï¼‰
            const flatTangent = new THREE.Vector3(tangent.x, 0, tangent.z).normalize();
            
            // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¨å‰ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å‚¾æ–œã‚’è¨ˆç®—ï¼ˆä¸Šã‚Šä¸‹ã‚Šã®è¨ˆç®—ç”¨ï¼‰
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—ï¼ˆYè»¸æ–¹å‘ã®å¤‰åŒ–ã‹ã‚‰ï¼‰
            const forwardSlope = Math.atan2(nextPoint.y - point.y, 
                Math.sqrt(Math.pow(nextPoint.x - point.x, 2) + Math.pow(nextPoint.z - point.z, 2)));
            
            // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ç¯„å›²ã‚’æ‹¡å¤§ã—ã¦ã€ã‚ˆã‚Šæ­£ç¢ºãªå‚¾æ–œã‚’å–å¾—
            // å°‘ã—åºƒã„ç¯„å›²ã§å‰å¾Œã®å‚¾æ–œã‚’è¨ˆç®—ã—ã¦ã‚ˆã‚Šå®‰å®šã•ã›ã‚‹
            const farNextPos = (carPosition + 0.02) % 1;
            const farPrevPos = (carPosition - 0.02 + 1) % 1;
            const farNextPoint = carPath.getPointAt(farNextPos);
            const farPrevPoint = carPath.getPointAt(farPrevPos);
            
            // åºƒã„ç¯„å›²ã§ã®å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—ï¼ˆæ€¥ãªå‚ã§ã®å¯¾å¿œå‘ä¸Šï¼‰
            const farForwardSlope = Math.atan2(farNextPoint.y - farPrevPoint.y, 
                Math.sqrt(Math.pow(farNextPoint.x - farPrevPoint.x, 2) + Math.pow(farNextPoint.z - farPrevPoint.z, 2)));
            
            // è¿‘è·é›¢ã¨é è·é›¢ã®å‚¾æ–œã‚’çµ„ã¿åˆã‚ã›ã¦ã€ã‚ˆã‚Šå®‰å®šã—ãŸå‚¾æ–œå€¤ã‚’å¾—ã‚‹
            const combinedSlope = (forwardSlope * 0.7 + farForwardSlope * 0.3);
            
            // æ›²ç‡ã‚’è¨ˆç®—
            const curvatureData = calculateCurvature(carPosition);
            const curveAngle = curvatureData.angle;
            const curveTiltDirection = curvatureData.direction;
            
            // ãƒã‚¤ã‚ºãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° - éå¸¸ã«å°ã•ãªæ›²ç‡å¤‰åŒ–ã‚’ç„¡è¦–
            // ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ãšã‹ãªé“è·¯ã®æºã‚Œãªã©ã«ã‚ˆã‚‹ä¸è¦ãªåå¿œã‚’é˜²æ­¢
            const minCurvatureThreshold = 0.005; // æœ€å°é–¾å€¤ä»¥ä¸‹ã¯çœŸã£ç›´ãã¨ã¿ãªã™
            const filteredCurveAngle = Math.abs(curveAngle) < minCurvatureThreshold ? 0 : curveAngle;
            const filteredDirection = filteredCurveAngle === 0 ? 0 : curveTiltDirection;
            
            // è»Šã®é«˜ã•ã¯é“è·¯ã®é«˜ã•ã«åˆã‚ã›ã‚‹
            const carHeight = point.y + 0.3; // é“è·¯ã®é«˜ã•ã«å¯¾ã—ã¦å°‘ã—ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            
            // ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã‚’å…ˆã«è¨ˆç®—ï¼ˆä»–ã®å ´æ‰€ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ï¼‰
            const speedFactor = Math.min(1.0, carSpeed / 0.7); // é€Ÿåº¦ã«ã‚ˆã‚‹èª¿æ•´ä¿‚æ•°
            
            // ---------- è»Šã®å›è»¢æ–¹å‘ã®è¨ˆç®—ï¼ˆå…ˆã«è¡Œã†ï¼‰ ----------
            
            // 1. é€²è¡Œæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¸¸ã«XZå¹³é¢ã«å¹³è¡Œï¼‰
            const forwardVector = flatTangent;
            
            // 2. ä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¸¸ã«ä¸–ç•Œåº§æ¨™ã®Yè»¸æ–¹å‘ï¼‰
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // 3. å³å‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã¨ä¸Šå‘ãã®å¤–ç©ï¼‰
            const rightVector = new THREE.Vector3().crossVectors(forwardVector, upVector).normalize();
            
            // 4. æœ€çµ‚çš„ãªä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆå³å‘ãã¨é€²è¡Œæ–¹å‘ã®å¤–ç©ã§å†è¨ˆç®—ã€å³å¯†ã«ç›´äº¤ã•ã›ã‚‹ï¼‰
            const correctedUpVector = new THREE.Vector3().crossVectors(rightVector, forwardVector).normalize();
            
            // ---------- ã‚¢ã‚¦ãƒˆã‚¤ãƒ³ã‚¢ã‚¦ãƒˆèµ°æ³•ã®ãŸã‚ã®è©³ç´°ãªè·¯ç·šè¨ˆç®— ----------
            
            // é“è·¯ã®å¹…ã«å¿œã˜ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡ã‚’èª¿æ•´ï¼ˆã‚ˆã‚Šå¤§ããªã‚ªãƒ•ã‚»ãƒƒãƒˆã«èª¿æ•´ï¼‰
            const pathOffsetAmount = 4.0; // å…ƒã®å€¤ã«æˆ»ã™
            
            // æ›²ç‡ã‚’ã‚ˆã‚Šæ­£ç¢ºã«è¨ˆç®—ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
            const detailedSamplePoints = 20;
            const detailedSampleDistance = 0.004;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼æ¤œå‡ºã®ãŸã‚ã®è¤‡æ•°ã®ãƒã‚¤ãƒ³ãƒˆã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
            const lookAheadDistances = [0.15, 0.1, 0.05, 0.03];
            const lookBehindDistances = [0.05, 0.02];
            
            // å„è·é›¢ã§ã®ã‚«ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’é©ç”¨ï¼‰
            const filteredAheadCurveData = lookAheadDistances.map(dist => {
                const data = calculateCurvature((carPosition + dist) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            const filteredBehindCurveData = lookBehindDistances.map(dist => {
                const data = calculateCurvature((carPosition - dist + 1) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸæ›²ç‡ã‚’ä½¿ç”¨
            const filteredAheadAngles = filteredAheadCurveData.map(data => data.angle);
            const filteredBehindAngles = filteredBehindCurveData.map(data => data.angle);
            
            // æœ€å¤§ã®æ›²ç‡ã¨ãã®æ–¹å‘ã‚’ç‰¹å®š
            const maxAheadAngle = Math.max(...filteredAheadAngles);
            const maxAheadIndex = filteredAheadAngles.indexOf(maxAheadAngle);
            const maxAheadDirection = filteredAheadCurveData[maxAheadIndex].direction;
            
            const maxBehindAngle = Math.max(...filteredBehindAngles);
            const maxBehindIndex = filteredBehindAngles.indexOf(maxBehindAngle);
            const maxBehindDirection = filteredBehindCurveData[maxBehindIndex].direction;
            
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨ˆç®—ç”¨ã®å¤‰æ•°ã®åˆæœŸåŒ–
            if (typeof lastPathOffset === 'undefined') {
                window.lastPathOffset = 0;
                window.lastCornerState = 'straight';
                window.cornerState = 'straight';
                window.stateChangeTime = 0;
                window.cornerHistory = []; 
                window.targetPathOffset = 0;
                window.cornerDetectionHistory = [];
                window.directionHistory = [];
                window.intermediateOffset = 0;
            }
            
            // ç¾åœ¨ã®æ›²ç‡ã‚’å±¥æ­´ã«è¿½åŠ ï¼ˆæœ€æ–°ã®30ã‚µãƒ³ãƒ—ãƒ«ã‚’ä¿æŒï¼‰
            if (!Array.isArray(window.cornerHistory)) {
                window.cornerHistory = [];
            }
            window.cornerHistory.push(filteredCurveAngle);
            if (window.cornerHistory.length > 30) {
                window.cornerHistory.shift();
            }
            
            // æ›²ç‡å±¥æ­´ã®å¹³å‡ã‚’è¨ˆç®—ï¼ˆãƒã‚¤ã‚ºã‚’é™¤å»ï¼‰- é‡ã¿ä»˜ãå¹³å‡ã‚’å°å…¥ã—ã¦æœ€æ–°ã®å€¤ã‚’ã‚ˆã‚Šé‡è¦–
            let totalWeight = 0;
            let weightedSum = 0;
            for (let i = 0; i < window.cornerHistory.length; i++) {
                // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã»ã©é‡ã¿ã‚’å¤§ããã™ã‚‹ï¼ˆæœ€æ–°ã®ãƒ‡ãƒ¼ã‚¿ãŒæœ€ã‚‚é‡è¦ï¼‰
                const weight = Math.pow(1.1, i);
                weightedSum += window.cornerHistory[window.cornerHistory.length - 1 - i] * weight;
                totalWeight += weight;
            }
            const avgCurveAngle = weightedSum / totalWeight;
            
            // æ–¹å‘ã®ä¸€è²«æ€§ç¢ºèªã®ãŸã‚ã€æ–¹å‘å±¥æ­´ã‚‚ä¿æŒ
            if (!Array.isArray(window.directionHistory)) {
                window.directionHistory = [];
            }
            window.directionHistory.push(filteredDirection); // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã•ã‚ŒãŸæ–¹å‘ã‚’ä½¿ç”¨
            if (window.directionHistory.length > 20) {
                window.directionHistory.shift();
            }
            
            // æ–¹å‘ã®å¤šæ•°æ±ºã‚’å–ã‚‹ï¼ˆæœ€é »å€¤ã‚’æ¡ç”¨ï¼‰
            const directionCounts = {};
            let maxCount = 0;
            let dominantDirection = 0;
            
            window.directionHistory.forEach(dir => {
                directionCounts[dir] = (directionCounts[dir] || 0) + 1;
                if (directionCounts[dir] > maxCount) {
                    maxCount = directionCounts[dir];
                    dominantDirection = dir;
                }
            });
            
            // ã‚«ãƒ¼ãƒ–ã®æ–¹å‘ã¨ã—ã¦æ”¯é…çš„ãªæ–¹å‘ã‚’ä½¿ç”¨
            const stableCurveTiltDirection = dominantDirection;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼æ¤œå‡ºç”¨ã®ãƒ¢ãƒ‡ãƒ«ã‚’æ§‹ç¯‰
            // å„ä½ç½®ã®æ›²ç‡æƒ…å ±ã‚’å…ƒã«ã€ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã‚’åˆ¤æ–­ã™ã‚‹ãŸã‚ã®ç‰¹å¾´é‡ã‚’ä½œæˆ
            const cornerDetectionFeatures = {
                current: avgCurveAngle,               // ç¾åœ¨åœ°ç‚¹ã®æ›²ç‡ï¼ˆå¹³å‡åŒ–æ¸ˆã¿ï¼‰
                ahead: filteredAheadAngles,           // è¤‡æ•°ã®å…ˆèª­ã¿åœ°ç‚¹ã®æ›²ç‡ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ¸ˆã¿ï¼‰
                behind: filteredBehindAngles,         // è¤‡æ•°ã®å¾Œèª­ã¿åœ°ç‚¹ã®æ›²ç‡ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ¸ˆã¿ï¼‰
                maxAhead: maxAheadAngle,              // æœ€å¤§ã®å…ˆèª­ã¿æ›²ç‡
                maxBehind: maxBehindAngle,            // æœ€å¤§ã®å¾Œèª­ã¿æ›²ç‡
                direction: stableCurveTiltDirection,  // å®‰å®šåŒ–ã•ã‚ŒãŸç¾åœ¨ã®æ›²ãŒã‚Šæ–¹å‘
                aheadDirection: maxAheadDirection,    // å…ˆã®ã‚«ãƒ¼ãƒ–ã®æ›²ãŒã‚Šæ–¹å‘
                behindDirection: maxBehindDirection,  // å¾Œã‚ã®ã‚«ãƒ¼ãƒ–ã®æ›²ãŒã‚Šæ–¹å‘
                speed: carSpeed                       // ç¾åœ¨ã®é€Ÿåº¦
            };
            
            // ã‚³ãƒ¼ãƒŠãƒ¼æ¤œå‡ºæƒ…å ±ã‚’å±¥æ­´ã«è¿½åŠ ï¼ˆçŠ¶æ…‹å¤‰æ›´ã®å®‰å®šæ€§å‘ä¸Šã®ãŸã‚ï¼‰
            if (!Array.isArray(window.cornerDetectionHistory)) {
                window.cornerDetectionHistory = [];
            }
            window.cornerDetectionHistory.push(cornerDetectionFeatures);
            if (window.cornerDetectionHistory.length > 15) {
                window.cornerDetectionHistory.shift();
            }
            
            // æ›²ç‡ã®æ€¥æ¿€ãªå¤‰åŒ–ã‚’æ¤œå‡ºã™ã‚‹ãŸã‚ã®é–¾å€¤
            const curvatureThreshold = 0.015;  // é€šå¸¸ã®ã‚«ãƒ¼ãƒ–æ¤œå‡ºé–¾å€¤
            const entryThreshold = 0.014;      // ã‚³ãƒ¼ãƒŠãƒ¼é€²å…¥æ¤œå‡ºé–¾å€¤
            const apexThreshold = 0.018;       // ã‚³ãƒ¼ãƒŠãƒ¼é ‚ç‚¹æ¤œå‡ºé–¾å€¤
            const exitThreshold = 0.015;       // ã‚³ãƒ¼ãƒŠãƒ¼å‡ºå£æ¤œå‡ºé–¾å€¤
            const hysteresis = 0.008;          // ãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹
            
            // çŠ¶æ…‹å¤‰æ›´ã®æ™‚é–“åˆ¶é™ï¼ˆæ€¥æ¿€ãªçŠ¶æ…‹å¤‰æ›´ã‚’é˜²æ­¢ï¼‰- ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã«å¿œã˜ã¦èª¿æ•´
            const baseStateChangeDuration = 800; // åŸºæœ¬ã®æœ€å°çŠ¶æ…‹å¤‰æ›´é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
            const speedBasedDuration = baseStateChangeDuration * (1.0 + speedFactor * 0.5); // é«˜é€Ÿæ™‚ã¯ã‚ˆã‚Šé•·ã„é–“éš”
            const minStateChangeDuration = Math.min(1200, speedBasedDuration); // æœ€å¤§1.2ç§’ã¾ã§
            
            const currentTime = Date.now();
            const canChangeState = (currentTime - window.stateChangeTime) > minStateChangeDuration;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼æ¤œå‡ºå±¥æ­´ã®å®‰å®šæ€§ç¢ºèªï¼ˆå¿…è¦ãªãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã‚’å¢—ã‚„ã—ã¦å®‰å®šæ€§å‘ä¸Šï¼‰
            const isStableAheadCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxAhead > entryThreshold).length >= 5;
            
            const isStableCurrentCurve = window.cornerDetectionHistory.filter(
                hist => hist.current > apexThreshold).length >= 5;
            
            const isStableBehindCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxBehind > exitThreshold).length >= 5;
            
            // é€£ç¶šã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ã§ã®åŒä¸€æ–¹å‘æ€§ã®ç¢ºèªï¼ˆæ–¹å‘ã®ä¸€è²«æ€§ã‚’ãƒã‚§ãƒƒã‚¯ï¼‰
            const aheadDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.aheadDirection === arr[i-1].aheadDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            const behindDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.behindDirection === arr[i-1].behindDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            // æ–¹å‘ã®ä¸€è²«æ€§ãŒé«˜ã„å ´åˆã®ã¿çŠ¶æ…‹é·ç§»ã‚’è¨±å¯ï¼ˆæ–¹å‘ãŒå®‰å®šã—ã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰
            const directionStability = Math.min(aheadDirectionConsistency, behindDirectionConsistency);
            const hasStableDirection = directionStability > 0.7;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹ã®é·ç§»åˆ¤å®šã‚’å®‰å®šæ€§ã‚’è€ƒæ…®ã—ã¦è¡Œã†
            let newCornerState = window.cornerState;
            
            if (canChangeState && hasStableDirection) {
                // ã‚³ãƒ¼ãƒŠãƒ¼é€²å…¥æ¤œå‡ºï¼ˆå…ˆã®å®‰å®šã—ãŸã‚«ãƒ¼ãƒ–ã‚’æ¤œå‡ºï¼‰
                if (maxAheadAngle > entryThreshold && 
                    maxAheadAngle > (avgCurveAngle + hysteresis) &&
                    maxAheadDirection !== 0 && // æ–¹å‘ãŒ0ã§ãªã„å ´åˆã®ã¿ï¼ˆæœ‰åŠ¹ãªã‚«ãƒ¼ãƒ–æ–¹å‘ï¼‰
                    isStableAheadCurve && 
                    window.cornerState !== 'entry') {
                    
                    newCornerState = 'entry';
                    window.stateChangeTime = currentTime;
                } 
                // ã‚³ãƒ¼ãƒŠãƒ¼ä¸­é–“ï¼ˆç¾åœ¨åœ°ç‚¹ã§å¤§ããªæ›²ç‡ã‚’æ¤œå‡ºï¼‰
                else if (avgCurveAngle > apexThreshold && 
                        stableCurveTiltDirection !== 0 && // æœ‰åŠ¹ãªã‚«ãƒ¼ãƒ–æ–¹å‘
                        isStableCurrentCurve &&
                        window.cornerState !== 'apex' && 
                        (window.cornerState === 'entry' || maxAheadAngle > entryThreshold)) {
                    
                    newCornerState = 'apex';
                    window.stateChangeTime = currentTime;
                } 
                // ã‚³ãƒ¼ãƒŠãƒ¼å‡ºå£ï¼ˆå¾Œæ–¹ã®å®‰å®šã—ãŸã‚«ãƒ¼ãƒ–ã‚’æ¤œå‡ºï¼‰
                else if (maxBehindAngle > exitThreshold && 
                        maxBehindAngle > (avgCurveAngle + hysteresis) &&
                        maxBehindDirection !== 0 && // æœ‰åŠ¹ãªã‚«ãƒ¼ãƒ–æ–¹å‘
                        isStableBehindCurve &&
                        window.cornerState === 'apex') {
                    
                    newCornerState = 'exit';
                    window.stateChangeTime = currentTime;
                } 
                // ç›´ç·šåŒºé–“ï¼ˆæ›²ç‡ãŒååˆ†ã«å°ã•ããªã£ãŸå ´åˆï¼‰
                else if (avgCurveAngle < (curvatureThreshold - hysteresis * 2) && 
                        maxBehindAngle < (exitThreshold - hysteresis) &&
                        maxAheadAngle < (entryThreshold - hysteresis) &&
                        window.cornerState === 'exit') {
                    
                    newCornerState = 'straight';
                    window.stateChangeTime = currentTime;
                }
            }
            
            // çŠ¶æ…‹ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€å‰ã®çŠ¶æ…‹ã‚’è¨˜éŒ²
            if (newCornerState !== window.cornerState) {
                window.lastCornerState = window.cornerState;
                window.cornerState = newCornerState;
                console.log("ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹å¤‰æ›´: " + window.cornerState); // ãƒ‡ãƒãƒƒã‚°ç”¨
            }
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®æ›²ãŒã‚Šæ–¹å‘ã‚’æ±ºå®šï¼ˆã‚ˆã‚Šå®‰å®šã—ãŸæ–¹å‘ã‚’ä½¿ç”¨ï¼‰
            // å®‰å®šåŒ–ã•ã‚ŒãŸæ–¹å‘ã‚’ä½¿ç”¨
            const cornerTiltDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // å„ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹ã«åŸºã¥ã„ã¦ç›®æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’è¨­å®š
            let targetOffset = 0;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹ã«åŸºã¥ã„ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
            switch (window.cornerState) {
                case 'entry':
                    // é€²å…¥æ™‚ã¯ã‚¢ã‚¦ãƒˆå´ã‹ã‚‰å…¥ã‚‹ï¼ˆã‚ˆã‚Šå¤§ããªã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
                    targetOffset = -pathOffsetAmount * 1.5 * cornerTiltDirection;
                    // æ›²ç‡ã«å¿œã˜ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡ã‚’èª¿æ•´ï¼ˆæ›²ç‡ã«å¯¾ã™ã‚‹æ„Ÿåº¦å‘ä¸Šï¼‰
                    targetOffset *= Math.min(1.0, Math.pow(maxAheadAngle / 0.04, 0.7));
                    break;
                    
                case 'apex':
                    // é ‚ç‚¹ã§ã¯ã‚¤ãƒ³å´ã«å¯„ã›ã‚‹ï¼ˆã‚ˆã‚Šå¼·ãã‚¤ãƒ³ã‚’æ”»ã‚ã‚‹ï¼‰
                    targetOffset = pathOffsetAmount * 1.2 * cornerTiltDirection;
                    // æ›²ç‡ã«å¿œã˜ã¦èª¿æ•´ï¼ˆã‚ˆã‚Šå¼·ã‚ã«ã‚¤ãƒ³ã‚’æ”»ã‚ã‚‹ï¼‰
                    targetOffset *= Math.min(1.0, Math.pow(avgCurveAngle / 0.04, 0.6));
                    break;
                    
                case 'exit':
                    // å‡ºå£ã§ã¯å†ã³ã‚¢ã‚¦ãƒˆå´ã«å¤§ããè†¨ã‚‰ã‚€
                    targetOffset = -pathOffsetAmount * 1.8 * cornerTiltDirection;
                    // æ›²ç‡ã«å¿œã˜ã¦èª¿æ•´ï¼ˆã‚ˆã‚Šæ•æ„Ÿã«åå¿œï¼‰
                    targetOffset *= Math.min(1.0, Math.pow(maxBehindAngle / 0.04, 0.7));
                    break;
                    
                case 'straight':
                default:
                    // ç›´ç·šã§ã¯å°‘ã—ä¸­å¤®ã‹ã‚‰å¤–å´ã«å¯„ã›ã‚‹ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªãƒ‰ãƒ©ã‚¤ãƒ“ãƒ³ã‚°ãƒ©ã‚¤ãƒ³ï¼‰
                    targetOffset = 0.5 * (window.lastCornerState === 'exit' ? -cornerTiltDirection : 0);
                    break;
            }
            
            // ã‚¹ãƒ”ãƒ¼ãƒ‰ãŒé€Ÿã„ã»ã©ã‚¢ã‚¦ãƒˆã‚’å¤§ããå–ã‚‹ï¼ˆé«˜é€Ÿã‚³ãƒ¼ãƒŠãƒªãƒ³ã‚°ã®æŒ™å‹•å‘ä¸Šï¼‰
            const speedFactorForOffset = speedFactor * 0.7; // é€Ÿåº¦ã«ã‚ˆã‚‹è¿½åŠ ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆã‚ˆã‚Šå¼·èª¿ï¼‰
            targetOffset *= (1 + speedFactorForOffset);
            
            // é“è·¯ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åˆ¶é™
            // è»Šã®å¹…ã‚’è€ƒæ…®ã—ãŸå®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ï¼ˆè»Šã®å¹…ã®åŠåˆ†+ä½™è£•ï¼‰
            window.carWidth = 2.5; // è»Šã®å¹…ã®æ¦‚ç®—
            window.safetyMargin = window.carWidth / 2 + 0.5; // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
            
            // é“è·¯ã®æœ‰åŠ¹å¹…ï¼ˆé“è·¯ã®ç«¯ã‹ã‚‰ã®å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã‚’å¼•ã„ãŸå€¤ï¼‰
            window.effectiveRoadHalfWidth = (roadWidth / 2) - window.safetyMargin;
            
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒé“è·¯ã®æœ‰åŠ¹å¹…ã‚’è¶…ãˆãªã„ã‚ˆã†ã«åˆ¶é™
            targetOffset = Math.max(-window.effectiveRoadHalfWidth, Math.min(window.effectiveRoadHalfWidth, targetOffset));
            
            window.targetPathOffset = targetOffset;
            
            // å®Ÿéš›ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå€¤ã‚’ç®—å‡ºï¼ˆã‚ˆã‚Šæ»‘ã‚‰ã‹ãªè£œé–“ï¼‰
            // æ”¹è‰¯ã•ã‚ŒãŸEasingè£œé–“é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦è‡ªç„¶ãªå‹•ãã‚’å®Ÿç¾
            const baseTransitionSpeed = 0.05; // åŸºæœ¬ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³é€Ÿåº¦ï¼ˆã‚ˆã‚Šå°ã•ãã—ã¦å®‰å®šæ€§å‘ä¸Šï¼‰
            const speedAdjustedTransition = baseTransitionSpeed * (1.0 - speedFactor * 0.4); // é«˜é€Ÿæ™‚ã¯é…ã„å¤‰åŒ–
            const transitionSpeed = Math.max(0.02, speedAdjustedTransition); // æœ€å°å€¤ã‚’è¨­å®š
            
            // Easingé–¢æ•°ã«ã‚ˆã‚‹äºŒé‡ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚° - éå¸¸ã«æ»‘ã‚‰ã‹ãªå‹•ãã‚’å®Ÿç¾
            // ä¸€æ™‚çš„ãªä¸­é–“å€¤ã‚’è¨ˆç®—ã—ã¦ã‹ã‚‰ã•ã‚‰ã«ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
            if (typeof window.intermediateOffset === 'undefined') {
                window.intermediateOffset = window.lastPathOffset;
            }
            
            // äºŒæ®µéšã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ã§éå¸¸ã«æ»‘ã‚‰ã‹ãªå‹•ãã‚’å®Ÿç¾
            window.intermediateOffset = smootherValue(window.targetPathOffset, window.intermediateOffset, transitionSpeed * 1.5, deltaTime);
            const pathOffset = smootherValue(window.intermediateOffset, window.lastPathOffset, transitionSpeed, deltaTime);
            window.lastPathOffset = pathOffset;
            
            // é“è·¯ã®æœ‰åŠ¹å¹…ã¯ã™ã§ã«è¨ˆç®—æ¸ˆã¿ï¼ˆwindow.effectiveRoadHalfWidthã‚’ä½¿ç”¨ï¼‰
            
            // æ¥ç·šæ–¹å‘ã«å¯¾ã—ã¦å‚ç›´ãªã‚ªãƒ•ã‚»ãƒƒãƒˆãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
            const offsetVector = rightVector.clone().multiplyScalar(pathOffset);
            
            // é“è·¯ã®ç«¯ã«è¿‘ã¥ã„ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const edgeProximityThreshold = 0.8; // é“è·¯ç«¯ã‹ã‚‰ã®è·é›¢ãŒå®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã®ä½•å€ä»¥ä¸‹ã§è­¦å‘Šã™ã‚‹ã‹
            const edgeProximity = Math.abs(pathOffset) / window.effectiveRoadHalfWidth;
            
            // åˆå›å®Ÿè¡Œæ™‚ã«æ—¢å­˜ã®è­¦å‘Šè¦ç´ ã‚’å‰Šé™¤ï¼ˆè­¦å‘Šè¡¨ç¤ºæ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–ï¼‰
            if (window.edgeWarningElement && !window.edgeWarningRemovalAttempted) {
                if (window.edgeWarningElement.parentNode) {
                    window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                }
                window.edgeWarningElement = null;
                window.edgeWarningRemovalAttempted = true;
            }
            
            // é“è·¯ç«¯ã«è¿‘ã¥ã„ã¦ã„ã‚‹å ´åˆã€è‡ªå‹•è£œæ­£ã¨è­¦å‘Š
            if (edgeProximity > edgeProximityThreshold) {
                // é“è·¯ç«¯ã«è¿‘ã„ã»ã©å¼·ãä¸­å¤®æ–¹å‘ã¸ã®è£œæ­£åŠ›ã‚’é©ç”¨
                const correctionFactor = Math.pow((edgeProximity - edgeProximityThreshold) / (1 - edgeProximityThreshold), 2) * 0.3;
                const correctionDirection = pathOffset > 0 ? -1 : 1;
                const correctionVector = rightVector.clone().multiplyScalar(correctionFactor * correctionDirection);
                
                // è£œæ­£ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿½åŠ 
                offsetVector.add(correctionVector);
                
                // è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºéƒ¨åˆ†ã‚’å‰Šé™¤ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«ã‚ˆã‚Šï¼‰
            } else if (window.edgeWarningElement) {
                // æ—¢å­˜ã®è­¦å‘Šè¦ç´ ãŒã‚ã‚Œã°éè¡¨ç¤ºã«ã—ã¦å‰Šé™¤
                window.edgeWarningElement.style.opacity = '0';
                
                // ä¸€å®šæ™‚é–“å¾Œã«è¦ç´ ã‚’å®Œå…¨ã«å‰Šé™¤
                setTimeout(() => {
                    if (window.edgeWarningElement && window.edgeWarningElement.parentNode) {
                        window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                        window.edgeWarningElement = null;
                    }
                }, 500);
            }
            
            // è»Šã®åŸºæœ¬ä½ç½®ã‚’å–å¾—
            const basePosition = point.clone();
            
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
            const offsetPosition = basePosition.add(offsetVector);
            
            // è»Šã®ä½ç½®ã‚’è¨­å®š
            car.position.set(offsetPosition.x, carHeight, offsetPosition.z);
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã‚’ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
            const cornerStateEmoji = {
                'straight': 'â†’',
                'entry': 'â†˜',
                'apex': 'â†“',
                'exit': 'â†—'
            };
            const cornerEmoji = cornerStateEmoji[window.cornerState] || 'â†’';
            
            // ã‚¹ã‚¿ã‚¤ãƒ«ã‚«ãƒ©ãƒ¼ã‚’ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰æ›´
            const cornerStateColor = {
                'straight': 'white',
                'entry': 'yellow',
                'apex': 'red',
                'exit': 'green'
            };
            const cornerColor = cornerStateColor[window.cornerState] || 'white';
            
            // ---------- å›è»¢è¨ˆç®—ã®æ®‹ã‚Šã®éƒ¨åˆ† ----------
            
            // 5. å›è»¢è¡Œåˆ—ã‚’ä½œæˆï¼ˆ3ã¤ã®ç›´äº¤ãƒ™ã‚¯ãƒˆãƒ«ã‹ã‚‰ï¼‰
            const rotationMatrix = new THREE.Matrix4().makeBasis(
                rightVector,
                correctedUpVector,
                forwardVector.clone().negate() // THREE.jsã®è»Šãƒ¢ãƒ‡ãƒ«ã¯Z-æ–¹å‘ãŒå‰æ–¹ãªã®ã§åè»¢
            );
            
            // 6. å›è»¢è¡Œåˆ—ã‹ã‚‰ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
            const targetRotation = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
            
            // 7. å›è»¢ã‚’ç›´æ¥é©ç”¨ï¼ˆã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ãªã— - å®‰å®šæ€§å„ªå…ˆï¼‰
            car.quaternion.copy(targetRotation);
            
            // 8. ä¸Šã‚Šä¸‹ã‚Šã®å‚¾æ–œã‚’åæ˜ ï¼ˆé€²è¡Œæ–¹å‘ã«åˆã‚ã›ã¦ãƒ”ãƒƒãƒè§’ã‚’é©ç”¨ï¼‰
            // combinedSlopeã‚’ä½¿ã£ã¦è»Šã‚’å‚¾ã‘ã‚‹ï¼ˆå€¤ã‚’èª¿æ•´ã—ã¦å‚¾ãã‚’å¼·èª¿ï¼‰
            // ãƒã‚¤ãƒŠã‚¹ç¬¦å·ã‚’é™¤å»ã—ã¦å‚¾æ–œã®é©ç”¨ã‚’æ­£ã—ãä¿®æ­£
            car.rotateX(combinedSlope * 1.5);
            
            // 9. ã‚«ãƒ¼ãƒ–ã«å¿œã˜ãŸå¾®å°ãªæ¨ªå‚¾æ–œï¼ˆZè»¸å›è»¢ï¼‰
            // éå¸¸ã«å°ã•ãªå€¤ã«åˆ¶é™ã—ã€å›è»¢è¡Œåˆ—ã«å½±éŸ¿ã‚’ä¸ãˆãªã„ã‚ˆã†ã«ã™ã‚‹
            const maxTilt = 0.005; // ç´„0.3åº¦ã«åˆ¶é™
            const tiltFactor = Math.min(maxTilt, curveAngle * carSpeed * 0.02);
            
            // æ¨ªå‚¾æ–œã‚’åˆ¥é€”é©ç”¨ï¼ˆæ—¢å­˜ã®å›è»¢ã«å°ã•ãªä¿®æ­£ã¨ã—ã¦è¿½åŠ ï¼‰
            car.rotateZ(-tiltFactor * curveTiltDirection);
            
            // ã‚¿ã‚¤ãƒ¤ã®å›è»¢ã¨ä½ç½®èª¿æ•´
            const wheelRotationSpeed = carSpeed * 0.3; // å›è»¢é€Ÿåº¦ä¿‚æ•°ã‚’0.2ã‹ã‚‰0.3ã«ä¸Šã’ã‚‹
            
            // ãƒ•ãƒ­ãƒ³ãƒˆã‚¿ã‚¤ãƒ¤ã®ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦è¨ˆç®—
            // æ›²ç‡ãŒå¤§ãã„ã»ã©ã€å¤§ããã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã™ã‚‹
            // curvatureDataã‹ã‚‰æ›²ç‡ã‚’å–å¾—ã€æ–¹å‘ã‚‚è€ƒæ…®
            const baseSteeringMultiplier = 3.5; // åŸºæœ¬ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ä¿‚æ•°
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã«å¿œã˜ã¦ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ä¿‚æ•°ã‚’èª¿æ•´ï¼ˆã‚ˆã‚Šè‡ªç„¶ãªæŒ™å‹•ï¼‰
            let steeringMultiplier = baseSteeringMultiplier;
            
            // ã‚³ãƒ¼ãƒŠãƒ¼é€²å…¥æ™‚ã¯ã‚ˆã‚Šç©æ¥µçš„ã«ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã€é ‚ç‚¹ã§ã¯ç¶­æŒã€å‡ºå£ã§ã¯å¾ã€…ã«æˆ»ã™
            if (window.cornerState === 'entry') {
                // ã‚³ãƒ¼ãƒŠãƒ¼é€²å…¥æ™‚ã¯æ—©ã‚ã«å¤§ããã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°
                steeringMultiplier = baseSteeringMultiplier * 1.2;
            } else if (window.cornerState === 'apex') {
                // ã‚³ãƒ¼ãƒŠãƒ¼é ‚ç‚¹ã§ã¯æ¨™æº–çš„ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°
                steeringMultiplier = baseSteeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // ã‚³ãƒ¼ãƒŠãƒ¼å‡ºå£ã§ã¯å¾ã€…ã«ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã‚’æˆ»ã™
                steeringMultiplier = baseSteeringMultiplier * 0.8;
            }
            
            // ã‚¹ãƒ”ãƒ¼ãƒ‰ã«å¿œã˜ãŸè¿½åŠ èª¿æ•´ï¼ˆé«˜é€Ÿæ™‚ã¯ã‚ˆã‚Šç©æ¥µçš„ã«ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ï¼‰
            steeringMultiplier *= (1 + speedFactor * 0.3);
            
            // æœ€çµ‚çš„ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦ã‚’è¨ˆç®—
            // ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®æ–¹å‘ã‚’ä¿®æ­£
            // THREE.jsã®åº§æ¨™ç³»ã¨ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®æ–¹å‘ã‚’æ­£ã—ãå¯¾å¿œã•ã›ã‚‹
            
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®çŠ¶æ…‹ã¨æ–¹å‘ã«åŸºã¥ã„ã¦ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦ã‚’è¨ˆç®—
            let steeringAngle = 0;
            const steeringCornerDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // ã‚³ãƒ¼ãƒŠãƒ¼çŠ¶æ…‹ã«å¿œã˜ãŸã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦æ±ºå®šãƒ­ã‚¸ãƒƒã‚¯
            if (window.cornerState === 'entry') {
                // é€²å…¥æ™‚ã¯å…ˆèª­ã¿ã—ãŸæ›²ç‡ã«åŸºã¥ã„ã¦ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°
                steeringAngle = -steeringCornerDirection * Math.abs(maxAheadAngle) * steeringMultiplier;
            } else if (window.cornerState === 'apex') {
                // é ‚ç‚¹ã§ã¯ç¾åœ¨ã®æ›²ç‡ã«åŸºã¥ã„ã¦ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°
                steeringAngle = -steeringCornerDirection * Math.abs(avgCurveAngle) * steeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // å‡ºå£ã§ã¯å¾Œã‚ã®æ›²ç‡ã«åŸºã¥ã„ã¦ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ï¼ˆå¾ã€…ã«æˆ»ã™ï¼‰
                steeringAngle = -steeringCornerDirection * Math.abs(maxBehindAngle) * steeringMultiplier;
            } else {
                // ç›´ç·šã§ã¯ã‚ãšã‹ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ï¼ˆç¾åœ¨ã®æ›²ç‡ã«åŸºã¥ãï¼‰
                steeringAngle = -curveTiltDirection * Math.abs(curveAngle) * steeringMultiplier * 0.5;
            }
            
            const maxSteeringAngle = Math.PI / 2.5; // æœ€å¤§ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦
            
            // ç›´ç·šèµ°è¡Œæ™‚ã®å¾®å°ãªã‚¦ã‚©ãƒ–ãƒªãƒ³ã‚°åŠ¹æœï¼ˆãƒªã‚¢ãƒ«ã•å‘ä¸Šï¼‰
            let wobblingEffect = 0;
            if (window.cornerState === 'straight') {
                // æ™‚é–“ã«åŸºã¥ã„ã¦å¾®å°ãªæŒ¯å‹•ã‚’ç”Ÿæˆ
                const wobbleFrequency = 2.0; // æºã‚Œã®é »åº¦
                const wobbleAmount = 0.03; // æºã‚Œã®å¤§ãã•
                wobblingEffect = Math.sin(Date.now() / 200 * wobbleFrequency) * wobbleAmount;
                
                // é€Ÿåº¦ãŒé€Ÿã„ã»ã©æºã‚Œã‚’å°ã•ã
                wobblingEffect *= (1 - speedFactor * 0.7);
            }
            
            // ã‚¦ã‚©ãƒ–ãƒªãƒ³ã‚°åŠ¹æœã‚’è¿½åŠ ã—ãŸæœ€çµ‚çš„ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦
            const finalSteeringAngle = steeringAngle + wobblingEffect;
            const clampedSteeringAngle = Math.max(-maxSteeringAngle, Math.min(maxSteeringAngle, finalSteeringAngle));
            
            // ã‚¿ã‚¤ãƒ¤ã®é«˜ã•ã‚’åœ°é¢ã«åˆã‚ã›ã¦èª¿æ•´
            for (let i = 0; i < wheels.length; i++) {
                // ã‚¿ã‚¤ãƒ¤ã‚’å›è»¢
                wheels[i].rotation.x += wheelRotationSpeed;
                
                // ã‚¿ã‚¤ãƒ¤ã®ä½ç½®ã‚’èª¿æ•´
                const wheelGroup = wheelGroups[i];
                const isLeftSide = (i % 2 === 0); // å·¦å´ã®ã‚¿ã‚¤ãƒ¤ã‹ã©ã†ã‹
                const isFrontWheel = (i < 2); // å‰è¼ªã‹ã©ã†ã‹
                
                // å‰è¼ªã®å ´åˆã€ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦ã‚’é©ç”¨
                if (isFrontWheel) {
                    // Yè»¸å‘¨ã‚Šã®å›è»¢ã§ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°åŠ¹æœã‚’å®Ÿç¾
                    wheelGroup.rotation.y = clampedSteeringAngle;
                }
                
                // ã‚¿ã‚¤ãƒ¤ã®åŸºæœ¬é«˜ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                const wheelBaseHeight = 0.5;
                
                // å‚¾ãã«ã‚ˆã‚‹é«˜ã•ã®ã‚ãšã‹ãªèª¿æ•´ï¼ˆã»ã¼ãªã—ï¼‰
                const wheelTiltOffset = isLeftSide ? 
                    -tiltFactor * curveTiltDirection * 0.2 : // å·¦å´ã‚¿ã‚¤ãƒ¤ï¼ˆåŠ¹æœã‚’0.2ã«å‰Šæ¸›ï¼‰
                    tiltFactor * curveTiltDirection * 0.2;   // å³å´ã‚¿ã‚¤ãƒ¤ï¼ˆåŠ¹æœã‚’0.2ã«å‰Šæ¸›ï¼‰
                
                // ã‚¿ã‚¤ãƒ¤ã®é«˜ã•ã‚’è¨­å®š
                wheelGroup.position.y = wheelBaseHeight + wheelTiltOffset;
            }
            
            // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’æ›´æ–°
            updateCamera();
            
            // ç”»é¢æç”»
            renderer.render(scene, camera);
        }
        
        // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã¨å‘ãã‚’æ›´æ–°
        function updateCamera() {
            switch (cameraMode) {
                case 0: // ä¿¯ç°
                    camera.position.set(3 * 50 * 2.0, 350, 9 * 50 * 2.0); // ã‚ˆã‚Šé«˜ã„ä½ç½®ã‹ã‚‰ã®ä¿¯ç°è¦–ç‚¹ï¼ˆã‚³ãƒ¼ã‚¹æ‹¡å¤§ã¨é«˜ä½å·®ã«å¯¾å¿œï¼‰
                    camera.lookAt(car.position);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 1: // è¿½å¾“
                    // è»Šã®å¾Œã‚ã‹ã‚‰å°‘ã—ä¸Šã®ä½ç½®ï¼ˆZè»¸ã‚’æ­£ã«å¤‰æ›´ã—ã¦è»Šã®å¾Œã‚ã«ï¼‰
                    const followOffset = new THREE.Vector3(0, 12, 25); // é«˜ã•ã‚’å°‘ã—ä¸Šã’ã‚‹ï¼ˆèµ·ä¼ã«å¯¾å¿œï¼‰
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedOffset = followOffset.clone().applyQuaternion(car.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetCameraPos = new THREE.Vector3().addVectors(car.position, rotatedOffset);
                    camera.position.lerp(targetCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // ã‚«ãƒ¡ãƒ©ã®æ³¨è¦–ç‚¹ã‚’è»Šã®ä½ç½®ã«è¨­å®šï¼ˆå°‘ã—å‰ã«ï¼‰
                    const lookAheadOffset = new THREE.Vector3(0, -2, -20).applyQuaternion(car.quaternion);
                    const lookAtPoint = new THREE.Vector3().addVectors(car.position, lookAheadOffset);
                    camera.lookAt(lookAtPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 2: // è»Šè¼‰
                    // é‹è»¢å¸­ã®ä½ç½®ï¼ˆå®Ÿéš›ã®ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ç›®ç·šã®ä½ç½®ã«ï¼‰
                    const fpvOffset = new THREE.Vector3(0, 1.1, -12); // ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã®ç›®ã®é«˜ã•ã¨ä½ç½®ã«èª¿æ•´
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedFpvOffset = fpvOffset.clone().applyQuaternion(car.quaternion);
                    
                    // è»Šä½“ã®æºã‚Œã‚’è¨ˆç®—ï¼ˆã‚«ãƒ¼ãƒ–ã§ã®å‚¾ãã‚’åæ˜ ï¼‰
                    const curvatureData = calculateCurvature(carPosition);
                    const tiltAngle = curvatureData.angle * 0.2; // ã‚«ãƒ¼ãƒ–ã§ã®å‚¾ã
                    
                    // ä¸Šä¸‹ã®æºã‚Œã‚’è¿½åŠ ï¼ˆé“è·¯ã®èµ·ä¼ã‚„é€Ÿåº¦ã«ã‚ˆã‚‹æºã‚Œï¼‰
                    const bumpiness = Math.sin(Date.now() * 0.01) * 0.05 * carSpeed;
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°ï¼ˆæºã‚Œã‚’åŠ ãˆã‚‹ï¼‰
                    const targetFpvCameraPos = new THREE.Vector3().addVectors(car.position, rotatedFpvOffset);
                    targetFpvCameraPos.y += bumpiness; // ä¸Šä¸‹ã®æºã‚Œã‚’è¿½åŠ 
                    camera.position.lerp(targetFpvCameraPos, 0.15); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆå°‘ã—é…ã‚ã«ï¼‰
                    
                    // ã‚«ãƒ¡ãƒ©ã®æ³¨è¦–ç‚¹ã‚’è»Šã®å‰æ–¹ã«è¨­å®šï¼ˆå°‘ã—å‰ã¨å°‘ã—ä¸‹ã‚’è¦‹ã‚‹ã‚ˆã†ã«ï¼‰
                    const fpvAheadOffset = new THREE.Vector3(0, -1, -20).applyQuaternion(car.quaternion);
                    const fpvAtPoint = new THREE.Vector3().addVectors(car.position, fpvAheadOffset);
                    
                    // ã‚«ãƒ¡ãƒ©ã®å‚¾ãã‚’è¨ˆç®—ï¼ˆã‚«ãƒ¼ãƒ–ã§ã®å‚¾ãã‚’åæ˜ ï¼‰
                    const fpvUpVector = new THREE.Vector3(Math.sin(tiltAngle), 1, 0);
                    camera.up.copy(fpvUpVector.normalize());
                    
                    // è»Šè¼‰è¦–ç‚¹ã®FOV(è¦–é‡è§’)ã‚’èª¿æ•´ã—ã¦æ²¡å…¥æ„Ÿã‚’é«˜ã‚ã‚‹
                    camera.fov = 75; // åºƒã„è¦–é‡è§’ã«è¨­å®š
                    camera.updateProjectionMatrix();
                    
                    // ã‚«ãƒ¡ãƒ©ã®æ³¨è¦–ç‚¹ã‚’è¨­å®š
                    camera.lookAt(fpvAtPoint);
                    break;
                case 3: // æ–œã‚ä¸Šè¦–ç‚¹
                    // è»Šã®ä¸Šã¨æ¨ªã‹ã‚‰è¦‹ã‚‹ä½ç½®ï¼ˆè»Šã®å‚¾ãã‚’å¼·èª¿ã—ã¦è¦‹ã›ã‚‹ãŸã‚ï¼‰
                    const diagonalOffset = new THREE.Vector3(50, 40, 20); // å³ä¸Šã‹ã‚‰ã‹ãªã‚Šé›¢ã‚ŒãŸä½ç½®ã«é…ç½®
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedDiagOffset = diagonalOffset.clone().applyQuaternion(car.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetDiagCameraPos = new THREE.Vector3().addVectors(car.position, rotatedDiagOffset);
                    camera.position.lerp(targetDiagCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // è»Šã‚’ã—ã£ã‹ã‚Šè¦‹ã‚‹ï¼ˆå°‘ã—å‰ã‚’è¦‹ã‚‹ã‚ˆã†ã«è¨­å®šï¼‰
                    const diagLookOffset = new THREE.Vector3(0, -1, -5).applyQuaternion(car.quaternion);
                    const diagLookAtPoint = new THREE.Vector3().addVectors(car.position, diagLookOffset);
                    camera.lookAt(diagLookAtPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 4: // è»Šå‰æ–¹ã‹ã‚‰å¾Œæ–¹ã‚’è¦‹ã‚‹è¦–ç‚¹
                    // è»Šã®å‰æ–¹ã®ä½ç½®ï¼ˆZè»¸ã‚’è² ã«å¤‰æ›´ã—ã¦è»Šã®å‰æ–¹ã«ï¼‰
                    const frontOffset = new THREE.Vector3(0, 5, -30); // è»Šã®å‰æ–¹ã€ã‚ˆã‚Šé›¢ã‚ŒãŸä½ç½®ã«å¤‰æ›´
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedFrontOffset = frontOffset.clone().applyQuaternion(car.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetFrontCameraPos = new THREE.Vector3().addVectors(car.position, rotatedFrontOffset);
                    camera.position.lerp(targetFrontCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // ã‚«ãƒ¡ãƒ©ãŒè»Šã®å¾Œæ–¹ã‚’è¦‹ã‚‹ã‚ˆã†ã«ã™ã‚‹
                    const lookBackOffset = new THREE.Vector3(0, 0, 20).applyQuaternion(car.quaternion);
                    const lookBackPoint = new THREE.Vector3().addVectors(car.position, lookBackOffset);
                    camera.lookAt(lookBackPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
            }
        }
        
        // ãƒªã‚µã‚¤ã‚ºå‡¦ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã®å‡¦ç†
        document.addEventListener('keydown', (event) => {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
            if (event.key === '1') {
                cameraMode = 0; // ä¿¯ç°
                updateButtonActiveState();
            } else if (event.key === '2') {
                cameraMode = 1; // è¿½å¾“
                updateButtonActiveState();
            } else if (event.key === '3') {
                cameraMode = 2; // è»Šè¼‰
                updateButtonActiveState();
            } else if (event.key === '4') {
                cameraMode = 3; // æ–œã‚ä¸Š
                updateButtonActiveState();
            } else if (event.key === '5') {
                cameraMode = 4; // å‰æ–¹
                updateButtonActiveState();
            }
        });

        // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®è¨­å®š
        function setupViewButtons() {
            const buttons = document.querySelectorAll('.viewButton');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    cameraMode = parseInt(button.getAttribute('data-view'));
                    updateButtonActiveState();
                    
                    // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ç¾åœ¨ã®å¤©æ°—ã«å¿œã˜ã¦ç’°å¢ƒã‚’æ›´æ–°
                    if (currentWeather === 'rain') {
                        updateEnvironmentForRain();
                    } else if (currentWeather === 'snow') {
                        updateEnvironmentForSnow();
                    } else {
                        // æ™´ã‚Œã®å ´åˆã¯éœ§ã‚’ãªãã™
                        scene.fog = null;
                    }
                });
            });
            
            // åˆæœŸè¡¨ç¤ºæ™‚ã«ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
            updateButtonActiveState();
        }

        // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
        function updateButtonActiveState() {
            const buttons = document.querySelectorAll('.viewButton');
            buttons.forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // åˆæœŸåŒ–é–¢æ•°
        function init() {
            // ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®
            placeEnvironmentObjects();
            
            // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®è¨­å®š
            setupViewButtons();
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®åˆæœŸåŒ–
            initMinimap();
            
            // å¤©æ°—ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('weatherToggleButton').addEventListener('click', function() {
                const weatherMenu = document.getElementById('weatherMenu');
                if (weatherMenu.style.display === 'none') {
                    weatherMenu.style.display = 'block';
                } else {
                    weatherMenu.style.display = 'none';
                }
            });
            
            // å¤©æ°—ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.querySelectorAll('.weatherOption').forEach(button => {
                button.addEventListener('click', function() {
                    const selectedWeather = this.getAttribute('data-weather');
                    
                    // ä»¥å‰ã®å¤©æ°—ã‚’ãƒªã‚»ãƒƒãƒˆ
                    document.querySelectorAll('.weatherOption').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // é¸æŠã•ã‚ŒãŸå¤©æ°—ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
                    this.classList.add('active');
                    
                    // å¤©æ°—ã‚’å¤‰æ›´
                    changeWeather(selectedWeather);
                    
                    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‰ã˜ã‚‹
                    document.getElementById('weatherMenu').style.display = 'none';
                });
            });
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆ
            log("ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹");
            animate();
            
            // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
            initWeatherSystem();
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        window.onload = init;

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡åˆæœŸåŒ–é˜²æ­¢ã®ãŸã‚ï¼‰
        
        // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®åˆæœŸåŒ–ã¨æç”»
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®æç”»é–¢æ•°
            function drawMinimap() {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // èƒŒæ™¯è‰²
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ã‚³ãƒ¼ã‚¹ã®åº§æ¨™ã‚’å–å¾—ã—ã€ãƒŸãƒ‹ãƒãƒƒãƒ—ã®åº§æ¨™ã«å¤‰æ›
                const minimapPoints = [];
                const margin = 10; // ãƒãƒ¼ã‚¸ãƒ³
                
                // ã‚³ãƒ¼ã‚¹ã®ç¯„å›²ã‚’è¨ˆç®—
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                trackPoints.forEach(point => {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minZ = Math.min(minZ, point[2]);
                    maxZ = Math.max(maxZ, point[2]);
                });
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã‚’è¨ˆç®—
                const mapWidth = canvas.width - margin * 2;
                const mapHeight = canvas.height - margin * 2;
                const scaleX = mapWidth / (maxX - minX);
                const scaleZ = mapHeight / (maxZ - minZ);
                const scale = Math.min(scaleX, scaleZ);
                
                // ã‚³ãƒ¼ã‚¹ã®ãƒã‚¤ãƒ³ãƒˆã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
                trackPoints.forEach(point => {
                    const x = margin + (point[0] - minX) * scale;
                    const y = margin + (point[2] - minZ) * scale;
                    minimapPoints.push([x, y]);
                });
                
                // ã‚³ãƒ¼ã‚¹ã‚’æç”»ï¼ˆç™½ã„ç·šï¼‰
                ctx.beginPath();
                ctx.moveTo(minimapPoints[0][0], minimapPoints[0][1]);
                for (let i = 1; i < minimapPoints.length; i++) {
                    ctx.lineTo(minimapPoints[i][0], minimapPoints[i][1]);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‚’ãƒãƒ¼ã‚¯
                const startX = minimapPoints[0][0];
                const startY = minimapPoints[0][1];
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã‚’æç”»
                ctx.beginPath();
                const tangent = new THREE.Vector3(
                    trackPoints[1][0] - trackPoints[0][0],
                    0,
                    trackPoints[1][2] - trackPoints[0][2]
                ).normalize();
                
                // å‚ç›´æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ä¸¡ç«¯ã®åº§æ¨™ã‚’è¨ˆç®—
                const lineLength = 8; // ãƒ©ã‚¤ãƒ³ã®é•·ã•
                const startLine1X = startX + perpendicular.x * lineLength;
                const startLine1Y = startY + perpendicular.z * lineLength;
                const startLine2X = startX - perpendicular.x * lineLength;
                const startLine2Y = startY - perpendicular.z * lineLength;
                
                // ãƒ©ã‚¤ãƒ³ã‚’æç”»
                ctx.moveTo(startLine1X, startLine1Y);
                ctx.lineTo(startLine2X, startLine2Y);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ãƒã‚§ãƒƒã‚«ãƒ¼ãƒ•ãƒ©ãƒƒã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æç”»
                const segments = 6;
                const segmentLength = lineLength * 2 / segments;
                
                for (let i = 0; i < segments; i++) {
                    if (i % 2 === 0) {
                        const segX1 = startLine2X + perpendicular.x * segmentLength * i;
                        const segY1 = startLine2Y + perpendicular.z * segmentLength * i;
                        const segX2 = segX1 + perpendicular.x * segmentLength;
                        const segY2 = segY1 + perpendicular.z * segmentLength;
                        
                        ctx.fillStyle = 'black';
                        
                        // çŸ©å½¢ã‚’æç”»
                        ctx.beginPath();
                        ctx.moveTo(segX1, segY1);
                        ctx.lineTo(segX2, segY2);
                        ctx.lineTo(segX2 + tangent.x * 3, segY2 + tangent.z * 3);
                        ctx.lineTo(segX1 + tangent.x * 3, segY1 + tangent.z * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // è»Šã®ä½ç½®ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—ä¸Šã§è¡¨ç¤ºï¼ˆèµ¤ã„ç‚¹ï¼‰
                if (typeof carPosition !== 'undefined' && typeof carPath !== 'undefined') {
                    const point = carPath.getPointAt(carPosition);
                    const x = margin + (point.x - minX) * scale;
                    const y = margin + (point.z - minZ) * scale;
                    
                    // è»Šã®å‘ãã‚’è¨ˆç®—
                    const tangent = carPath.getTangentAt(carPosition).normalize();
                    const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                    
                    // è»Šã‚’ä¸‰è§’å½¢ã§æç”»
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, -5);  // å…ˆç«¯
                    ctx.lineTo(-3, 3);  // å·¦ä¸‹
                    ctx.lineTo(3, 3);   // å³ä¸‹
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’å®šæœŸçš„ã«æ›´æ–°
            setInterval(drawMinimap, 50);
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
        function setupKeyboardControls() {
            document.addEventListener('keydown', function(event) {
                switch(event.key) {
                    case '1':
                        cameraMode = 0; // ä¿¯ç°
                        updateCameraButtonState();
                        break;
                    case '2':
                        cameraMode = 1; // è¿½å¾“
                        updateCameraButtonState();
                        break;
                    case '3':
                        cameraMode = 2; // è»Šè¼‰
                        updateCameraButtonState();
                        break;
                    case '4':
                        cameraMode = 3; // æ–œã‚ä¸Š
                        updateCameraButtonState();
                        break;
                    case '5':
                        cameraMode = 4; // å‰æ–¹
                        updateCameraButtonState();
                        break;
                }
            });

            // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.querySelectorAll('.viewButton').forEach(button => {
                button.addEventListener('click', function() {
                    cameraMode = parseInt(this.getAttribute('data-view'));
                    updateCameraButtonState();
                });
            });
        }

        // æ™‚é–“ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('timeToggleButton').addEventListener('click', function() {
            useRealTime = !useRealTime;
            
            // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
            if (useRealTime) {
                this.textContent = 'ğŸ•’';
                this.title = 'ç¾åœ¨ã®æ™‚åˆ»ã«é€£å‹•ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰';
                
                // ç¾å®Ÿæ™‚é–“ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã£ãŸã‚‰å¤©æ°—ã¨ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å¤‰æ›´ã‚’ãƒªã‚»ãƒƒãƒˆ
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 30000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 30000;
                
                // ç¾åœ¨åœ°ç‚¹ã®å¤©æ°—ã‚’å–å¾—ã—ã¦åæ˜ 
                fetchCurrentWeather();
            } else {
                this.textContent = 'â©';
                this.title = 'ã‚²ãƒ¼ãƒ å†…æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰';
                
                // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰ã«å…¥ã£ãŸã‚‰å¤©æ°—ã¨ã‚«ãƒ¡ãƒ©ã‚’è‡ªå‹•æ›´æ–°é–‹å§‹
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 20000 + Math.random() * 20000;

                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 10000 + Math.random() * 5000;
            }
        });

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯å‰Šé™¤ï¼ˆinité–¢æ•°ã«ç§»å‹•æ¸ˆã¿ï¼‰

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        window.onload = init;

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡åˆæœŸåŒ–é˜²æ­¢ã®ãŸã‚ï¼‰
        
        // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®åˆæœŸåŒ–ã¨æç”»
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®æç”»é–¢æ•°
            function drawMinimap() {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // èƒŒæ™¯è‰²
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ã‚³ãƒ¼ã‚¹ã®åº§æ¨™ã‚’å–å¾—ã—ã€ãƒŸãƒ‹ãƒãƒƒãƒ—ã®åº§æ¨™ã«å¤‰æ›
                const minimapPoints = [];
                const margin = 10; // ãƒãƒ¼ã‚¸ãƒ³
                
                // ã‚³ãƒ¼ã‚¹ã®ç¯„å›²ã‚’è¨ˆç®—
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                trackPoints.forEach(point => {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minZ = Math.min(minZ, point[2]);
                    maxZ = Math.max(maxZ, point[2]);
                });
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°ã‚’è¨ˆç®—
                const mapWidth = canvas.width - margin * 2;
                const mapHeight = canvas.height - margin * 2;
                const scaleX = mapWidth / (maxX - minX);
                const scaleZ = mapHeight / (maxZ - minZ);
                const scale = Math.min(scaleX, scaleZ);
                
                // ã‚³ãƒ¼ã‚¹ã®ãƒã‚¤ãƒ³ãƒˆã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—åº§æ¨™ã«å¤‰æ›
                trackPoints.forEach(point => {
                    const x = margin + (point[0] - minX) * scale;
                    const y = margin + (point[2] - minZ) * scale;
                    minimapPoints.push([x, y]);
                });
                
                // ã‚³ãƒ¼ã‚¹ã‚’æç”»ï¼ˆç™½ã„ç·šï¼‰
                ctx.beginPath();
                ctx.moveTo(minimapPoints[0][0], minimapPoints[0][1]);
                for (let i = 1; i < minimapPoints.length; i++) {
                    ctx.lineTo(minimapPoints[i][0], minimapPoints[i][1]);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã‚’ãƒãƒ¼ã‚¯
                const startX = minimapPoints[0][0];
                const startY = minimapPoints[0][1];
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã‚’æç”»
                ctx.beginPath();
                const tangent = new THREE.Vector3(
                    trackPoints[1][0] - trackPoints[0][0],
                    0,
                    trackPoints[1][2] - trackPoints[0][2]
                ).normalize();
                
                // å‚ç›´æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ä¸¡ç«¯ã®åº§æ¨™ã‚’è¨ˆç®—
                const lineLength = 8; // ãƒ©ã‚¤ãƒ³ã®é•·ã•
                const startLine1X = startX + perpendicular.x * lineLength;
                const startLine1Y = startY + perpendicular.z * lineLength;
                const startLine2X = startX - perpendicular.x * lineLength;
                const startLine2Y = startY - perpendicular.z * lineLength;
                
                // ãƒ©ã‚¤ãƒ³ã‚’æç”»
                ctx.moveTo(startLine1X, startLine1Y);
                ctx.lineTo(startLine2X, startLine2Y);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // ãƒã‚§ãƒƒã‚«ãƒ¼ãƒ•ãƒ©ãƒƒã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æç”»
                const segments = 6;
                const segmentLength = lineLength * 2 / segments;
                
                for (let i = 0; i < segments; i++) {
                    if (i % 2 === 0) {
                        const segX1 = startLine2X + perpendicular.x * segmentLength * i;
                        const segY1 = startLine2Y + perpendicular.z * segmentLength * i;
                        const segX2 = segX1 + perpendicular.x * segmentLength;
                        const segY2 = segY1 + perpendicular.z * segmentLength;
                        
                        ctx.fillStyle = 'black';
                        
                        // çŸ©å½¢ã‚’æç”»
                        ctx.beginPath();
                        ctx.moveTo(segX1, segY1);
                        ctx.lineTo(segX2, segY2);
                        ctx.lineTo(segX2 + tangent.x * 3, segY2 + tangent.z * 3);
                        ctx.lineTo(segX1 + tangent.x * 3, segY1 + tangent.z * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // è»Šã®ä½ç½®ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—ä¸Šã§è¡¨ç¤ºï¼ˆèµ¤ã„ç‚¹ï¼‰
                if (typeof carPosition !== 'undefined' && typeof carPath !== 'undefined') {
                    const point = carPath.getPointAt(carPosition);
                    const x = margin + (point.x - minX) * scale;
                    const y = margin + (point.z - minZ) * scale;
                    
                    // è»Šã®å‘ãã‚’è¨ˆç®—
                    const tangent = carPath.getTangentAt(carPosition).normalize();
                    const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                    
                    // è»Šã‚’ä¸‰è§’å½¢ã§æç”»
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, -5);  // å…ˆç«¯
                    ctx.lineTo(-3, 3);  // å·¦ä¸‹
                    ctx.lineTo(3, 3);   // å³ä¸‹
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’å®šæœŸçš„ã«æ›´æ–°
            setInterval(drawMinimap, 50);
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
        function setupKeyboardControls() {
            // ... existing code ...
        }

        
        // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        function initWeatherSystem() {
            // é›ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 15000;
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSizes = new Float32Array(snowCount);
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                snowPositions[i] = Math.random() * 2000 - 1000; // x: -1000 to 1000
                snowPositions[i+1] = Math.random() * 1000; // y: 0 to 1000
                snowPositions[i+2] = Math.random() * 2000 - 1000; // z: -1000 to 1000
                snowSizes[i/3] = 3.0;
            }
            
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.0,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            snowParticles.visible = false;
            scene.add(snowParticles);
            
            // é›²ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ è¿½åŠ 
            const cloudGeometry = new THREE.BufferGeometry();
            const cloudCount = 500; // é›²ã¯é›ªã‚ˆã‚Šå°‘ãªã
            const cloudPositions = new Float32Array(cloudCount * 3);
            const cloudSizes = new Float32Array(cloudCount);
            
            for (let i = 0; i < cloudCount * 3; i += 3) {
                cloudPositions[i] = Math.random() * 3000 - 1500; // x: -1500 to 1500 (åºƒç¯„å›²ã«é…ç½®)
                cloudPositions[i+1] = 300 + Math.random() * 500; // y: 300 to 800 (é«˜ã„ä½ç½®ã«é…ç½®)
                cloudPositions[i+2] = Math.random() * 3000 - 1500; // z: -1500 to 1500
                cloudSizes[i/3] = 20.0 + Math.random() * 30.0; // é›²ã¯å¤§ãã‚ã«
            }
            
            cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
            cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));
            
            // é›²ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨
            const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud10.png');
            
            const cloudMaterial = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 30.0,
                transparent: true,
                opacity: 0.7,
                map: cloudTexture,
                sizeAttenuation: true,
                depthWrite: false // åŠé€æ˜ã®ãŸã‚ã€æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ã‚ªãƒ•
            });
            
            cloudParticles = new THREE.Points(cloudGeometry, cloudMaterial);
            cloudParticles.visible = false;
            scene.add(cloudParticles);
            
            // é›¨ç²’ã‚’ç¸¦é•·ã®å½¢çŠ¶ã«å¤‰æ›´ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ã‚’ä½¿ç”¨ï¼‰
            // é›¨ç²’ã®åŸºæœ¬å½¢çŠ¶ï¼ˆç´°é•·ã„ç›´æ–¹ä½“ï¼‰
            const rainDropGeometry = new THREE.BoxGeometry(0.1, 1.0, 0.1);
            const rainMaterial = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true, 
                opacity: 0.6
            });
            
            // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
            const rainCount = 15000;
            rainParticles = new THREE.InstancedMesh(rainDropGeometry, rainMaterial, rainCount);
            rainParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // ä½ç½®ã‚’å‹•çš„ã«æ›´æ–°
            rainParticles.visible = false;
            
            // é›¨ç²’ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã®åˆæœŸä½ç½®ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨­å®š
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const rotation = new THREE.Euler();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3(1, 1, 1);
            
            for (let i = 0; i < rainCount; i++) {
                position.x = Math.random() * 2000 - 1000;
                position.y = Math.random() * 1000;
                position.z = Math.random() * 2000 - 1000;
                
                // è‹¥å¹²ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ã‚’ä»˜ã‘ã‚‹ï¼ˆé›¨ãŒæ–œã‚ã«é™ã£ã¦ã„ã‚‹ã‚ˆã†ã«ï¼‰
                rotation.x = 0;
                rotation.z = 0;
                rotation.y = Math.random() * Math.PI;
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                rainParticles.setMatrixAt(i, matrix);
            }
            
            rainParticles.instanceMatrix.needsUpdate = true;
            scene.add(rainParticles);
            
            // åˆæœŸå¤©æ°—ã®è¨­å®š
            if (useRealTime) {
                // ç¾åœ¨åœ°ç‚¹ã®å¤©æ°—ã‚’å–å¾—ã—ã¦åæ˜ 
                fetchCurrentWeather();
            } else {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªå¤©æ°—ã‚’è¨­å®š
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
            }
        }
        
        // å¤©æ°—ã‚’å¤‰æ›´ã™ã‚‹é–¢æ•°
        function changeWeather(weather) {
            currentWeather = weather;
            
            // å¤©æ°—ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
            const weatherButton = document.getElementById('weatherToggleButton');
            
            switch(weather) {
                case 'sunny':
                    weatherButton.textContent = 'â˜€ï¸';
                    weatherButton.title = 'æ™´ã‚Œ (ã‚¯ãƒªãƒƒã‚¯ã§å¤‰æ›´)';
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = false;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = false;
                    
                    // æ™´ã‚Œã®ç’°å¢ƒã«æ›´æ–°
                    updateEnvironmentForSunny();
                    break;
                case 'cloudy':
                    weatherButton.textContent = 'â˜ï¸';
                    weatherButton.title = 'æ›‡ã‚Š (ã‚¯ãƒªãƒƒã‚¯ã§å¤‰æ›´)';
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // æ›‡ã‚Šã®å ´åˆã¯éœ§ã‚’è¿½åŠ 
                    updateEnvironmentForCloudy();
                    break;
                case 'rain':
                    weatherButton.textContent = 'ğŸŒ§';
                    weatherButton.title = 'é›¨ (ã‚¯ãƒªãƒƒã‚¯ã§å¤‰æ›´)';
                    isRaining = true;
                    isSnowing = false;
                    isCloudy = true; // é›¨ã®æ™‚ã¯æ›‡ã‚Šã‚‚æœ‰åŠ¹
                    if (rainParticles) rainParticles.visible = true;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // é›¨ã®å ´åˆã¯åœ°é¢ã‚’æ¿¡ã‚ŒãŸæ„Ÿã˜ã«
                    updateEnvironmentForRain();
                    break;
                case 'snow':
                    weatherButton.textContent = 'â„ï¸';
                    weatherButton.title = 'é›ª (ã‚¯ãƒªãƒƒã‚¯ã§å¤‰æ›´)';
                    isRaining = false;
                    isSnowing = true;
                    isCloudy = true; // é›ªã®æ™‚ã¯æ›‡ã‚Šã‚‚æœ‰åŠ¹
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = true;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // é›ªã®å ´åˆã¯åœ°é¢ã‚’ç™½ãã™ã‚‹
                    updateEnvironmentForSnow();
                    break;
            }
        }
        
        // æ›‡ã‚Šã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForCloudy() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) { // ä¿¯ç°è¦–ç‚¹ã®å ´åˆ
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.003);
            }
            
            // æ›‡ã‚Šã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆã‚°ãƒ¬ãƒ¼ãŒã‹ã£ãŸè‰²ï¼‰
            weatherSkyColor = new THREE.Color(0x8c8c8c);
            
            // æ›‡ã‚Šæ™‚ã®èŠç”Ÿã®è‰²
            floor.material.color.setHex(0x2a552a);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // é›¨ã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForRain() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0x555555, 0.001);
            } else {
                scene.fog = new THREE.FogExp2(0x555555, 0.007);
            }
            
            // é›¨ã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæš—ã„ã‚°ãƒ¬ãƒ¼ï¼‰
            weatherSkyColor = new THREE.Color(0x4a4a4a);
            
            // åœ°é¢ã‚’æ¿¡ã‚ŒãŸæ„Ÿã˜ã«
            floor.material.color.setHex(0x1c4d1c);
            floor.material.roughness = 0.4;
            floor.material.metalness = 0.3;
            floor.material.needsUpdate = true;
        }
        
        // é›ªã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForSnow() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0005);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.005);
            }
            
            // é›ªã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæ˜ã‚‹ã„ã‚°ãƒ¬ãƒ¼ï¼‰
            weatherSkyColor = new THREE.Color(0xd8d8d8);
            
            // åœ°é¢ã‚’é›ªã§è¦†ã‚ã‚ŒãŸã‚ˆã†ã«
            floor.material.color.setHex(0xf0f0f0);
            floor.material.roughness = 0.9;
            floor.material.metalness = 0.0;
            floor.material.needsUpdate = true;
        }
        
        // æ™´ã‚Œã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForSunny() {
            // éœ§ã‚’ãªãã™
            scene.fog = null;
            
            // æ™´ã‚Œã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæ˜ã‚‹ã„é’ç©ºï¼‰
            weatherSkyColor = new THREE.Color(0x87CEEB);
            
            // é€šå¸¸ã®èŠç”Ÿã®è‰²ã«æˆ»ã™
            floor.material.color.setHex(0x336633);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // å¤©æ°—ã®æ›´æ–°
        function updateWeather(deltaTime) {
            // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰æ™‚ã®è‡ªå‹•å¤©æ°—å¤‰æ›´ã¨ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆ
            if (!useRealTime) {
                const currentTime = Date.now();
                
                // å¤©æ°—ã®è‡ªå‹•å¤‰æ›´
                if (currentTime - lastWeatherChangeTime > weatherChangeInterval) {
                    const availableChoices = availableWeathers.filter(w => w !== currentWeather);
                    const nextWeather = availableChoices[Math.floor(Math.random() * availableChoices.length)];
                    changeWeather(nextWeather);
                    lastWeatherChangeTime = currentTime;
                    weatherChangeInterval = 20000 + Math.random() * 20000;
                    console.log("å¤©æ°—è‡ªå‹•å¤‰æ›´: " + nextWeather);
                }
                
                // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ
                if (currentTime - lastCameraChangeTime > cameraChangeInterval) {
                    const availableViews = availableCameraModes.filter(mode => mode !== cameraMode);
                    const nextCameraMode = availableViews[Math.floor(Math.random() * availableViews.length)];
                    cameraMode = nextCameraMode;
                    updateCameraButtonState();
                    
                    lastCameraChangeTime = currentTime;
                    cameraChangeInterval = 10000 + Math.random() * 5000;
                    console.log("ã‚«ãƒ¡ãƒ©è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ: " + nextCameraMode);
                }
            }
            
            // æ—¢å­˜ã®å¤©æ°—æ›´æ–°å‡¦ç†
            if (isCloudy && cloudParticles) {
                // é›²ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                const cloudPositions = cloudParticles.geometry.attributes.position.array;
                const cloudCount = cloudPositions.length / 3;
                
                // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦é›²ã®è¡¨ç¤ºã‚’èª¿æ•´
                if (cameraMode === 0) { // ä¿¯ç°è¦–ç‚¹ã®å ´åˆ
                    // ä¿¯ç°è¦–ç‚¹ã§ã¯å°‘ã—é€æ˜åº¦ã‚’ä¸Šã’ã¦è–„ãè¦‹ã›ã‚‹
                    cloudParticles.material.opacity = 0.4;
                    // ã‚ˆã‚Šåºƒç¯„å›²ã«é…ç½®
                    cloudParticles.scale.set(3, 1, 3);
                } else {
                    // é€šå¸¸è¦–ç‚¹ã§ã¯æ¨™æº–ã®è¡¨ç¤º
                    cloudParticles.material.opacity = 0.7;
                    cloudParticles.scale.set(1, 1, 1);
                }
                
                for (let i = 0; i < cloudCount * 3; i += 3) {
                    // X,Zåº§æ¨™ã‚’ã‚†ã£ãã‚Šå‹•ã‹ã™ï¼ˆé›²ãŒå‹•ãæ„Ÿã˜ï¼‰
                    cloudPositions[i] += Math.sin(currentFrameTime * 0.0001 + i * 0.01) * 0.3 * deltaTime;
                    cloudPositions[i+2] += Math.cos(currentFrameTime * 0.00015 + i * 0.01) * 0.3 * deltaTime;
                    
                    // é ãã«è¡Œãã™ããŸã‚‰åå¯¾å´ã«é…ç½®
                    if (cloudPositions[i] > 1500) cloudPositions[i] = -1500;
                    if (cloudPositions[i] < -1500) cloudPositions[i] = 1500;
                    if (cloudPositions[i+2] > 1500) cloudPositions[i+2] = -1500;
                    if (cloudPositions[i+2] < -1500) cloudPositions[i+2] = 1500;
                }
                
                // ã‚«ãƒ¡ãƒ©ã‚’ä¸­å¿ƒã«é›²ã‚’é…ç½®
                cloudParticles.position.x = camera.position.x;
                cloudParticles.position.z = camera.position.z;
                
                cloudParticles.geometry.attributes.position.needsUpdate = true;
            }
        
            if (isRaining && rainParticles) {
                // é›¨ç²’ã‚’æ›´æ–°ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚ŒãŸãƒ¡ãƒƒã‚·ãƒ¥ç‰ˆï¼‰
                const rainMatrix = new THREE.Matrix4();
                const rainPosition = new THREE.Vector3();
                const rainRotation = new THREE.Euler();
                const rainQuaternion = new THREE.Quaternion();
                const rainScale = new THREE.Vector3();
                
                // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦é›¨ã®è¡¨ç¤ºã‚’èª¿æ•´
                if (cameraMode === 0) { // ä¿¯ç°è¦–ç‚¹ã®å ´åˆ
                    // ä¿¯ç°è¦–ç‚¹ã§ã¯é€æ˜åº¦ã‚’ä¸Šã’ã¦è–„ãè¦‹ã›ã‚‹
                    rainParticles.material.opacity = 0.3;
                    // åºƒç¯„å›²ã«é…ç½®ã™ã‚‹ãŸã‚å¤§ããªã‚¹ã‚±ãƒ¼ãƒ«
                    rainParticles.scale.set(3, 1, 3);
                } else {
                    // é€šå¸¸è¦–ç‚¹ã§ã¯æ¨™æº–ã®è¡¨ç¤º
                    rainParticles.material.opacity = 0.6;
                    rainParticles.scale.set(1, 1, 1);
                }
                
                // ã‚«ãƒ¡ãƒ©ã‚’ä¸­å¿ƒã«é›¨ã‚’é…ç½®
                rainParticles.position.x = camera.position.x;
                rainParticles.position.z = camera.position.z;
                
                // å„é›¨ç²’ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ›´æ–°
                for (let i = 0; i < rainParticles.count; i++) {
                    rainParticles.getMatrixAt(i, rainMatrix);
                    // è¡Œåˆ—ã‹ã‚‰ä½ç½®ã€å›è»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã‚’æŠ½å‡º
                    rainMatrix.decompose(rainPosition, rainQuaternion, rainScale);
                    
                    // Yåº§æ¨™ã‚’ä¸‹ã«ç§»å‹•ï¼ˆé›¨ãŒé™ã‚‹ï¼‰
                    rainPosition.y -= 10 * deltaTime;
                    
                    // åœ°é¢ã«åˆ°é”ã—ãŸã‚‰ä¸Šã«æˆ»ã™
                    if (rainPosition.y < 0) {
                        rainPosition.y = 1000;
                        // X,Zåº§æ¨™ã‚‚ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã—ç›´ã™
                        rainPosition.x = Math.random() * 2000 - 1000;
                        rainPosition.z = Math.random() * 2000 - 1000;
                    }
                    
                    // å›è»¢ã¯ç¶­æŒ
                    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚‚ç¶­æŒ
                    
                    // æ–°ã—ã„ä½ç½®ã§è¡Œåˆ—ã‚’æ›´æ–°
                    rainMatrix.compose(rainPosition, rainQuaternion, rainScale);
                    rainParticles.setMatrixAt(i, rainMatrix);
                }
                
                rainParticles.instanceMatrix.needsUpdate = true;
            }
            
            if (isSnowing && snowParticles) {
                // é›ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
                const snowPositions = snowParticles.geometry.attributes.position.array;
                const snowCount = snowPositions.length / 3;
                
                // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦é›ªã®è¡¨ç¤ºã‚’èª¿æ•´
                if (cameraMode === 0) { // ä¿¯ç°è¦–ç‚¹ã®å ´åˆ
                    // ä¿¯ç°è¦–ç‚¹ã§ã¯å°‘ã—é€æ˜åº¦ã‚’ä¸Šã’ã¦è–„ãè¦‹ã›ã‚‹
                    snowParticles.material.opacity = 0.4;
                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚µã‚¤ã‚ºã‚’å°ã•ã
                    snowParticles.material.size = 1.0;
                    
                    // ã‚ˆã‚Šåºƒç¯„å›²ã«é…ç½®
                    snowParticles.scale.set(3, 1, 3);
                } else {
                    // é€šå¸¸è¦–ç‚¹ã§ã¯æ¨™æº–ã®è¡¨ç¤º
                    snowParticles.material.opacity = 0.8;
                    snowParticles.material.size = 2.0;
                    snowParticles.scale.set(1, 1, 1);
                }
                
                for (let i = 0; i < snowCount * 3; i += 3) {
                    // Yåº§æ¨™ã‚’ä¸‹ã«ç§»å‹•ï¼ˆé›ªãŒé™ã‚‹ã€é›¨ã‚ˆã‚Šé…ã„ï¼‰
                    snowPositions[i+1] -= 2 * deltaTime;
                    
                    // X,Zåº§æ¨™ã‚‚å°‘ã—æºã‚‰ã™ï¼ˆé›ªãŒèˆã†æ„Ÿã˜ï¼‰
                    snowPositions[i] += Math.sin(currentFrameTime * 0.001 + i * 0.1) * 0.2 * deltaTime;
                    snowPositions[i+2] += Math.cos(currentFrameTime * 0.0015 + i * 0.1) * 0.2 * deltaTime;
                    
                    // åœ°é¢ã«åˆ°é”ã—ãŸã‚‰ä¸Šã«æˆ»ã™
                    if (snowPositions[i+1] < 0) {
                        snowPositions[i+1] = 1000;
                        // X,Zåº§æ¨™ã‚‚ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®ã—ç›´ã™
                        snowPositions[i] = Math.random() * 2000 - 1000;
                        snowPositions[i+2] = Math.random() * 2000 - 1000;
                    }
                }
                
                // ã‚«ãƒ¡ãƒ©ã‚’ä¸­å¿ƒã«é›ªã‚’é…ç½®
                snowParticles.position.x = camera.position.x;
                snowParticles.position.z = camera.position.z;
                
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateCameraButtonState() {
            document.querySelectorAll('.viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // ç¾åœ¨ä½ç½®ã®å¤©æ°—ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        async function fetchCurrentWeather() {
            try {
                // ç¾åœ¨ä½ç½®ã‚’å–å¾—
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                log(`ç¾åœ¨ä½ç½®ã‚’å–å¾—ã—ã¾ã—ãŸ: ç·¯åº¦ ${lat}, çµŒåº¦ ${lon}`);
                
                // OpenWeatherMap APIã‚’å‘¼ã³å‡ºã—
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${weatherApiKey}&units=metric`);
                
                if (!response.ok) {
                    throw new Error('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                const data = await response.json();
                log('ç¾åœ¨ã®å¤©æ°—æƒ…å ±ã‚’å–å¾—ã—ã¾ã—ãŸ: ' + data.weather[0].main);
                
                // å¤©æ°—ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦å¤©æ°—ã‚’è¨­å®š
                const weatherCode = data.weather[0].id;
                let gameWeather = 'sunny'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                
                // å¤©æ°—ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦å¤©æ°—ã‚’åˆ¤å®š
                // é›ª (Snow): 600-622
                if (weatherCode >= 600 && weatherCode < 623) {
                    gameWeather = 'snow';
                }
                // é›¨ (Rain): 500-531, é›·é›¨ (Thunderstorm): 200-232
                else if ((weatherCode >= 500 && weatherCode < 532) || (weatherCode >= 200 && weatherCode < 233)) {
                    gameWeather = 'rain';
                }
                // æ›‡ã‚Š (Clouds): 801-804
                else if (weatherCode >= 801 && weatherCode < 805) {
                    gameWeather = 'cloudy';
                }
                // æ™´ã‚Œ (Clear): 800
                else if (weatherCode === 800) {
                    gameWeather = 'sunny';
                }
                // ãã®ä»–ã®å¤©æ°—ï¼ˆéœ§ã€éœãªã©ï¼‰ã¯æ›‡ã‚Šã¨ã—ã¦æ‰±ã†
                else {
                    gameWeather = 'cloudy';
                }
                
                log(`å¤©æ°—ã‚’å¤‰æ›´ã—ã¾ã™: ${gameWeather}`);
                
                // å¤©æ°—ã‚’å¤‰æ›´
                changeWeather(gameWeather);
                
                // å¤©æ°—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
                document.querySelectorAll('.weatherOption').forEach(button => {
                    if (button.getAttribute('data-weather') === gameWeather) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
                
                return gameWeather;
            } catch (error) {
                console.error('å¤©æ°—æƒ…å ±ã®å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                log('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¤©æ°—ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
                
                // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ ãªå¤©æ°—ã‚’è¨­å®š
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
                
                return null;
            }
        }
    </script>
</body>
</html> 