<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エンドレスカー - ロンドン市街地コース</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 170px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: calc(100% - 190px); /* ボタン幅を考慮して調整 */
            z-index: 10;
        }
        #viewButtons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
            flex-wrap: nowrap;
            justify-content: flex-start;
            max-width: 60px;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .button-separator {
            width: 100%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            margin: 5px 0;
        }
        
        .weather-button {
            font-size: 16px !important;
            padding: 2px 6px !important;
        }
        
        .weather-button.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        
        /* ミニマップ用のスタイル */
        #minimap-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            z-index: 99;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        #minimap {
            width: 100%;
            height: 100%;
        }
        
        #minimap-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }
        
        .viewButton {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-bottom: 3px;
            min-width: 30px;
            text-align: center; /* テキストを中央揃え */
            width: 100%; /* ボタンの幅を親要素に合わせる */
        }
        .viewButton:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        .viewButton:active {
            transform: scale(0.95);
        }
        .viewButton.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        /* スマートフォン向け調整 */
        @media (max-width: 480px) {
            #info {
                left: 120px;
                font-size: 12px;
            }
            .viewButton {
                padding: 3px 4px;
                font-size: 10px;
                min-width: 24px;
            }
            #viewButtons {
                gap: 2px;
                max-width: 45px; /* スマホ向けにさらに小さく */
            }
            
            #minimap-container {
                width: 100px;
                height: 80px;
                right: 55px;
            }
            
            /* スマホ向け時間モードボタン位置調整 */
            #timeToggle {
                right: 55px;
                top: 160px; /* 視点ボタンの下に配置 */
            }
            
            /* スマホ向け天気ボタン位置調整を削除 */
            #weatherToggle {
                right: 55px;
                top: 210px; /* 時間モードボタンの下に配置 */
            }
        }
        
        #timeWeatherInfo {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #timeToggleButton {
            background: none;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            padding: 0;
            margin: 0 5px;
        }
        
        #timeToggleButton:hover {
            opacity: 0.8;
        }
        
        /* 天気ボタン用のスタイル追加 */
        .weather-button {
            font-size: 16px !important;
            padding: 2px 6px !important;
        }
        
        /* セパレーター用のスタイル */
        .button-separator {
            width: 100%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            margin: 5px 0;
        }
        /* BGMコントロール用のスタイル */
        #bgmControl {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>
<body>
    <div id="viewButtons">
        <div class="button-group view-buttons">
            <button class="viewButton" data-view="0" title="俯瞰視点 (1)">俯瞰</button>
            <button class="viewButton" data-view="1" title="追従視点 (2)">追従</button>
            <button class="viewButton" data-view="2" title="車載視点 (3)">車載</button>
            <button class="viewButton active" data-view="3" title="斜め上視点 (4)">斜め</button>
            <button class="viewButton" data-view="4" title="前方視点 (5)">前方</button>
        </div>
        <div class="button-separator"></div>
        <div class="button-group weather-buttons">
            <button class="viewButton weather-button" data-weather="sunny" title="晴れ">☀️</button>
            <button class="viewButton weather-button" data-weather="cloudy" title="曇り">☁️</button>
            <button class="viewButton weather-button" data-weather="rain" title="雨">🌧️</button>
            <button class="viewButton weather-button" data-weather="snow" title="雪">❄️</button>
        </div>
    </div>
    <div id="minimap-container">
        <canvas id="minimap" width="150" height="120"></canvas>
    </div>
    <div id="info">
        <div id="timeWeatherInfo" style="font-family: 'Helvetica', sans-serif;">
            <button id="timeToggleButton" title="現在の時刻に連動（クリックで切替）">🕒</button>
            <span id="currentTime">--:--</span>
            <span style="margin: 0 5px;">|</span>
            <span id="currentWeatherText">-</span>
        </div>
    </div>
    <script type="module">
        import { Car } from './Car.js';
        
        // デバッグ用のログ
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
        
        log("スクリプト開始");
        
        // 基本設定
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x646464); // 初期の空の色を設定
        document.body.appendChild(renderer.domElement);
        
        // グローバル定数の定義
        const HORIZONTAL_SCALE = 100; // x,z座標のスケール
        const VERTICAL_SCALE = 4;     // y座標(高さ)のスケール
        const roadWidth = 16;         // 道路の幅
        
        // トラックポイントの定義
        const originalTrackPoints = [
            [4, 0, 7],     // 4,7,0
            [1, 0, 7],     // 1,7,0
            [0, 1, 5],     // 0,5,1
            [0.5, 2, 4],   // 0.5,4,2
            [1.2, 2, 4.3], // 1.2,4.3,2
            [2.5, 2, 2.8], // 2.5,2.8,2
            [2, 5, 1],     // 2,1,3
            [2.7, 3, 0],   // 2.7,0,2.5
            [4, 0, 1],     // 4,1,0
            [4.4, 0, 0.8], // 4.4,0.8,0
            [5.9, 0, 1.8], // 5.9,1.8,0
            [5.7, 1, 2.1], // 5.7,2.1,1
            [4.2, 1, 2.2], // 4.2,2.2,1
            [3.7, 2, 2.9], // 3.7,2.9,2
            [3, 2, 4.7],   // 3,4.7,2
            [3.4, 1, 5.5], // 3.4,5.5,1
            [4.4, 1, 5.5], // 4.4,5.5,1
            [5.4, 2, 4.5], // 5.4,4.5,2
            [5.7, 2, 3.6], // 5.7,3.6,2
            [7.3, 1, 3],   // 7.3,3,1
            [8, 1, 3.3],   // 8,3.3,1
            [9.5, 2, 3.5], // 9.5,3.5,2
            [9, 1, 5],     // 9,5,1
            [7.9, 1, 5.7], // 7.9,5.7,1
            [7, 1, 5.3],   // 7,5.3,1
            [6, 0, 5.5],   // 6,5.5,0
            [4.9, 0, 7],   // 4.9,7,0
            [4, 0, 7]      // 4,7,0
        ];
        
        // スケールを適用してtrackPointsを生成
        const trackPoints = originalTrackPoints.map(point => [
            point[0] * HORIZONTAL_SCALE,
            point[1] * VERTICAL_SCALE,
            point[2] * HORIZONTAL_SCALE
        ]);
        
        // 道路を作成
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);
        
        // 3Dパスポイントに変換
        const carPathPoints = [];
        for (let i = 0; i < trackPoints.length; i++) {
            // 高さ情報（Y軸）を考慮したポイントを作成
            carPathPoints.push(new THREE.Vector3(trackPoints[i][0], trackPoints[i][1] + 0.3, trackPoints[i][2]));
        }
        
        // カトマル・ロムスプラインで滑らかな曲線を作成
        const carPath = new THREE.CatmullRomCurve3(carPathPoints);
        carPath.closed = true; // 閉じたループに戻す
        
        // パスの詳細なポイントを取得（道路生成用）
        const detailedPathPoints = carPath.getPoints(500);
        
 
        
        // 車のオブジェクト配列
        const cars = [];
        let currentCarIndex = 0;
        
        // 車を作成して配列に追加する関数
        function createCars(count = 1) {
            // 既存の車をクリア
            for (let car of cars) {
                if (car.object) {
                    scene.remove(car.object);
                }
            }
            cars.length = 0;
            
            // 新しい車を作成
            for (let i = 0; i < count; i++) {
                const car = new Car(carPath);
                car.position = i * (1.0 / count); // 均等に配置
                car.createObject(scene);
                cars.push(car);
            }
            for (let i = 0; i < count; i++) {
                const car = cars[i];
                car.setOtherCars(cars.filter(c => c !== car));  
            }
            
            log(`${count}台の車を作成しました`);
        }
        
        // 初期状態では3台の車を作成
        createCars(10);
        
        log("車の作成完了");
        
        // カメラ位置の初期設定（斜め視点向け）
        camera.position.set(100, 70, 90);
        
        log("Three.jsの基本設定完了");
        
        // 時間システムの追加
        let gameTime = 5.0; // 朝5時からスタート
        let timeSpeed = 0.01; // 時間の進み速度 (0.01 = 現実の100倍速)
        let isNight = false;
        let isNightMode = false;
        let useRealTime = true; // デフォルトは現在時刻モード
        let lastCameraChangeTime = Date.now(); // 最後にカメラが変更された時刻
        let cameraChangeInterval = 30000; // カメラ変更の間隔（ミリ秒）
        let availableCameraModes = [0, 1, 2, 3, 4]; // 利用可能なカメラモード

        // 天気システムの追加
        let currentWeather = 'sunny'; // デフォルトは晴れ
        let rainParticles;
        let snowParticles;
        let cloudParticles; // 雲パーティクル追加
        let driftSmokeParticles; // ドリフト煙パーティクル
        let driftSmokeData; // ドリフト煙データ
        let isRaining = false;
        let isSnowing = false;
        let isCloudy = false; // 曇りフラグ追加
        let lastWeatherChangeTime = Date.now(); // 最後に天気が変更された時刻
        let weatherChangeInterval = 30000; // 天気変更の間隔（ミリ秒）
        let availableWeathers = ['sunny', 'cloudy', 'rain', 'snow']; // 利用可能な天気の配列
        let currentFrameTime = Date.now(); // グローバル変数として定義
        let weatherApiKey = '2416f36c5b6368d2de6d3016e34ae8f8'; // OpenWeatherMap APIキー
        
        // グローバル変数として天気の色の影響を保持
        let weatherSkyColor = new THREE.Color(0x87CEEB); // デフォルトは晴れの空の色

        // 時間帯に応じた空の色と光の設定
        function updateDayNightCycle() {
            // 時間モードに応じて時間を更新
            if (useRealTime) {
                // 現在時刻を取得
                const now = new Date();
                gameTime = now.getHours() + now.getMinutes() / 60;
            } else {
                // アプリケーション内の時間を早回しで進める
                gameTime = (gameTime + timeSpeed) % 24;
            }
            
            updateTimeDisplay(); // 時刻表示を更新
            
            // 時間帯に応じた空の色の設定
            let timeSkyColor;
            let lightIntensity;
            let ambientIntensity;
            
            isNight = false;
            if (gameTime >= 5 && gameTime < 7) {
                // 朝焼け（5時～7時）
                const t = (gameTime - 5) / 2;
                timeSkyColor = new THREE.Color(0xff9966).lerp(new THREE.Color(0x87CEEB), t);
                lightIntensity = 0.5 + t * 0.5;
                ambientIntensity = 0.3 + t * 0.3;
            } else if (gameTime >= 7 && gameTime < 17) {
                // 昼間（7時～17時）
                timeSkyColor = new THREE.Color(0x87CEEB);
                lightIntensity = 1.0;
                ambientIntensity = 0.6;
            } else if (gameTime >= 17 && gameTime < 19) {
                // 夕焼け（17時～19時）
                const t = (gameTime - 17) / 2;
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff7733), t);
                lightIntensity = 1.0 - t * 0.5;
                ambientIntensity = 0.6 - t * 0.3;
            } else if (gameTime >= 19 && gameTime < 21) {
                // 日没後（19時～21時）
                const t = (gameTime - 19) / 2;
                timeSkyColor = new THREE.Color(0xff7733).lerp(new THREE.Color(0x111133), t);
                lightIntensity = 0.5 - t * 0.4;
                ambientIntensity = 0.3 - t * 0.2;
                isNight = true;
            } else {
                // 夜間（21時～5時）
                if (gameTime >= 21) {
                    timeSkyColor = new THREE.Color(0x111133);
                } else {
                    // 夜明け前（0時～5時）
                    const t = gameTime / 5;
                    timeSkyColor = new THREE.Color(0x111133).lerp(new THREE.Color(0xff9966), t);
                }
                lightIntensity = 0.1;
                ambientIntensity = 0.1;
                isNight = true;
            }
            
            // 時間帯の色と天気の色を合成
            let finalColor;
            if (currentWeather === 'sunny') {
                finalColor = timeSkyColor;
            } else {
                // 天気による色の影響を強める（0.7は天気の影響度）
                finalColor = timeSkyColor.clone().lerp(weatherSkyColor, 0.7);
            }
            
            // 空の色を設定
            renderer.setClearColor(finalColor.getHex());
            
            // 光源の強度を設定
            directionalLight.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            
            // 夜間は街灯を明るく
            updateStreetLights(isNight);
        }
        
        // 街灯の明るさを更新
        function updateStreetLights(isNight) {
            // 街灯のオブジェクトとライトを更新
            scene.traverse((object) => {
                if (object.userData && object.userData.isStreetlight) {
                    // 街灯本体の発光を設定
                    if (object.material && object.material.emissive) {
                        if (isNight) {
                            // 夜間は明るく発光
                            object.material.emissive.set(0xFFDD99);
                            object.material.emissiveIntensity = 1.0;
                        } else {
                            // 昼間は発光を弱める
                            object.material.emissive.set(0x333333);
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                    
                    // 関連付けられたポイントライトの明るさを設定
                    if (object.userData.pointLight) {
                        const pointLight = object.userData.pointLight;
                        if (isNight) {
                            // 夜間はライトを明るく
                            pointLight.intensity = 2.5;
                            pointLight.distance = 50;
                        } else {
                            // 昼間はライトを弱く（完全に消さない）
                            pointLight.intensity = 0.2;
                            pointLight.distance = 10;
                        }
                    }
                }
            });
        }

        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        // 都市の地面を作成
        const floorSize = 5000; // 床のサイズを2500から2.0倍の5000に拡大
        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x336633, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5; // 床の位置を下げる
        scene.add(floor);
        
        // 舗装された道路の幅
        
        // アスファルト部分を作成
        function createRoadSurface() {
            // 道路の左右のエッジを計算
            const leftEdgePoints = [];
            const rightEdgePoints = [];
            
            for (let i = 0; i < detailedPathPoints.length; i++) {
                const point = detailedPathPoints[i];
                const nextPoint = detailedPathPoints[(i + 1) % detailedPathPoints.length];
                
                // 進行方向ベクトルを計算
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                
                // 上向きベクトル（法線）を計算
                // 高さの変化を考慮した法線ベクトルを計算する（地形に沿った道路）
                const up = new THREE.Vector3(0, 1, 0);
                
                // 右向きベクトル（進行方向と上向きの外積）
                const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                
                // 修正した上向きベクトル（進行方向と右向きの外積）
                const correctedUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                
                // 道路の左右のエッジを計算（修正した法線ベクトルを使用）
                const leftEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(roadWidth / 2));
                const rightEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(-roadWidth / 2));
                
                // 高さを維持（道路面の高さは既にdetailedPathPointsに含まれる）
                // 道路を少し浮かせる（0.05）
                leftEdge.y += 0.05;
                rightEdge.y += 0.05;
                
                leftEdgePoints.push(leftEdge);
                rightEdgePoints.push(rightEdge);
            }
            
            // 道路の表面を三角形メッシュで作成
            const roadGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // すべてのポイントを頂点配列に追加
            for (let i = 0; i < leftEdgePoints.length; i++) {
                vertices.push(leftEdgePoints[i].x, leftEdgePoints[i].y, leftEdgePoints[i].z);
                vertices.push(rightEdgePoints[i].x, rightEdgePoints[i].y, rightEdgePoints[i].z);
            }
            
            // 三角形インデックスを作成
            for (let i = 0; i < leftEdgePoints.length - 1; i++) {
                const v0 = i * 2;
                const v1 = v0 + 1;
                const v2 = v0 + 2;
                const v3 = v0 + 3;
                
                // 2つの三角形で四角形を作成
                indices.push(v0, v1, v2);
                indices.push(v2, v1, v3);
            }
            
            // 最後の部分を閉じる
            const v0 = (leftEdgePoints.length - 1) * 2;
            const v1 = v0 + 1;
            const v2 = 0;
            const v3 = 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
            
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            roadGeometry.setIndex(indices);
            roadGeometry.computeVertexNormals();
            
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,    // より暗めのグレーに
                roughness: 0.98,    // roughnessを最大限に近く設定
                metalness: 0.05,    // metalnessをさらに下げて光の反射を抑える
                side: THREE.DoubleSide
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadGroup.add(roadMesh);
            
            // 白線（実線）を作成 - 削除
            // createRoadLine(detailedPathPoints, 0.05, 0xFFFFFF);
            
            // 縁石を作成（コーナー部分） - 削除
            // createCurbstones();
            
            return roadMesh;
        }
        
        // 道路の白線を作成
        function createRoadLine(pathPoints, lineWidth, color) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.y = 0.1; // 道路の上に浮かせる
            roadGroup.add(line);
            
            return line;
        }
        
        // 縁石を作成（コーナー部分）
        function createCurbstones() {
            // コーナーの位置（パスの割合）
            const cornerPositions = [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.85];
            
            for (let i = 0; i < cornerPositions.length; i++) {
                const t = cornerPositions[i];
                const cornerLength = 0.05; // コーナーの長さ（パスの割合）
                
                for (let j = 0; j < 10; j++) {
                    const segmentT = t + (j * cornerLength / 10);
                    const point = carPath.getPointAt(segmentT);
                    const tangent = carPath.getTangentAt(segmentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (segmentT + 0.005) % 1;
                    const prevT = (segmentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // 縁石の位置（道路の外側）
                    const curbPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(roadWidth / 2)
                    );
                    
                    // 前後方向の傾斜角を計算（Y軸方向の変化から）
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // 赤白の縁石（交互）
                    const color = j % 2 === 0 ? 0xff0000 : 0xffffff;
                    
                    const curbGeometry = new THREE.BoxGeometry(1, 0.3, 1);
                    const curbMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                    
                    // 縁石の位置を道路の高さに合わせる
                    curb.position.copy(curbPosition);
                    curb.position.y = point.y + 0.1; // 道路面より少し浮かせる
                    
                    // 進行方向を向くように回転
                    const lookAtPos = new THREE.Vector3().addVectors(
                        curbPosition,
                        tangent
                    );
                    curb.lookAt(lookAtPos);
                    
                    // 上下の傾斜に合わせて追加の回転
                    curb.rotateX(slope);
                    
                    roadGroup.add(curb);
                }
            }
        }
        
        // ガードレールを作成（コース全体の外側）
        function createGuardrails() {
            // ガードレールの間隔（パスの割合）
            const railSpacing = 0.005; // より密に配置
            const postSpacing = 0.025; // 支柱の間隔
            
            // ガードレール用のグループを作成
            const guardrailGroup = new THREE.Group();
            roadGroup.add(guardrailGroup);
            
            // 道路の両側にガードレールを設置
            createSideGuardrail(1); // 右側
            createSideGuardrail(-1); // 左側
            
            // 特定の側（右側または左側）にガードレールを作成する関数
            function createSideGuardrail(side) {
                // 連続したガードレールのセグメントを格納する配列
                const railSegments = [];
                const railPosts = [];
                
                // ガードレール用の頂点とインデックスを収集
                const railVertices = [];
                const railIndices = [];
                const railUvs = [];
                
                let vertexIndex = 0;
                let currentT = 0;
                
                // ガードレールの頂点データを生成
                while (currentT < 1) {
                    const point = carPath.getPointAt(currentT);
                    const tangent = carPath.getTangentAt(currentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (currentT + 0.005) % 1;
                    const prevT = (currentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ガードレールの位置（道路の外側、side=1で右側、side=-1で左側）
                    const railPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(side * (roadWidth / 2 + 1.2))
                    );
                    
                    // 前後方向の傾斜角を計算
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // ガードレールの高さ調整
                    const railHeight = point.y + 0.8; // 道路面から少し高く
                    
                    // ガードレールの上部と下部の頂点を追加
                    const topRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight + 0.4, // 上部の高さ
                        railPosition.z
                    );
                    
                    const bottomRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight, // 下部の高さ
                        railPosition.z
                    );
                    
                    // 支柱を作成（一定間隔ごと）
                    if (Math.abs(currentT % postSpacing) < railSpacing) {
                        const postGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6);
                        const postMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        
                        // 支柱の位置を設定
                        post.position.copy(new THREE.Vector3(
                            railPosition.x,
                            point.y + 0.5, // 地面からの高さ
                            railPosition.z
                        ));
                        
                        // 支柱を少し内側に傾ける
                        const postLookAt = new THREE.Vector3().addVectors(
                            post.position,
                            normal.clone().multiplyScalar(-0.1 * side) // 内側に少し傾ける
                        );
                        post.lookAt(postLookAt);
                        post.rotateX(Math.PI / 2); // 支柱の向きを修正
                        
                        // 上下の傾斜に合わせて追加の回転
                        post.rotateZ(slope); // X軸ではなくZ軸で回転（支柱の向きが変わっているため）
                        
                        guardrailGroup.add(post);
                        railPosts.push(post);
                    }
                    
                    // 頂点データを追加
                    railVertices.push(
                        topRailPos.x, topRailPos.y, topRailPos.z,
                        bottomRailPos.x, bottomRailPos.y, bottomRailPos.z
                    );
                    
                    // テクスチャ座標を追加
                    railUvs.push(
                        currentT * 20, 0, // 上部のUV座標
                        currentT * 20, 1  // 下部のUV座標
                    );
                    
                    // インデックスを追加（四角形を作成）
                    if (vertexIndex > 0) {
                        // 各セグメント間を三角形で接続
                        railIndices.push(
                            vertexIndex * 2 - 2, vertexIndex * 2, vertexIndex * 2 - 1, // 最初の三角形
                            vertexIndex * 2 - 1, vertexIndex * 2, vertexIndex * 2 + 1  // 二番目の三角形
                        );
                    }
                    
                    vertexIndex++;
                    currentT += railSpacing;
                }
                
                // 最後のセグメントを最初のセグメントと接続して閉じる
                railIndices.push(
                    (vertexIndex - 1) * 2, 0, (vertexIndex - 1) * 2 + 1, // 最初の三角形
                    (vertexIndex - 1) * 2 + 1, 0, 1  // 二番目の三角形
                );
                
                // ガードレールのジオメトリを作成
                const railGeometry = new THREE.BufferGeometry();
                railGeometry.setAttribute('position', new THREE.Float32BufferAttribute(railVertices, 3));
                railGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(railUvs, 2));
                railGeometry.setIndex(railIndices);
                railGeometry.computeVertexNormals();
                
                // 高速道路のガードレールらしい素材
                const railMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE0E0E0,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // ガードレールメッシュを作成
                const railMesh = new THREE.Mesh(railGeometry, railMaterial);
                guardrailGroup.add(railMesh);
            }
        }
        
        // 道路の可視化
        createRoadSurface();
        
        // 高層道路の柱を生成する関数
        function createRoadPillars() {
            const pillarGroup = new THREE.Group();
            roadGroup.add(pillarGroup);
            
            // 柱の間隔（パスの割合）
            const pillarSpacing = 0.04; // 約25本の柱
            
            // コース全体に柱を配置
            let currentT = 0;
            while (currentT < 1) {
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // 地上からの高さが1以上の場合のみ柱を設置
                if (point.y > 1) {
                    // 道路の左右に柱を設置
                    createSinglePillar(point, tangent, 1);  // 右側
                    createSinglePillar(point, tangent, -1); // 左側
                }
                
                currentT += pillarSpacing;
            }
            
            // 1本の柱を生成する関数
            function createSinglePillar(point, tangent, side) {
                // 垂直方向ベクトル（外側方向）
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // 柱の位置（道路の外側）
                const pillarPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 - 1))
                );
                
                // 柱の高さを計算（地上から道路面まで）
                const pillarHeight = point.y;
                
                // 柱のジオメトリとマテリアル
                const pillarGeometry = new THREE.BoxGeometry(2, pillarHeight, 2);
                const pillarMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x888888,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                
                // 柱の位置を設定（Y座標は高さの半分）
                pillar.position.set(
                    pillarPosition.x,
                    pillarHeight / 2,
                    pillarPosition.z
                );
                
                pillarGroup.add(pillar);
            }
        }
        
        // 高層道路の柱を生成
        createRoadPillars();
        
        // ガードレールの作成
        createGuardrails();
        
        log("道路の作成完了");
        
        // 環境オブジェクトを配置（ビルは削除して星空のみに）
        function placeEnvironmentObjects() {
            log("環境オブジェクトの配置開始");
            
            // 街灯を配置
            createStreetlights();
            
            log("環境オブジェクトの配置完了");
        }
        
        // 街灯を作成する関数
        function createStreetlights() {
            // 街灯の間隔（パスの割合）
            const streetlightSpacing = 0.04; // コース全体で約25本の街灯
            
            // 街灯用のグループを作成
            const streetlightGroup = new THREE.Group();
            roadGroup.add(streetlightGroup);
            
            // コース全体に街灯を配置
            let currentT = 0;
            while (currentT < 1) {
                // パス上の位置と接線を取得
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // 垂直方向ベクトル（外側方向）
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // 道路の右側に街灯を設置
                createSingleStreetlight(point, normal, 1); // 右側
                
                currentT += streetlightSpacing;
            }
            
            // 1本の街灯を作成する関数
            function createSingleStreetlight(point, normal, side) {
                // 街灯の位置（道路の外側）
                const lightPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 + 2.0))
                );
                
                // 街灯の支柱
                const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 8, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                
                // 支柱の位置を設定
                pole.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 4, // 地面からの高さ
                    lightPosition.z
                ));
                
                // 支柱を垂直に立てる
                pole.rotation.x = Math.PI / 2;
                
                streetlightGroup.add(pole);
                
                // 街灯の頭部
                const headGeometry = new THREE.BoxGeometry(1.0, 0.4, 0.4);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0xFFDD99,
                    emissiveIntensity: 0.1 // 初期値は低く
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // 頭部の位置を設定
                head.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // 支柱の上部
                    lightPosition.z
                ));
                
                // 頭部を道路に向ける
                head.lookAt(new THREE.Vector3(
                    point.x,
                    point.y + 8,
                    point.z
                ));
                
                // ユーザーデータに街灯フラグを設定
                head.userData.isStreetlight = true;
                
                streetlightGroup.add(head);
                
                // 街灯のライト
                const light = new THREE.PointLight(0xFFDD99, 0.2, 10, 2);
                light.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // 支柱の上部
                    lightPosition.z
                ));
                
                // ライトを街灯の頭部に関連付ける
                head.userData.pointLight = light;
                
                streetlightGroup.add(light);
            }
        }
        
        // カメラモード（0: 俯瞰, 1: 追従, 2: 車載, 3: 斜め視点）
        let cameraMode = 3; // デフォルトを斜め視点モードに設定
        
        // カメラ位置の初期設定（斜め視点向け）
        camera.position.set(100, 70, 90); // 斜め視点の初期位置
        
        // 過去フレームの時間を記録する変数
        let lastFrameTime = Date.now();
        
        // アニメーションループ
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            const metrics = {};
            const startTime = performance.now();
            let lastCheck = startTime;
            
            // フレーム間のデルタタイムを計算
            currentFrameTime = Date.now();
            const deltaTime = (currentFrameTime - lastFrameTime) / 16.67;
            lastFrameTime = currentFrameTime;
            
            // 昼夜サイクルの更新
            updateDayNightCycle();
            metrics.dayNightCycle = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // 天気の更新
            updateWeather(deltaTime);
            metrics.weather = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // 早送りモード時の車の自動切り替え
            if (!useRealTime && currentFrameTime - lastCarChangeTime > carChangeInterval) {
                // 現在の車以外からランダムに選択
                const availableCars = Array.from({length: cars.length}, (_, i) => i).filter(i => i !== currentCarIndex);
                currentCarIndex = availableCars[Math.floor(Math.random() * availableCars.length)];
                
                lastCarChangeTime = currentFrameTime;
                carChangeInterval = 20000 + Math.random() * 10000; // 20-30秒のランダムな間隔
            }
            
            // 車の更新
            for (let i = 0; i < cars.length; i++) {
                const car = cars[i];
                car.update(deltaTime, isNight);
            }
            metrics.carUpdates = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // カメラの更新
            updateCamera();
            metrics.camera = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // ミニマップの更新
            updateMinimap();
            metrics.minimap = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // レンダリング
            renderer.render(scene, camera);
            metrics.rendering = performance.now() - lastCheck;
            
            // 全体の実行時間
            metrics.total = performance.now() - startTime;
            
            // 100フレームごとにメトリクスを出力
            frameCount++;
            if (frameCount % 100 === 0) {
                console.log('Frame Performance Metrics:');
                console.table(metrics);
            }
        }
        
        // カメラの位置と向きを更新
        function updateCamera() {
            const currentCar = cars[currentCarIndex];
            if (!currentCar || !currentCar.object) return;

            switch (cameraMode) {
                case 0: // 俯瞰
                    // 車の真上からの追従視点
                    const topOffset = new THREE.Vector3(0, 100, 0); // 高さ100の真上
                    const targetTopCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, topOffset);
                    camera.position.lerp(targetTopCameraPos, 0.1); // スムーズな追従
                    camera.lookAt(currentCar.object.position);
                    
                    // 視野角を広めに設定して見やすく
                    camera.fov = 70;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 1: // 追従
                    // 車の後ろから少し上の位置（Z軸を正に変更して車の後ろに）
                    const followOffset = new THREE.Vector3(0, 10, 20); // 高さを少し上げる（起伏に対応）
                    // 車の向きに合わせてオフセットを回転
                    const rotatedOffset = followOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedOffset);
                    camera.position.lerp(targetCameraPos, 0.1); // スムージング
                    
                    // カメラの注視点を車の位置に設定（少し前に）
                    const lookAheadOffset = new THREE.Vector3(0, -2, -20).applyQuaternion(currentCar.object.quaternion);
                    const lookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, lookAheadOffset);
                    camera.lookAt(lookAtPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 2: // 車載
                    // 車の後ろから少し上の位置（Z軸を正に変更して車の後ろに）
                    const fpvOffset = new THREE.Vector3(0, 3, -12); // 高さを少し上げる（起伏に対応）
                    // 車の向きに合わせてオフセットを回転
                    const rotatedFpvOffset = fpvOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetFpvCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedFpvOffset);
                    camera.position.lerp(targetFpvCameraPos, 0.1); // スムージング
                    
                    // カメラの注視点を車の位置に設定（少し前に）
                    const fpvLookAheadOffset = new THREE.Vector3(0, -2, -30).applyQuaternion(currentCar.object.quaternion);
                    const fpvLookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, fpvLookAheadOffset);
                    camera.lookAt(fpvLookAtPoint);
                    
                    camera.fov = 75;
                    camera.updateProjectionMatrix();

                    break;
                case 3: // 斜め上視点
                    // 車の上と横から見る位置（車の傾きを強調して見せるため）
                    const diagonalOffset = new THREE.Vector3(50, 40, 20); // 右上からかなり離れた位置に配置
                    // 車の向きに合わせてオフセットを回転
                    const rotatedDiagOffset = diagonalOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetDiagCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedDiagOffset);
                    camera.position.lerp(targetDiagCameraPos, 0.1); // スムージング
                    
                    // 車をしっかり見る（少し前を見るように設定）
                    const diagLookOffset = new THREE.Vector3(0, -1, -5).applyQuaternion(currentCar.object.quaternion);
                    const diagLookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, diagLookOffset);
                    camera.lookAt(diagLookAtPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 4: // 車前方から後方を見る視点
                    // 車の前方の位置（Z軸を負に変更して車の前方に）
                    const frontOffset = new THREE.Vector3(0, 5, -32); // 車の前方、より離れた位置に変更
                    // 車の向きに合わせてオフセットを回転
                    const rotatedFrontOffset = frontOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetFrontCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedFrontOffset);
                    camera.position.lerp(targetFrontCameraPos, 0.1); // スムージング
                    
                    // カメラが車の後方を見るようにする
                    const lookBackOffset = new THREE.Vector3(0, 0, 20).applyQuaternion(currentCar.object.quaternion);
                    const lookBackPoint = new THREE.Vector3().addVectors(currentCar.object.position, lookBackOffset);
                    camera.lookAt(lookBackPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
            }
        }
        
        // リサイズ処理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 視点切り替えボタンの設定
        function setupViewButtons() {
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                button.addEventListener('click', () => {
                    cameraMode = parseInt(button.getAttribute('data-view'));
                    updateButtonActiveState();
                });
            });
        }

        // ボタンのアクティブ状態を更新
        function updateButtonActiveState() {
            // 視点ボタンの状態を更新（.view-buttons内のボタンのみ）
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // 初期化関数
        function init() {
            // 環境オブジェクトを配置
            placeEnvironmentObjects();
            
            // 視点切り替えボタンの設定
            setupViewButtons();
            
            // 天気ボタンの設定
            setupWeatherButtons();
            
            // 初期天気のボタンをアクティブに
            updateWeatherButtonState(currentWeather);
            
            // ミニマップのクリックイベントを設定
            document.getElementById('minimap-container').addEventListener('click', () => {
                // タブキーと同じ動作：次の車に切り替え
                currentCarIndex = (currentCarIndex + 1) % cars.length;
            });
            
            // アニメーションスタート
            log("アニメーション開始");
            animate();
            
            // 天気システムの初期化
            initWeatherSystem();
        }

        // ページ読み込み完了時に初期化を実行
        window.onload = init;


        // キーボードイベントを設定
        function setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case 'Tab':
                        // Tabキーで車を切り替え
                        event.preventDefault(); // デフォルトのTab動作を防止
                        currentCarIndex = (currentCarIndex + 1) % cars.length;
                        break;
                    case '1':
                        cameraMode = 0; // 俯瞰
                        updateCameraButtonState();
                        break;
                    case '2':
                        cameraMode = 1; // 追従
                        updateCameraButtonState();
                        break;
                    case '3':
                        cameraMode = 2; // 車載
                        updateCameraButtonState();
                        break;
                    case '4':
                        cameraMode = 3; // 斜め
                        updateCameraButtonState();
                        break;
                    case '5':
                        cameraMode = 4; // 前方
                        updateCameraButtonState();
                        break;
                }
            });
        }

        // キーボードイベントを設定
        setupKeyboardControls();

        // 時間モード切替ボタンのイベントリスナー
        document.getElementById('timeToggleButton').addEventListener('click', function() {
            useRealTime = !useRealTime;
            
            // ボタンの表示を更新
            if (useRealTime) {
                this.textContent = '🕒';
                this.title = '現在の時刻に連動（クリックで切替）';
                
                // 現実時間モードに戻ったら天気とカメラの自動変更をリセット
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 30000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 30000;
                
                // 現在地点の天気を取得して反映
                fetchCurrentWeather();
            } else {
                this.textContent = '⏩';
                this.title = 'ゲーム内時間モード（クリックで切替）';
                
                // 早送りモードに入ったら天気表示を非表示に
                updateWeatherDisplay(null, false);
                
                // 早送りモードに入ったら天気とカメラを自動更新開始
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 20000 + Math.random() * 20000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 10000 + Math.random() * 5000;
            }
        });

        // DOMContentLoadedイベントリスナーは削除（init関数に移動済み）

        // ページ読み込み完了時に初期化を実行
        window.onload = init;

        // DOMContentLoadedイベントリスナーを削除（重複初期化防止のため）
        
        // 天気システムの初期化
        function initWeatherSystem() {
            // 雪のパーティクルシステムを作成
            createSnowParticles();
            
            // 雨のパーティクルシステムを作成
            createRainParticles();
            
            // 雲のパーティクルシステム追加
            const cloudGeometry = new THREE.BufferGeometry();
            const cloudCount = 500; // 雲は雪より少なく
            const cloudPositions = new Float32Array(cloudCount * 3);
            const cloudSizes = new Float32Array(cloudCount);
            
            for (let i = 0; i < cloudCount * 3; i += 3) {
                cloudPositions[i] = Math.random() * 3000 - 1500; // x: -1500 to 1500 (広範囲に配置)
                cloudPositions[i+1] = 300 + Math.random() * 500; // y: 300 to 800 (高い位置に配置)
                cloudPositions[i+2] = Math.random() * 3000 - 1500; // z: -1500 to 1500
                cloudSizes[i/3] = 20.0 + Math.random() * 30.0; // 雲は大きめに
            }
            
            cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
            cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));
            
            // 雲のテクスチャを使用
            const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud10.png');
            
            const cloudMaterial = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 30.0,
                transparent: true,
                opacity: 0.7,
                map: cloudTexture,
                sizeAttenuation: true,
                depthWrite: false // 半透明のため、深度書き込みをオフ
            });
            
            cloudParticles = new THREE.Points(cloudGeometry, cloudMaterial);
            cloudParticles.visible = false;
            scene.add(cloudParticles);
            
            // 初期天気の設定
            if (useRealTime) {
                // 現在地点の天気を取得して反映
                fetchCurrentWeather();
            } else {
                // ランダムな天気を設定
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
            }
        }
        
        // 天気を変更する関数
        function changeWeather(weather, isFromCurrentLocation = false, temperature = null, windSpeed = null) {
            currentWeather = weather;
            updateWeatherDisplay(weather, isFromCurrentLocation, temperature, windSpeed);
            updateWeatherButtonState(weather);
            
            switch(weather) {
                case 'sunny':
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = false;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = false;
                    updateEnvironmentForSunny();
                    break;
                    
                case 'cloudy':
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForCloudy();
                    break;
                    
                case 'rain':
                    isRaining = true;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = true;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForRain();
                    break;
                    
                case 'snow':
                    isRaining = false;
                    isSnowing = true;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = true;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForSnow();
                    break;
            }
        }
        
        // 曇りの環境更新
        function updateEnvironmentForCloudy() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) { // 俯瞰視点の場合
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.003);
            }
            
            // 曇りの空の色を設定（グレーがかった色）
            weatherSkyColor = new THREE.Color(0x8c8c8c);
            
            // 曇り時の芝生の色
            floor.material.color.setHex(0x2a552a);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // 雨の環境更新
        function updateEnvironmentForRain() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0x555555, 0.001);
            } else {
                scene.fog = new THREE.FogExp2(0x555555, 0.007);
            }
            
            // 雨の空の色を設定（暗いグレー）
            weatherSkyColor = new THREE.Color(0x4a4a4a);
            
            // 地面を濡れた感じに
            floor.material.color.setHex(0x1c4d1c);
            floor.material.roughness = 0.9; // より反射するように
            floor.material.metalness = 0.5; // より金属感を増やして反射を強める
            floor.material.needsUpdate = true;
        }
        
        // 雪の環境更新
        function updateEnvironmentForSnow() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0005);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.005);
            }
            
            // 雪の空の色を設定（明るいグレー）
            weatherSkyColor = new THREE.Color(0xd8d8d8);
            
            // 地面を雪で覆われたように
            floor.material.color.setHex(0xf0f0f0);
            floor.material.roughness = 0.9;
            floor.material.metalness = 0.0
            floor.material.needsUpdate = true;
        }
        
        // 晴れの環境更新
        function updateEnvironmentForSunny() {
            // 霧をなくす
            scene.fog = null;
            
            // 晴れの空の色を設定（明るい青空）
            weatherSkyColor = new THREE.Color(0x87CEEB);
            
            // 通常の芝生の色に戻す
            floor.material.color.setHex(0x336633);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // 天気の更新
        function updateWeather(deltaTime) {
            // 早送りモード時の自動天気変更とカメラ切り替え
            if (!useRealTime) {
                const currentTime = Date.now();
                
                // 天気の自動変更
                if (currentTime - lastWeatherChangeTime > weatherChangeInterval) {
                    const availableChoices = availableWeathers.filter(w => w !== currentWeather);
                    const nextWeather = availableChoices[Math.floor(Math.random() * availableChoices.length)];
                    changeWeather(nextWeather);
                    lastWeatherChangeTime = currentTime;
                    weatherChangeInterval = 20000 + Math.random() * 20000;
                }
                
                // カメラの自動切り替え
                if (currentTime - lastCameraChangeTime > cameraChangeInterval) {
                    const availableViews = availableCameraModes.filter(mode => mode !== cameraMode);
                    const nextCameraMode = availableViews[Math.floor(Math.random() * availableViews.length)];
                    cameraMode = nextCameraMode;
                    updateCameraButtonState();
                    
                    lastCameraChangeTime = currentTime;
                    cameraChangeInterval = 10000 + Math.random() * 5000;
                }
            }
            
            // 雲のアニメーション
            if (isCloudy && cloudParticles) {
                cloudParticles.visible = true;
                cloudParticles.position.x = camera.position.x;
                cloudParticles.position.z = camera.position.z;
            } else if (cloudParticles) {
                cloudParticles.visible = false;
            }
            
            // 雨のアニメーション
            if (isRaining && rainParticles) {
                const positions = rainParticles.userData.positions;
                const speeds = rainParticles.userData.speeds;
                const swayFactors = rainParticles.userData.swayFactors;
                const phases = rainParticles.userData.phases;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length; i += 6) {
                    const index = i / 6;
                    
                    positions[i + 1] -= speeds[index] * deltaTime;
                    positions[i + 4] -= speeds[index] * deltaTime;
                    
                    const swayAmount = swayFactors[index];
                    const phase = phases[index];
                    const swayX = Math.sin(time + phase) * swayAmount * 0.1 * deltaTime;
                    const swayZ = Math.cos(time * 0.8 + phase) * swayAmount * 0.1 * deltaTime;
                    
                    positions[i] += swayX;
                    positions[i + 2] += swayZ;
                    positions[i + 3] += swayX;
                    positions[i + 5] += swayZ;
                    
                    if (positions[i + 4] < 0) {
                        const x = Math.random() * 2000 - 1000;
                        const y = 1000;
                        const z = Math.random() * 2000 - 1000;
                        
                        positions[i] = x;
                        positions[i + 1] = y;
                        positions[i + 2] = z;
                        
                        positions[i + 3] = x;
                        positions[i + 4] = y - 10;
                        positions[i + 5] = z;
                    }
                }
                
                rainParticles.position.x = camera.position.x;
                rainParticles.position.z = camera.position.z;
                
                rainParticles.geometry.attributes.position.needsUpdate = true;
            } else if (rainParticles) {
                rainParticles.visible = false;
            }
            
            // 雪のアニメーション
            if (isSnowing && snowParticles) {
                const positions = snowParticles.userData.positions;
                const speeds = snowParticles.userData.speeds;
                const swayFactors = snowParticles.userData.swayFactors;
                const phases = snowParticles.userData.phases;
                const time = Date.now() * 0.001; // 秒単位の時間
                
                for (let i = 0; i < positions.length; i += 3) {
                    const index = i / 3;
                    
                    // Y座標（落下）の更新
                    positions[i + 1] -= speeds[index] * deltaTime;
                    
                    // X座標とZ座標の揺れを更新（サインカーブを使用）
                    const swayAmount = swayFactors[index];
                    const phase = phases[index];
                    positions[i] += Math.sin(time + phase) * swayAmount * 0.1 * deltaTime;
                    positions[i + 2] += Math.cos(time * 0.8 + phase) * swayAmount * 0.1 * deltaTime;
                    
                    // 地面に到達したら上に戻す
                    if (positions[i + 1] < 0) {
                        positions[i] = Math.random() * 2000 - 1000;     // X
                        positions[i + 1] = 1000;                        // Y
                        positions[i + 2] = Math.random() * 2000 - 1000; // Z
                    }
                }
                
                // カメラを中心に雪を配置
                snowParticles.position.x = camera.position.x;
                snowParticles.position.z = camera.position.z;
                
                snowParticles.geometry.attributes.position.needsUpdate = true;
            } else if (snowParticles) {
                snowParticles.visible = false;
            }
        }

        // カメラモードボタンの表示を更新する関数
        function updateCameraButtonState() {
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // 現在位置の天気を取得する関数
        async function fetchCurrentWeather() {
            try {
                // 現在位置を取得
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                log(`現在位置を取得しました: 緯度 ${lat}, 経度 ${lon}`);
                
                // OpenWeatherMap APIを呼び出し
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${weatherApiKey}&units=metric`);
                
                if (!response.ok) {
                    throw new Error('天気情報の取得に失敗しました');
                }
                
                const data = await response.json();
                
                // 気温と風速を取得
                const temperature = data.main.temp;
                const windSpeed = data.wind.speed;
                
                // 気温と風速を保存
                currentTemperature = temperature;
                currentWindSpeed = windSpeed;
                
                log(`気温: ${temperature}℃, 風速: ${windSpeed}m/s`);
                
                // 天気コードに基づいて天気を設定
                const weatherCode = data.weather[0].id;
                let gameWeather = 'sunny'; // デフォルト
                
                // 天気コードに基づいて天気を判定
                if (weatherCode >= 600 && weatherCode < 623) {
                    gameWeather = 'snow';
                } else if ((weatherCode >= 500 && weatherCode < 532) || (weatherCode >= 200 && weatherCode < 233)) {
                    gameWeather = 'rain';
                } else if (weatherCode >= 801 && weatherCode < 805) {
                    gameWeather = 'cloudy';
                } else if (weatherCode === 800) {
                    gameWeather = 'sunny';
                } else {
                    gameWeather = 'cloudy';
                }
                
                log(`天気を変更します: ${gameWeather}`);
                
                // 天気を変更（気温と風速も渡す）
                changeWeather(gameWeather, true, temperature, windSpeed);
                
                return gameWeather;
            } catch (error) {
                console.error('天気情報の取得エラー:', error);
                log('天気情報の取得に失敗しました。デフォルトの天気を使用します。');
                
                updateWeatherDisplay('-', false); // エラー時は天気表示を非表示に
                
                // エラーの場合はランダムな天気を設定（表示はしない）
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather, false);
                
                return null;
            }
        }

        // 時刻表示を更新する関数
        function updateTimeDisplay() {
            const timeDisplay = document.getElementById('currentTime');
            if (useRealTime) {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                timeDisplay.textContent = `${hours}:${minutes}`;
            } else {
                const hours = Math.floor(gameTime).toString().padStart(2, '0');
                const minutes = Math.floor((gameTime % 1) * 60).toString().padStart(2, '0');
                timeDisplay.textContent = `${hours}:${minutes}`;
            }
        }

        // 天気表示を更新する関数
        function updateWeatherDisplay(weather, isFromCurrentLocation = false, temperature = null, windSpeed = null) {
            const weatherDisplay = document.getElementById('currentWeatherText');
            
            // 早送りモードまたは現在地からの天気でない場合は非表示
            if (!useRealTime || !isFromCurrentLocation) {
                weatherDisplay.textContent = '-';
                return;
            }
            
            const weatherMap = {
                'sunny': '☀️',
                'cloudy': '☁️',
                'rain': '🌧️',
                'snow': '❄️'
            };
            
            let displayText = weatherMap[weather] || '-';
            displayText += ` ${Math.round(temperature)}℃`;
            displayText += ` ${Math.round(windSpeed)}m/s `;
            
            weatherDisplay.textContent = displayText;
        }

        // 天気ボタンのイベントリスナーを修正
        function setupWeatherButtons() {
            document.querySelectorAll('.weather-button').forEach(button => {
                button.addEventListener('click', function() {
                    const selectedWeather = this.getAttribute('data-weather');
                    
                    // 以前の天気をリセット
                    document.querySelectorAll('.weather-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // 選択された天気をアクティブに
                    this.classList.add('active');
                    
                    // 天気を変更（手動変更なのでisFromCurrentLocation = false）
                    changeWeather(selectedWeather, false);
                });
            });
        }

        // 天気ボタンのアクティブ状態を更新する関数
        function updateWeatherButtonState(weather) {
            document.querySelectorAll('.weather-button').forEach(button => {
                if (button.getAttribute('data-weather') === weather) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // グローバル変数に気温と風速を追加
        let currentTemperature = null;
        let currentWindSpeed = null;

        // 雨のパーティクルシステムを作成
        function createRainParticles() {
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 7500; // 15000から7500に減らす
            
            // 雨粒の位置配列を作成（各雨粒の開始点と終点）
            const rainPositions = new Float32Array(rainCount * 6); // 2点（開始点と終点）で1つの線を表現
            const rainSpeeds = new Float32Array(rainCount);
            const rainSwayFactors = new Float32Array(rainCount);
            const rainPhases = new Float32Array(rainCount);
            
            for (let i = 0; i < rainCount; i++) {
                const baseIndex = i * 6;
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 1000;
                const z = Math.random() * 2000 - 1000;
                
                // 線の開始点
                rainPositions[baseIndex] = x;
                rainPositions[baseIndex + 1] = y;
                rainPositions[baseIndex + 2] = z;
                
                // 線の終点（開始点より10単位下）
                rainPositions[baseIndex + 3] = x;
                rainPositions[baseIndex + 4] = y - 10;
                rainPositions[baseIndex + 5] = z;
                
                // 個別の雨粒のパラメータを設定
                rainSpeeds[i] = 20.0 + Math.random() * 10.0;
                rainSwayFactors[i] = 0.1 + Math.random() * 0.2;
                rainPhases[i] = Math.random() * Math.PI * 2;
            }
            
            rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
            
            const rainMaterial = new THREE.LineBasicMaterial({
                color: 0x99ccff,
                opacity: 0.4,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            rainParticles = new THREE.LineSegments(rainGeometry, rainMaterial);
            rainParticles.visible = false;
            scene.add(rainParticles);
            
            // アニメーション用のデータをパーティクルシステムに保存
            rainParticles.userData = {
                positions: rainPositions,
                speeds: rainSpeeds,
                swayFactors: rainSwayFactors,
                phases: rainPhases
            };
        }

        // 雪のパーティクルシステムを作成
        function createSnowParticles() {
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 5000; // 10000から5000に減らす
            
            // 雪片の位置配列を作成
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSpeeds = new Float32Array(snowCount); // 個別の速度を保存
            const snowSwayFactors = new Float32Array(snowCount); // 揺れの係数を保存
            const snowPhases = new Float32Array(snowCount); // 位相のずれを保存
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                snowPositions[i] = Math.random() * 2000 - 1000;     // X
                snowPositions[i + 1] = Math.random() * 1000;        // Y
                snowPositions[i + 2] = Math.random() * 2000 - 1000; // Z
                
                // 個別の雪片のパラメータを設定
                const index = i / 3;
                snowSpeeds[index] = 0.5 + Math.random() * 1.0; // 0.5〜1.5の範囲でランダムな速度
                snowSwayFactors[index] = 0.3 + Math.random() * 0.4; // 0.3〜0.7の範囲で揺れの大きさ
                snowPhases[index] = Math.random() * Math.PI * 2; // 0〜2πの範囲で初期位相
            }
            
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                opacity: 0.8,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            snowParticles.visible = false;
            scene.add(snowParticles);
            
            // アニメーション用のデータをパーティクルシステムに保存
            snowParticles.userData = {
                positions: snowPositions,
                speeds: snowSpeeds,
                swayFactors: snowSwayFactors,
                phases: snowPhases
            };
        }

        // ミニマップの更新関数
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // キャンバスをクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 背景色
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // パスの描画に必要な変数
            const margin = 10;
            const pathPoints = [];
            
            // パスの座標を取得
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const point = carPath.getPointAt(t);
                pathPoints.push(point);
            }
            
            // 座標の最小値と最大値を計算
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (const point of pathPoints) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minZ = Math.min(minZ, point.z);
                maxZ = Math.max(maxZ, point.z);
            }
            
            // スケールを計算（余白を考慮）
            const width = canvas.width - margin * 2;
            const height = canvas.height - margin * 2;
            const scaleX = width / (maxX - minX);
            const scaleZ = height / (maxZ - minZ);
            const scale = Math.min(scaleX, scaleZ);
            
            // パスを描画
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const x = margin + (point.x - minX) * scale;
                const z = margin + (point.z - minZ) * scale;
                
                if (i === 0) {
                    ctx.moveTo(x, z);
                } else {
                    ctx.lineTo(x, z);
                }
            }
            
            ctx.closePath();
            ctx.stroke();
            
            // 車の位置をミニマップ上で表示
            for (let i = 0; i < cars.length; i++) {
                const car = cars[i];
                const point = carPath.getPointAt(car.position);
                const x = margin + (point.x - minX) * scale;
                const y = margin + (point.z - minZ) * scale;
                
                // 車の向きを計算
                const tangent = carPath.getTangentAt(car.position).normalize();
                const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                
                // 車を三角形で描画
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -5);  // 先端
                ctx.lineTo(-3, 3);  // 左下
                ctx.lineTo(3, 3);   // 右下
                ctx.closePath();
                ctx.fillStyle = (i === currentCarIndex) ? 'red' : 'white';
                ctx.fill();
                ctx.restore();
            }
        }

        // 車の自動切り替え用の変数を初期化
        let lastCarChangeTime = Date.now();
        let carChangeInterval = 20000 + Math.random() * 10000; // 20-30秒のランダムな間隔
    </script>
</body>
</html> 