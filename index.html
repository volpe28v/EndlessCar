<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エンドレスカー - ロンドン市街地コース</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: calc(100% - 190px); /* ボタン幅を考慮して調整 */
            z-index: 10;
        }
        #viewButtons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column; /* 縦に並べる */
            gap: 5px;
            z-index: 100;
            flex-wrap: nowrap; /* 折り返しなし */
            justify-content: flex-start;
            max-width: 60px; /* ボタンの幅に合わせて調整 */
        }
        
        /* ミニマップ用のスタイル */
        #minimap-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            z-index: 99;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        #minimap {
            width: 100%;
            height: 100%;
        }
        
        #minimap-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }
        
        .viewButton {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-bottom: 3px;
            min-width: 30px;
            text-align: center; /* テキストを中央揃え */
            width: 100%; /* ボタンの幅を親要素に合わせる */
        }
        .viewButton:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        .viewButton:active {
            transform: scale(0.95);
        }
        .viewButton.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        /* スマートフォン向け調整 */
        @media (max-width: 480px) {
            #info {
                max-width: 60%;
                font-size: 12px;
                padding: 6px;
            }
            .viewButton {
                padding: 3px 4px;
                font-size: 10px;
                min-width: 24px;
            }
            #viewButtons {
                gap: 2px;
                max-width: 45px; /* スマホ向けにさらに小さく */
            }
            
            #minimap-container {
                width: 100px;
                height: 100px;
                right: 55px;
            }
            
            /* スマホ向け時間モードボタン位置調整 */
            #timeToggle {
                right: 55px;
                top: 160px; /* 視点ボタンの下に配置 */
            }
            
            /* スマホ向け天気ボタン位置調整 */
            #weatherToggle {
                right: 55px;
                top: 210px; /* 時間モードボタンの下に配置 */
            }
        }
        
        #weatherToggleButton, .weatherOption {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 16px;
            cursor: pointer;
            outline: none;
            transition: background-color 0.3s;
        }
        
        #weatherToggleButton:hover, .weatherOption:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        
        .weatherOption.active {
            background-color: rgba(100, 100, 100, 0.7);
            border-color: #888;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>
<body>
    <div id="viewButtons">
        <button class="viewButton" data-view="0" title="俯瞰視点 (1)">俯瞰</button>
        <button class="viewButton" data-view="1" title="追従視点 (2)">追従</button>
        <button class="viewButton" data-view="2" title="車載視点 (3)">車載</button>
        <button class="viewButton active" data-view="3" title="斜め上視点 (4)">斜め</button>
        <button class="viewButton" data-view="4" title="前方視点 (5)">前方</button>
    </div>
    <div id="timeToggle" style="position: fixed; top: 10px; right: 80px; z-index: 100;">
        <button id="timeToggleButton" title="現在の時刻に連動（クリックで切替）">🕒</button>
    </div>
    <div id="weatherToggle" style="position: fixed; top: 10px; right: 140px; z-index: 100;">
        <button id="weatherToggleButton" title="天気を変更">☀️</button>
        <div id="weatherMenu" style="display: none; position: absolute; top: 30px; right: 0; background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; padding: 5px;">
            <button class="weatherOption active" data-weather="sunny" title="晴れ">☀️</button>
            <button class="weatherOption" data-weather="cloudy" title="曇り">☁️</button>
            <button class="weatherOption" data-weather="rain" title="雨">🌧</button>
            <button class="weatherOption" data-weather="snow" title="雪">❄️</button>
        </div>
    </div>
    <div id="minimap-container">
        <canvas id="minimap" width="150" height="120"></canvas>
    </div>
    <script>
        // デバッグ用のログ
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
        
        log("スクリプト開始");
        
        // 基本設定
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x646464); // 初期の空の色を設定
        document.body.appendChild(renderer.domElement);
        
        log("Three.jsの基本設定完了");

        // 時間システムの追加
        let gameTime = 5.0; // 朝5時からスタート
        let timeSpeed = 0.01; // 時間の進み速度 (0.01 = 現実の100倍速)
        let isNight = false;
        let isNightMode = false;
        let useRealTime = true; // デフォルトは現在時刻モード
        let lastCameraChangeTime = Date.now(); // 最後にカメラが変更された時刻
        let cameraChangeInterval = 30000; // カメラ変更の間隔（ミリ秒）
        let availableCameraModes = [0, 1, 2, 3, 4]; // 利用可能なカメラモード

        // 天気システムの追加
        let currentWeather = 'sunny'; // デフォルトは晴れ
        let rainParticles;
        let snowParticles;
        let cloudParticles; // 雲パーティクル追加
        let driftSmokeParticles; // ドリフト煙パーティクル
        let driftSmokeData; // ドリフト煙データ
        let isRaining = false;
        let isSnowing = false;
        let isCloudy = false; // 曇りフラグ追加
        let lastWeatherChangeTime = Date.now(); // 最後に天気が変更された時刻
        let weatherChangeInterval = 30000; // 天気変更の間隔（ミリ秒）
        let availableWeathers = ['sunny', 'cloudy', 'rain', 'snow']; // 利用可能な天気の配列
        let currentFrameTime = Date.now(); // グローバル変数として定義
        let weatherApiKey = '2416f36c5b6368d2de6d3016e34ae8f8'; // OpenWeatherMap APIキー
        
        // ヘッドライト用のグローバル変数
        let leftHeadlightLight;
        let rightHeadlightLight;
        
        // グローバル変数として天気の色の影響を保持
        let weatherSkyColor = new THREE.Color(0x87CEEB); // デフォルトは晴れの空の色

        // 時間帯に応じた空の色と光の設定
        function updateDayNightCycle() {
            // 時間モードに応じて時間を更新
            if (useRealTime) {
                // 現在時刻を取得
                const now = new Date();
                gameTime = now.getHours() + now.getMinutes() / 60;
            } else {
                // アプリケーション内の時間を早回しで進める
                gameTime = (gameTime + timeSpeed) % 24;
            }
            
            // 時間帯に応じた空の色の設定
            let timeSkyColor;
            let lightIntensity;
            let ambientIntensity;
            let isNight = false;
            
            if (gameTime >= 5 && gameTime < 7) {
                // 朝焼け（5時～7時）
                const t = (gameTime - 5) / 2;
                timeSkyColor = new THREE.Color(0xff9966).lerp(new THREE.Color(0x87CEEB), t);
                lightIntensity = 0.5 + t * 0.5;
                ambientIntensity = 0.3 + t * 0.3;
            } else if (gameTime >= 7 && gameTime < 17) {
                // 昼間（7時～17時）
                timeSkyColor = new THREE.Color(0x87CEEB);
                lightIntensity = 1.0;
                ambientIntensity = 0.6;
            } else if (gameTime >= 17 && gameTime < 19) {
                // 夕焼け（17時～19時）
                const t = (gameTime - 17) / 2;
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff7733), t);
                lightIntensity = 1.0 - t * 0.5;
                ambientIntensity = 0.6 - t * 0.3;
            } else if (gameTime >= 19 && gameTime < 21) {
                // 日没後（19時～21時）
                const t = (gameTime - 19) / 2;
                timeSkyColor = new THREE.Color(0xff7733).lerp(new THREE.Color(0x111133), t);
                lightIntensity = 0.5 - t * 0.4;
                ambientIntensity = 0.3 - t * 0.2;
                isNight = true;
            } else {
                // 夜間（21時～5時）
                if (gameTime >= 21) {
                    timeSkyColor = new THREE.Color(0x111133);
                } else {
                    // 夜明け前（0時～5時）
                    const t = gameTime / 5;
                    timeSkyColor = new THREE.Color(0x111133).lerp(new THREE.Color(0xff9966), t);
                }
                lightIntensity = 0.1;
                ambientIntensity = 0.1;
                isNight = true;
            }
            
            // 時間帯の色と天気の色を合成
            let finalColor;
            if (currentWeather === 'sunny') {
                finalColor = timeSkyColor;
            } else {
                // 天気による色の影響を強める（0.7は天気の影響度）
                finalColor = timeSkyColor.clone().lerp(weatherSkyColor, 0.7);
            }
            
            // 空の色を設定
            renderer.setClearColor(finalColor.getHex());
            
            // 光源の強度を設定
            directionalLight.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            
            // 夜間は街灯を明るく
            updateStreetLights(isNight);
            
            // 夜間はヘッドライトをオン、昼間はオフ
            if (leftHeadlightLight && rightHeadlightLight) {
                leftHeadlightLight.visible = isNight;
                rightHeadlightLight.visible = isNight;
            }
        }
        
        // 街灯の明るさを更新
        function updateStreetLights(isNight) {
            // 街灯のオブジェクトとライトを更新
            scene.traverse((object) => {
                if (object.userData && object.userData.isStreetlight) {
                    // 街灯本体の発光を設定
                    if (object.material && object.material.emissive) {
                        if (isNight) {
                            // 夜間は明るく発光
                            object.material.emissive.set(0xFFDD99);
                            object.material.emissiveIntensity = 1.0;
                        } else {
                            // 昼間は発光を弱める
                            object.material.emissive.set(0x333333);
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                    
                    // 関連付けられたポイントライトの明るさを設定
                    if (object.userData.pointLight) {
                        const pointLight = object.userData.pointLight;
                        if (isNight) {
                            // 夜間はライトを明るく
                            pointLight.intensity = 2.5;
                            pointLight.distance = 50;
                        } else {
                            // 昼間はライトを弱く（完全に消さない）
                            pointLight.intensity = 0.2;
                            pointLight.distance = 10;
                        }
                    }
                }
            });
        }

        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        // 都市の地面を作成
        const floorSize = 5000; // 床のサイズを2500から2.0倍の5000に拡大
        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x336633, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5; // 床の位置を下げる
        scene.add(floor);
        
        // 舗装された道路の幅
        const roadWidth = 16; // 道路の幅を元に戻す
        
        // リッジレーサー風の上級コース定義（すべて地上・閉ループ化）
        const trackPoints = [
            // 新しいトラックポイント（x, 高度, z）- 2.0倍に拡大、高さは2倍
            [200 * 2.0, 0, 350 * 2.0],      // 4,7,0
            [50 * 2.0, 0, 350 * 2.0],       // 1,7,0
            [0 * 2.0, 1 * 2, 250 * 2.0],    // 0,5,1
            [25 * 2.0, 2 * 2, 200 * 2.0],   // 0.5,4,2
            [60 * 2.0, 2 * 2, 215 * 2.0],   // 1.2,4.3,2
            [125 * 2.0, 2 * 2, 140 * 2.0],  // 2.5,2.8,2
            [100 * 2.0, 5 * 2, 50 * 2.0],   // 2,1,3
            [135 * 2.0, 3 * 2, 0 * 2.0],    // 2.7,0,2.5
            [200 * 2.0, 0, 50 * 2.0],       // 4,1,0
            [220 * 2.0, 0, 40 * 2.0],       // 4.4,0.8,0
            [295 * 2.0, 0, 90 * 2.0],       // 5.9,1.8,0
            [285 * 2.0, 1 * 2, 105 * 2.0],  // 5.7,2.1,1
            [210 * 2.0, 1 * 2, 110 * 2.0],  // 4.2,2.2,1
            [185 * 2.0, 2 * 2, 145 * 2.0],  // 3.7,2.9,2
            [150 * 2.0, 2 * 2, 235 * 2.0],  // 3,4.7,2
            [170 * 2.0, 1 * 2, 275 * 2.0],  // 3.4,5.5,1
            [220 * 2.0, 1 * 2, 275 * 2.0],  // 4.4,5.5,1
            [270 * 2.0, 2 * 2, 225 * 2.0],  // 5.4,4.5,2
            [285 * 2.0, 2 * 2, 180 * 2.0],  // 5.7,3.6,2
            [365 * 2.0, 1 * 2, 150 * 2.0],  // 7.3,3,1
            [400 * 2.0, 1 * 2, 165 * 2.0],  // 8,3.3,1
            [475 * 2.0, 2 * 2, 175 * 2.0],  // 9.5,3.5,2
            [450 * 2.0, 1 * 2, 250 * 2.0],  // 9,5,1
            [395 * 2.0, 1 * 2, 285 * 2.0],  // 7.9,5.7,1
            [350 * 2.0, 1 * 2, 265 * 2.0],  // 7,5.3,1
            [300 * 2.0, 0, 275 * 2.0],      // 6,5.5,0
            [245 * 2.0, 0, 350 * 2.0],      // 4.9,7,0
            [200 * 2.0, 0, 350 * 2.0]       // 4,7,0
        ];
        
        // 道路を作成
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);
        
        // 3Dパスポイントに変換
        const carPathPoints = [];
        for (let i = 0; i < trackPoints.length; i++) {
            // 高さ情報（Y軸）を考慮したポイントを作成
            carPathPoints.push(new THREE.Vector3(trackPoints[i][0], trackPoints[i][1] + 0.3, trackPoints[i][2]));
        }
        
        // カトマル・ロムスプラインで滑らかな曲線を作成
        const carPath = new THREE.CatmullRomCurve3(carPathPoints);
        carPath.closed = true; // 閉じたループに戻す
        
        // パスの詳細なポイントを取得（道路生成用）
        const detailedPathPoints = carPath.getPoints(500);
        
        // アスファルト部分を作成
        function createRoadSurface() {
            // 道路の左右のエッジを計算
            const leftEdgePoints = [];
            const rightEdgePoints = [];
            
            for (let i = 0; i < detailedPathPoints.length; i++) {
                const point = detailedPathPoints[i];
                const nextPoint = detailedPathPoints[(i + 1) % detailedPathPoints.length];
                
                // 進行方向ベクトルを計算
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                
                // 上向きベクトル（法線）を計算
                // 高さの変化を考慮した法線ベクトルを計算する（地形に沿った道路）
                const up = new THREE.Vector3(0, 1, 0);
                
                // 右向きベクトル（進行方向と上向きの外積）
                const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                
                // 修正した上向きベクトル（進行方向と右向きの外積）
                const correctedUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                
                // 道路の左右のエッジを計算（修正した法線ベクトルを使用）
                const leftEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(roadWidth / 2));
                const rightEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(-roadWidth / 2));
                
                // 高さを維持（道路面の高さは既にdetailedPathPointsに含まれる）
                // 道路を少し浮かせる（0.05）
                leftEdge.y += 0.05;
                rightEdge.y += 0.05;
                
                leftEdgePoints.push(leftEdge);
                rightEdgePoints.push(rightEdge);
            }
            
            // 道路の表面を三角形メッシュで作成
            const roadGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // すべてのポイントを頂点配列に追加
            for (let i = 0; i < leftEdgePoints.length; i++) {
                vertices.push(leftEdgePoints[i].x, leftEdgePoints[i].y, leftEdgePoints[i].z);
                vertices.push(rightEdgePoints[i].x, rightEdgePoints[i].y, rightEdgePoints[i].z);
            }
            
            // 三角形インデックスを作成
            for (let i = 0; i < leftEdgePoints.length - 1; i++) {
                const v0 = i * 2;
                const v1 = v0 + 1;
                const v2 = v0 + 2;
                const v3 = v0 + 3;
                
                // 2つの三角形で四角形を作成
                indices.push(v0, v1, v2);
                indices.push(v2, v1, v3);
            }
            
            // 最後の部分を閉じる
            const v0 = (leftEdgePoints.length - 1) * 2;
            const v1 = v0 + 1;
            const v2 = 0;
            const v3 = 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
            
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            roadGeometry.setIndex(indices);
            roadGeometry.computeVertexNormals();
            
            const roadMaterial = new THREE.MeshLambertMaterial({
                color: 0x777777, // 0x333333から0x777777に変更して道路を薄く（明るく）する
                side: THREE.DoubleSide
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadGroup.add(roadMesh);
            
            // 白線（実線）を作成 - 削除
            // createRoadLine(detailedPathPoints, 0.05, 0xFFFFFF);
            
            // 縁石を作成（コーナー部分） - 削除
            // createCurbstones();
            
            return roadMesh;
        }
        
        // 道路の白線を作成
        function createRoadLine(pathPoints, lineWidth, color) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.y = 0.1; // 道路の上に浮かせる
            roadGroup.add(line);
            
            return line;
        }
        
        // 縁石を作成（コーナー部分）
        function createCurbstones() {
            // コーナーの位置（パスの割合）
            const cornerPositions = [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.85];
            
            for (let i = 0; i < cornerPositions.length; i++) {
                const t = cornerPositions[i];
                const cornerLength = 0.05; // コーナーの長さ（パスの割合）
                
                for (let j = 0; j < 10; j++) {
                    const segmentT = t + (j * cornerLength / 10);
                    const point = carPath.getPointAt(segmentT);
                    const tangent = carPath.getTangentAt(segmentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (segmentT + 0.005) % 1;
                    const prevT = (segmentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // 縁石の位置（道路の外側）
                    const curbPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(roadWidth / 2)
                    );
                    
                    // 前後方向の傾斜角を計算（Y軸方向の変化から）
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // 赤白の縁石（交互）
                    const color = j % 2 === 0 ? 0xff0000 : 0xffffff;
                    
                    const curbGeometry = new THREE.BoxGeometry(1, 0.3, 1);
                    const curbMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                    
                    // 縁石の位置を道路の高さに合わせる
                    curb.position.copy(curbPosition);
                    curb.position.y = point.y + 0.1; // 道路面より少し浮かせる
                    
                    // 進行方向を向くように回転
                    const lookAtPos = new THREE.Vector3().addVectors(
                        curbPosition,
                        tangent
                    );
                    curb.lookAt(lookAtPos);
                    
                    // 上下の傾斜に合わせて追加の回転
                    curb.rotateX(slope);
                    
                    roadGroup.add(curb);
                }
            }
        }
        
        // ガードレールを作成（コース全体の外側）
        function createGuardrails() {
            // ガードレールの間隔（パスの割合）
            const railSpacing = 0.005; // より密に配置
            const postSpacing = 0.025; // 支柱の間隔
            
            // ガードレール用のグループを作成
            const guardrailGroup = new THREE.Group();
            roadGroup.add(guardrailGroup);
            
            // 道路の両側にガードレールを設置
            createSideGuardrail(1); // 右側
            createSideGuardrail(-1); // 左側
            
            // 特定の側（右側または左側）にガードレールを作成する関数
            function createSideGuardrail(side) {
                // 連続したガードレールのセグメントを格納する配列
                const railSegments = [];
                const railPosts = [];
                
                // ガードレール用の頂点とインデックスを収集
                const railVertices = [];
                const railIndices = [];
                const railUvs = [];
                
                let vertexIndex = 0;
                let currentT = 0;
                
                // ガードレールの頂点データを生成
                while (currentT < 1) {
                    const point = carPath.getPointAt(currentT);
                    const tangent = carPath.getTangentAt(currentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (currentT + 0.005) % 1;
                    const prevT = (currentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ガードレールの位置（道路の外側、side=1で右側、side=-1で左側）
                    const railPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(side * (roadWidth / 2 + 1.2))
                    );
                    
                    // 前後方向の傾斜角を計算
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // ガードレールの高さ調整
                    const railHeight = point.y + 0.8; // 道路面から少し高く
                    
                    // ガードレールの上部と下部の頂点を追加
                    const topRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight + 0.4, // 上部の高さ
                        railPosition.z
                    );
                    
                    const bottomRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight, // 下部の高さ
                        railPosition.z
                    );
                    
                    // 支柱を作成（一定間隔ごと）
                    if (Math.abs(currentT % postSpacing) < railSpacing) {
                        const postGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6);
                        const postMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        
                        // 支柱の位置を設定
                        post.position.copy(new THREE.Vector3(
                            railPosition.x,
                            point.y + 0.5, // 地面からの高さ
                            railPosition.z
                        ));
                        
                        // 支柱を少し内側に傾ける
                        const postLookAt = new THREE.Vector3().addVectors(
                            post.position,
                            normal.clone().multiplyScalar(-0.1 * side) // 内側に少し傾ける
                        );
                        post.lookAt(postLookAt);
                        post.rotateX(Math.PI / 2); // 支柱の向きを修正
                        
                        // 上下の傾斜に合わせて追加の回転
                        post.rotateZ(slope); // X軸ではなくZ軸で回転（支柱の向きが変わっているため）
                        
                        guardrailGroup.add(post);
                        railPosts.push(post);
                    }
                    
                    // 頂点データを追加
                    railVertices.push(
                        topRailPos.x, topRailPos.y, topRailPos.z,
                        bottomRailPos.x, bottomRailPos.y, bottomRailPos.z
                    );
                    
                    // テクスチャ座標を追加
                    railUvs.push(
                        currentT * 20, 0, // 上部のUV座標
                        currentT * 20, 1  // 下部のUV座標
                    );
                    
                    // インデックスを追加（四角形を作成）
                    if (vertexIndex > 0) {
                        // 各セグメント間を三角形で接続
                        railIndices.push(
                            vertexIndex * 2 - 2, vertexIndex * 2, vertexIndex * 2 - 1, // 最初の三角形
                            vertexIndex * 2 - 1, vertexIndex * 2, vertexIndex * 2 + 1  // 二番目の三角形
                        );
                    }
                    
                    vertexIndex++;
                    currentT += railSpacing;
                }
                
                // 最後のセグメントを最初のセグメントと接続して閉じる
                railIndices.push(
                    (vertexIndex - 1) * 2, 0, (vertexIndex - 1) * 2 + 1, // 最初の三角形
                    (vertexIndex - 1) * 2 + 1, 0, 1  // 二番目の三角形
                );
                
                // ガードレールのジオメトリを作成
                const railGeometry = new THREE.BufferGeometry();
                railGeometry.setAttribute('position', new THREE.Float32BufferAttribute(railVertices, 3));
                railGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(railUvs, 2));
                railGeometry.setIndex(railIndices);
                railGeometry.computeVertexNormals();
                
                // 高速道路のガードレールらしい素材
                const railMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE0E0E0,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // ガードレールメッシュを作成
                const railMesh = new THREE.Mesh(railGeometry, railMaterial);
                guardrailGroup.add(railMesh);
            }
        }
        
        // 道路の可視化
        createRoadSurface();
        
        // ガードレールの作成
        createGuardrails();
        
        log("道路の作成完了");
        
        // 環境オブジェクトを配置（ビルは削除して星空のみに）
        function placeEnvironmentObjects() {
            log("環境オブジェクトの配置開始");
            
            // 街灯を配置
            createStreetlights();
            
            log("環境オブジェクトの配置完了");
        }
        
        // 街灯を作成する関数
        function createStreetlights() {
            // 街灯の間隔（パスの割合）
            const streetlightSpacing = 0.04; // コース全体で約25本の街灯
            
            // 街灯用のグループを作成
            const streetlightGroup = new THREE.Group();
            roadGroup.add(streetlightGroup);
            
            // コース全体に街灯を配置
            let currentT = 0;
            while (currentT < 1) {
                // パス上の位置と接線を取得
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // 垂直方向ベクトル（外側方向）
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // 道路の右側に街灯を設置
                createSingleStreetlight(point, normal, 1); // 右側
                
                currentT += streetlightSpacing;
            }
            
            // 1本の街灯を作成する関数
            function createSingleStreetlight(point, normal, side) {
                // 街灯の位置（道路の外側）
                const lightPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 + 2.0))
                );
                
                // 街灯の支柱
                const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 8, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                
                // 支柱の位置を設定
                pole.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 4, // 地面からの高さ
                    lightPosition.z
                ));
                
                // 支柱を垂直に立てる
                pole.rotation.x = Math.PI / 2;
                
                streetlightGroup.add(pole);
                
                // 街灯の頭部
                const headGeometry = new THREE.BoxGeometry(1.0, 0.4, 0.4);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0xFFDD99,
                    emissiveIntensity: 0.1 // 初期値は低く
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // 頭部の位置を設定
                head.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // 支柱の上部
                    lightPosition.z
                ));
                
                // 頭部を道路に向ける
                head.lookAt(new THREE.Vector3(
                    point.x,
                    point.y + 8,
                    point.z
                ));
                
                // ユーザーデータに街灯フラグを設定
                head.userData.isStreetlight = true;
                
                streetlightGroup.add(head);
                
                // 街灯のライト
                const light = new THREE.PointLight(0xFFDD99, 0.2, 10, 2);
                light.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // 支柱の上部
                    lightPosition.z
                ));
                
                // ライトを街灯の頭部に関連付ける
                head.userData.pointLight = light;
                
                streetlightGroup.add(light);
            }
        }
        
        // 詳細な車のモデルを作成
        function createDetailedCar() {
            const car = new THREE.Group();
            
            // カラーバリエーション
            const carColors = [
                { name: 'レーシングレッド', body: 0xFF0000, accent: 0x111111 },
                { name: 'クラシックブルー', body: 0x0066CC, accent: 0x111111 },
                { name: 'イエロー', body: 0xFFCC00, accent: 0x111111 },
                { name: 'ブリティッシュグリーン', body: 0x006633, accent: 0x111111 },
                { name: 'パールホワイト', body: 0xFFFFFF, accent: 0x111111 }
            ];
            
            // ランダムにカラーを選択
            const selectedColor = carColors[Math.floor(Math.random() * carColors.length)];
            log(`選択されたカラー: ${selectedColor.name}`);
            
            // 車体ベース（レーシングカー風の低く、幅広いデザイン）
            const carBodyGeometry = new THREE.BoxGeometry(2.4, 0.3, 4.8);
            const carBodyMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body }); // 選択されたカラー
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.55;
            car.add(carBody);

            // フロントノーズ（先端が低く、シャープな形状）
            const noseGeometry = new THREE.BoxGeometry(1.8, 0.2, 1.0);
            const noseMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 0.45, -2.2);
            car.add(nose);
            
            // フロントウイング
            const frontWingGeometry = new THREE.BoxGeometry(2.2, 0.1, 0.4);
            const frontWingMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const frontWing = new THREE.Mesh(frontWingGeometry, frontWingMaterial);
            frontWing.position.set(0, 0.35, -2.4);
            car.add(frontWing);

            // フロントウイングエンドプレート（左）
            const frontWingEndPlateLeftGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.6);
            const frontWingEndPlateLeft = new THREE.Mesh(frontWingEndPlateLeftGeometry, frontWingMaterial);
            frontWingEndPlateLeft.position.set(-1.1, 0.4, -2.4);
            car.add(frontWingEndPlateLeft);

            // フロントウイングエンドプレート（右）
            const frontWingEndPlateRight = frontWingEndPlateLeft.clone();
            frontWingEndPlateRight.position.set(1.1, 0.4, -2.4);
            car.add(frontWingEndPlateRight);
            
            // サイドポンツーン（左）
            const sidePodGeometry = new THREE.BoxGeometry(0.4, 0.3, 2.0);
            const sidePodMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const leftSidePod = new THREE.Mesh(sidePodGeometry, sidePodMaterial);
            leftSidePod.position.set(-1.0, 0.5, 0.2);
            car.add(leftSidePod);

            // サイドポンツーン（右）
            const rightSidePod = leftSidePod.clone();
            rightSidePod.position.set(1.0, 0.5, 0.2);
            car.add(rightSidePod);

            // エアボックス（エンジン上部の空気取り入れ口）
            const airboxGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.8);
            const airboxMaterial = new THREE.MeshLambertMaterial({ color: selectedColor.body });
            const airbox = new THREE.Mesh(airboxGeometry, airboxMaterial);
            airbox.position.set(0, 1.0, 0.8);
            car.add(airbox);

            // リアウイング本体（より薄く、幅広に）
            const rearWingGeometry = new THREE.BoxGeometry(2.2, 0.08, 0.6);
            const rearWingMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const rearWing = new THREE.Mesh(rearWingGeometry, rearWingMaterial);
            rearWing.position.set(0, 1.2, 2.2);
            car.add(rearWing);

            // リアウイングエンドプレート（左）
            const wingEndPlateGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.8);
            const leftWingEndPlate = new THREE.Mesh(wingEndPlateGeometry, rearWingMaterial);
            leftWingEndPlate.position.set(-1.1, 1.2, 2.2);
            car.add(leftWingEndPlate);

            // リアウイングエンドプレート（右）
            const rightWingEndPlate = leftWingEndPlate.clone();
            rightWingEndPlate.position.set(1.1, 1.2, 2.2);
            car.add(rightWingEndPlate);

            // リアウイングサポート（左）
            const wingPillarGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            const wingPillarMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const leftWingPillar = new THREE.Mesh(wingPillarGeometry, wingPillarMaterial);
            leftWingPillar.position.set(-0.8, 1.0, 2.2);
            car.add(leftWingPillar);

            // リアウイングサポート（右）
            const rightWingPillar = leftWingPillar.clone();
            rightWingPillar.position.set(0.8, 1.0, 2.2);
            car.add(rightWingPillar);

            // レーシングナンバー（3）- 左側
            const leftNumberGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const leftNumberMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });
            const leftNumber = new THREE.Mesh(leftNumberGeometry, leftNumberMaterial);
            leftNumber.position.set(-1.21, 0.85, 0);
            leftNumber.rotation.y = Math.PI / 2;
            car.add(leftNumber);

            // レーシングナンバー（3）- 右側
            const rightNumber = leftNumber.clone();
            rightNumber.position.set(1.21, 0.85, 0);
            rightNumber.rotation.y = -Math.PI / 2;
            car.add(rightNumber);

            // NAMCOロゴ - 左側
            const leftLogoGeometry = new THREE.PlaneGeometry(1.2, 0.3);
            const leftLogoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9
            });
            const leftLogo = new THREE.Mesh(leftLogoGeometry, leftLogoMaterial);
            leftLogo.position.set(-1.21, 1.0, -0.5);
            leftLogo.rotation.y = Math.PI / 2;
            car.add(leftLogo);

            // NAMCOロゴ - 右側
            const rightLogo = leftLogo.clone();
            rightLogo.position.set(1.21, 1.0, -0.5);
            rightLogo.rotation.y = -Math.PI / 2;
            car.add(rightLogo);
            
            // フロントガラス（レーシング風に低く）
            const windshieldGeometry = new THREE.BoxGeometry(1.4, 0.25, 1.0);
            const windshieldMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.7
            });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 0.9, -0.4);
            windshield.rotation.x = Math.PI * 0.06;
            car.add(windshield);

            // ヘッドレスト
            const headrestGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.3);
            const headrestMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const headrest = new THREE.Mesh(headrestGeometry, headrestMaterial);
            headrest.position.set(0, 0.9, 0.4);
            car.add(headrest);

            // リアディフューザー
            const diffuserGeometry = new THREE.BoxGeometry(2.0, 0.15, 0.6);
            const diffuserMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const diffuser = new THREE.Mesh(diffuserGeometry, diffuserMaterial);
            diffuser.position.set(0, 0.35, 2.3);
            car.add(diffuser);

            // ヘッドライト（レーシング風の小型ライト）
            const headlightGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.1);
            const headlightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 1.0
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(0.7, 0.65, -2.35);
            car.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(-0.7, 0.65, -2.35);
            car.add(rightHeadlight);
            
            // ヘッドライトのスポットライト
            leftHeadlightLight = new THREE.SpotLight(0xFFFFFF, 1.5, 50, Math.PI / 6, 0.3, 1);
            leftHeadlightLight.position.set(0.6, 2.0, -2.0);
            leftHeadlightLight.target.position.set(0.3, 0.0, -20);
            leftHeadlightLight.visible = false;
            car.add(leftHeadlightLight);
            car.add(leftHeadlightLight.target);
            
            rightHeadlightLight = new THREE.SpotLight(0xFFFFFF, 1.5, 50, Math.PI / 6, 0.3, 1);
            rightHeadlightLight.position.set(-0.6, 2.0, -2.0);
            rightHeadlightLight.target.position.set(-0.3, 0.0, -20);
            rightHeadlightLight.visible = false;
            car.add(rightHeadlightLight);
            car.add(rightHeadlightLight.target);

            // テールライト（レーシング風の細長いデザイン）
            const taillightGeometry = new THREE.BoxGeometry(1.0, 0.1, 0.1);
            const taillightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            
            const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillight.position.set(0, 0.85, 2.35);
            car.add(taillight);
            
            // サイドエアインテーク（レーシングカー風）
            const intakeGeometry = new THREE.BoxGeometry(0.1, 0.4, 1.2);
            const intakeMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            
            const leftIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
            leftIntake.position.set(1.15, 0.75, 0.5);
            car.add(leftIntake);
            
            const rightIntake = new THREE.Mesh(intakeGeometry, intakeMaterial);
            rightIntake.position.set(-1.15, 0.75, 0.5);
            car.add(rightIntake);
            
            // タイヤを作成する関数（レーシングホイール）
            function createWheel(x, z) {
                const wheelGroup = new THREE.Group();
                
                // タイヤ本体（ワイドタイヤ）
                const wheelGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 16);
                const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheelGroup.add(wheel);
                
                // レーシングホイール
                const hubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.41, 12);
                const hubMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                hub.rotation.z = Math.PI / 2;
                wheelGroup.add(hub);
                
                // センターロック風のキャップ
                const capGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.42, 6);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.rotation.z = Math.PI / 2;
                wheelGroup.add(cap);
                
                // レーシングスポーク
                for (let i = 0; i < 6; i++) {
                    const spokeGeometry = new THREE.BoxGeometry(0.04, 0.02, 0.35);
                    const spokeMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.x = (Math.PI * 2 / 6) * i;
                    spoke.position.y = 0;
                    wheelGroup.add(spoke);
                }
                
                wheelGroup.position.set(x, 0.4, z);
                car.add(wheelGroup);
                
                return { wheel, wheelGroup };
            }
            
            // 4つのタイヤを作成（ワイドトレッド）
            const frontLeftWheel = createWheel(-1.1, -1.7);
            const frontRightWheel = createWheel(1.1, -1.7);
            const rearLeftWheel = createWheel(-1.1, 1.7);
            const rearRightWheel = createWheel(1.1, 1.7);
            
            const wheels = [
                frontLeftWheel.wheel,
                frontRightWheel.wheel,
                rearLeftWheel.wheel,
                rearRightWheel.wheel
            ];
            
            const wheelGroups = [
                frontLeftWheel.wheelGroup,
                frontRightWheel.wheelGroup,
                rearLeftWheel.wheelGroup,
                rearRightWheel.wheelGroup
            ];
            
            // 車の向きベクトル（常に上方向）
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // 車の初期位置（スタート地点）
            car.position.copy(carPath.getPointAt(0));
            car.position.y = 1.0; // 地面からの高さ
            
            // 車の初期方向
            const initialTangent = carPath.getTangentAt(0);
            const initialDirection = new THREE.Vector3(initialTangent.x, 0, initialTangent.z).normalize();
            
            // 車の向きを設定（Y軸は常に上）
            const initialTarget = new THREE.Vector3().addVectors(car.position, initialDirection);
            car.lookAt(initialTarget);
            
            scene.add(car);
            
            return { car, wheels, wheelGroups, upVector };
        }
        
        const { car, wheels, wheelGroups, upVector } = createDetailedCar();
        
        log("車の作成完了");
        
        // カメラモード（0: 俯瞰, 1: 追従, 2: 車載, 3: 斜め視点）
        let cameraMode = 3; // デフォルトを斜め視点モードに設定
        
        // カメラ位置の初期設定（斜め視点向け）
        camera.position.set(100, 70, 90); // 斜め視点の初期位置
        camera.lookAt(car.position);
        
        // 車の位置パラメータ
        let carPosition = 0; // パス上の位置（0から1）
        let carSpeed = 0.3;  // 車の速度（1分周回に調整）
        let targetSpeed = 0.3; // 目標速度（1分周回に調整）
        
        // 速度の範囲を設定（コース1周約1分になるよう調整）
        const MIN_SPEED = 0.25; // 最低速度
        const MAX_SPEED = 0.6; // 最高速度
        const ACCELERATION_RATE = 0.01; // 加速率を上げる（0.008から0.01に）
        const DECELERATION_RATE = 0.02; // 減速率も上げる（0.015から0.02に）
        
        // 前回の位置と回転を保存（スムージング用）
        let lastCarPosition = new THREE.Vector3();
        let lastCarRotation = new THREE.Quaternion();
        let lastCarUp = new THREE.Vector3(0, 1, 0);
        // 前回の傾き角度を保存（滑らかな変化のため）
        let lastTiltAngle = 0;
        
        // 初期位置設定
        lastCarPosition.copy(car.position);
        lastCarRotation.copy(car.quaternion);
        
        // カメラ切り替え
        window.addEventListener('keydown', (e) => {
            if (e.key === '1' || e.key === '１') {
                cameraMode = 0; // 俯瞰
                log("カメラモード: 俯瞰");
            } else if (e.key === '2' || e.key === '２') {
                cameraMode = 1; // 追従
                log("カメラモード: 追従");
            } else if (e.key === '3' || e.key === '３') {
                cameraMode = 2; // 車載
                log("カメラモード: 車載");
            } else if (e.key === '4' || e.key === '４') {
                cameraMode = 4; // 車前方
                log("カメラモード: 車前方");
            } else if (e.key === '5' || e.key === '５') {
                cameraMode = 3; // 斜め上視点
                log("カメラモード: 斜め上視点");
            }
        });
        
        // 多点サンプリングで曲率を計算（より安定した値を得るため）
        function calculateCurvature(t, samplePoints = 15, sampleDistance = 0.005) {
            const angles = [];
            
            // 複数のサンプル点で角度を計算し平均を取る
            for (let i = 0; i < samplePoints - 1; i++) {
                const currentPos = (t + i * sampleDistance) % 1;
                const nextPos = (currentPos + sampleDistance) % 1;
                const nextNextPos = (nextPos + sampleDistance) % 1;
                
                const point = carPath.getPointAt(currentPos);
                const nextPoint = carPath.getPointAt(nextPos);
                const nextNextPoint = carPath.getPointAt(nextNextPos);
                
                const v1 = new THREE.Vector2(nextPoint.x - point.x, nextPoint.z - point.z).normalize();
                const v2 = new THREE.Vector2(nextNextPoint.x - nextPoint.x, nextNextPoint.z - nextPoint.z).normalize();
                
                // 2つのベクトル間の角度
                const angle = Math.acos(Math.min(1, Math.max(-1, v1.dot(v2))));
                angles.push(angle);
            }
            
            // 角度の平均値を計算
            const avgAngle = angles.reduce((sum, angle) => sum + angle, 0) / angles.length;
            
            // 曲がる方向の判定（中央のサンプルポイントで判定）
            const middleIndex = Math.floor(samplePoints / 2);
            const currentPos = (t + middleIndex * sampleDistance) % 1;
            const nextPos = (currentPos + sampleDistance) % 1;
            const nextNextPos = (nextPos + sampleDistance) % 1;
            
            const pointStart = carPath.getPointAt(currentPos);
            const pointNext = carPath.getPointAt(nextPos);
            const pointNextNext = carPath.getPointAt(nextNextPos);
            
            const vec1 = new THREE.Vector2(pointNext.x - pointStart.x, pointNext.z - pointStart.z).normalize();
            const vec2 = new THREE.Vector2(pointNextNext.x - pointNext.x, pointNextNext.z - pointNext.z).normalize();
            
            // 曲がり方向を判定（外積）
            const crossProduct = vec1.x * vec2.y - vec1.y * vec2.x;
            const tiltDirection = Math.sign(crossProduct);
            
            return { angle: avgAngle, direction: tiltDirection };
        }
        
        // 前方のカーブを予測する関数
        function predictUpcomingCurve(currentPosition, lookAheadDistance = 0.05) {
            // 現在の位置から少し先の位置でのカーブ強度を取得
            const upcomingPos = (currentPosition + lookAheadDistance) % 1;
            const curvatureData = calculateCurvature(upcomingPos);
            return curvatureData.angle;
        }
        
        // 速度を更新する関数（スローインファーストアウト）
        function updateSpeed() {
            // 現在のカーブ強度を取得
            const currentCurvature = calculateCurvature(carPosition).angle;
            
            // 前方のカーブ強度を予測
            const upcomingCurvature = predictUpcomingCurve(carPosition, 0.05);
            
            // カーブ強度に基づいて目標速度を計算
            // 曲率が大きいほど速度を下げる
            const curvatureThreshold = 0.03; // カーブ検出の閾値（少し下げてより早くカーブを検知）
            
            if (upcomingCurvature > curvatureThreshold) {
                // カーブが近づいている場合（スローイン）
                // カーブ強度に応じて目標速度を下げる
                const curveFactor = Math.min(1, upcomingCurvature / 0.08); // カーブ強度を0-1の範囲に正規化（値を小さくしてより敏感に）
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7); // べき乗を使って急激な減速を実現
            } else if (currentCurvature > curvatureThreshold / 2) {
                // カーブ中の場合
                const curveFactor = Math.min(1, currentCurvature / 0.08);
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7);
            } else {
                // カーブを抜けた場合（ファーストアウト）
                targetSpeed = MAX_SPEED;
            }
            
            // 下り坂では少し加速、上り坂では少し減速
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const point = carPath.getPointAt(carPosition);
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // 傾斜を計算
            const slope = Math.atan2(nextPoint.y - prevPoint.y, 
                Math.sqrt(Math.pow(nextPoint.x - prevPoint.x, 2) + Math.pow(nextPoint.z - prevPoint.z, 2)));
            
            // 傾斜に応じて速度を調整（下り坂で加速、上り坂で減速）
            if (slope < -0.01) {
                // 下り坂
                targetSpeed *= (1.0 - slope); // 傾斜が大きいほど加速
            } else if (slope > 0.01) {
                // 上り坂
                targetSpeed *= (1.0 - slope * 0.5); // 傾斜が大きいほど減速
            }
            
            // 現在の速度を目標速度に徐々に近づける（加速・減速）
            if (carSpeed < targetSpeed) {
                // 加速（ゆっくり）
                carSpeed = Math.min(targetSpeed, carSpeed + ACCELERATION_RATE);
            } else if (carSpeed > targetSpeed) {
                // 減速（素早く）
                carSpeed = Math.max(targetSpeed, carSpeed - DECELERATION_RATE);
            }
        }
        
        // 前フレームと現在フレームの値を補間する関数
        function smoothValue(current, last, factor) {
            return last * (1 - factor) + current * factor;
        }
        
        // より滑らかなEasing補間を行う関数（2次のベジェ曲線に基づくなめらかな補間）
        function smootherValue(target, current, speed, deltaTime = 1) {
            // デフォルトのデルタタイムは1フレーム分（60fpsを想定）
            const delta = (target - current);
            
            // 非常に小さな変化は無視する（ノイズによる微小変動を防止）
            if (Math.abs(delta) < 0.001) {
                return current;
            }
            
            // より自然な動きのために3次のベジェ曲線のイージングを適用
            // これにより、目標値に近づくほど徐々に減速する効果が得られる
            const easeFactor = Math.min(1.0, speed * deltaTime);
            
            // 改良されたスムーズステップ関数（より高次の関数で滑らかさを向上）
            const t = Math.max(0, Math.min(1, easeFactor));
            const easeFactorCubic = t * t * (3 - 2 * t);
            const easeFactorQuintic = t * t * t * (t * (t * 6 - 15) + 10); // より滑らかな5次関数
            
            // 二つの関数をブレンド（大きな変化には5次関数、小さな変化には3次関数を適用）
            const blendFactor = Math.min(1.0, Math.abs(delta) / 0.5);
            const finalEaseFactor = easeFactorCubic * (1 - blendFactor) + easeFactorQuintic * blendFactor;
            
            return current + delta * finalEaseFactor;
        }
        
        // 過去フレームの時間を記録する変数
        let lastFrameTime = Date.now();
        
        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            
            // フレーム間のデルタタイムを計算
            currentFrameTime = Date.now(); // グローバル変数を更新
            const deltaTime = (currentFrameTime - lastFrameTime) / 16.67; // 60fpsを基準にした値
            lastFrameTime = currentFrameTime;
            
            // 時間の更新と昼夜サイクルの適用
            updateDayNightCycle();
            
            // 天気の更新
            updateWeather(deltaTime);
            
            // 速度を更新（カーブに応じて）
            updateSpeed();
            
            // 車の位置を更新
            carPosition += carSpeed * 0.001;
            if (carPosition >= 1) carPosition -= 1;
            
            // 道路上の位置を厳密に取得
            const point = carPath.getPointAt(carPosition);
            
            // パスの接線ベクトルを取得（進行方向）
            const tangent = carPath.getTangentAt(carPosition).normalize();
            // XZ平面上の接線ベクトル（高さを無視）
            const flatTangent = new THREE.Vector3(tangent.x, 0, tangent.z).normalize();
            
            // 次のポイントと前のポイントを取得して傾斜を計算（上り下りの計算用）
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // 前後方向の傾斜角を計算（Y軸方向の変化から）
            const forwardSlope = Math.atan2(nextPoint.y - point.y, 
                Math.sqrt(Math.pow(nextPoint.x - point.x, 2) + Math.pow(nextPoint.z - point.z, 2)));
            
            // サンプリング範囲を拡大して、より正確な傾斜を取得
            // 少し広い範囲で前後の傾斜を計算してより安定させる
            const farNextPos = (carPosition + 0.02) % 1;
            const farPrevPos = (carPosition - 0.02 + 1) % 1;
            const farNextPoint = carPath.getPointAt(farNextPos);
            const farPrevPoint = carPath.getPointAt(farPrevPos);
            
            // 広い範囲での前後方向の傾斜角を計算（急な坂での対応向上）
            const farForwardSlope = Math.atan2(farNextPoint.y - farPrevPoint.y, 
                Math.sqrt(Math.pow(farNextPoint.x - farPrevPoint.x, 2) + Math.pow(farNextPoint.z - farPrevPoint.z, 2)));
            
            // 近距離と遠距離の傾斜を組み合わせて、より安定した傾斜値を得る
            const combinedSlope = (forwardSlope * 0.7 + farForwardSlope * 0.3);
            
            // 曲率を計算
            const curvatureData = calculateCurvature(carPosition);
            const curveAngle = curvatureData.angle;
            const curveTiltDirection = curvatureData.direction;
            
            // ノイズフィルタリング - 非常に小さな曲率変化を無視
            // これにより、わずかな道路の揺れなどによる不要な反応を防止
            const minCurvatureThreshold = 0.005; // 最小閾値以下は真っ直ぐとみなす
            const filteredCurveAngle = Math.abs(curveAngle) < minCurvatureThreshold ? 0 : curveAngle;
            const filteredDirection = filteredCurveAngle === 0 ? 0 : curveTiltDirection;
            
            // 車の高さは道路の高さに合わせる
            const carHeight = point.y + 0.3; // 道路の高さに対して少しオフセット
            
            // スピードファクターを先に計算（他の場所で使用するため）
            const speedFactor = Math.min(1.0, carSpeed / 0.7); // 速度による調整係数
            
            // ---------- 車の回転方向の計算（先に行う） ----------
            
            // 1. 進行方向ベクトル（常にXZ平面に平行）
            const forwardVector = flatTangent;
            
            // 2. 上向きベクトル（常に世界座標のY軸方向）
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // 3. 右向きベクトル（進行方向と上向きの外積）
            const rightVector = new THREE.Vector3().crossVectors(forwardVector, upVector).normalize();
            
            // 4. 最終的な上向きベクトル（右向きと進行方向の外積で再計算、厳密に直交させる）
            const correctedUpVector = new THREE.Vector3().crossVectors(rightVector, forwardVector).normalize();
            
            // ---------- アウトインアウト走法のための詳細な路線計算 ----------
            
            // 道路の幅に応じてオフセット量を調整（より大きなオフセットに調整）
            const pathOffsetAmount = 4.0; // 元の値に戻す
            
            // 曲率をより正確に計算するためのパラメータ
            const detailedSamplePoints = 20;
            const detailedSampleDistance = 0.004;
            
            // コーナー検出のための複数のポイントをサンプリング
            const lookAheadDistances = [0.15, 0.1, 0.05, 0.03];
            const lookBehindDistances = [0.05, 0.02];
            
            // 各距離でのカーブデータを取得（フィルタリングを適用）
            const filteredAheadCurveData = lookAheadDistances.map(dist => {
                const data = calculateCurvature((carPosition + dist) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            const filteredBehindCurveData = lookBehindDistances.map(dist => {
                const data = calculateCurvature((carPosition - dist + 1) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            // フィルタリングされた曲率を使用
            const filteredAheadAngles = filteredAheadCurveData.map(data => data.angle);
            const filteredBehindAngles = filteredBehindCurveData.map(data => data.angle);
            
            // 最大の曲率とその方向を特定
            const maxAheadAngle = Math.max(...filteredAheadAngles);
            const maxAheadIndex = filteredAheadAngles.indexOf(maxAheadAngle);
            const maxAheadDirection = filteredAheadCurveData[maxAheadIndex].direction;
            
            const maxBehindAngle = Math.max(...filteredBehindAngles);
            const maxBehindIndex = filteredBehindAngles.indexOf(maxBehindAngle);
            const maxBehindDirection = filteredBehindCurveData[maxBehindIndex].direction;
            
            // オフセット計算用の変数の初期化
            if (typeof lastPathOffset === 'undefined') {
                window.lastPathOffset = 0;
                window.lastCornerState = 'straight';
                window.cornerState = 'straight';
                window.stateChangeTime = 0;
                window.cornerHistory = []; 
                window.targetPathOffset = 0;
                window.cornerDetectionHistory = [];
                window.directionHistory = [];
                window.intermediateOffset = 0;
            }
            
            // 現在の曲率を履歴に追加（最新の30サンプルを保持）
            if (!Array.isArray(window.cornerHistory)) {
                window.cornerHistory = [];
            }
            window.cornerHistory.push(filteredCurveAngle);
            if (window.cornerHistory.length > 30) {
                window.cornerHistory.shift();
            }
            
            // 曲率履歴の平均を計算（ノイズを除去）- 重み付き平均を導入して最新の値をより重視
            let totalWeight = 0;
            let weightedSum = 0;
            for (let i = 0; i < window.cornerHistory.length; i++) {
                // 新しいデータほど重みを大きくする（最新のデータが最も重要）
                const weight = Math.pow(1.1, i);
                weightedSum += window.cornerHistory[window.cornerHistory.length - 1 - i] * weight;
                totalWeight += weight;
            }
            const avgCurveAngle = weightedSum / totalWeight;
            
            // 方向の一貫性確認のため、方向履歴も保持
            if (!Array.isArray(window.directionHistory)) {
                window.directionHistory = [];
            }
            window.directionHistory.push(filteredDirection); // フィルタリングされた方向を使用
            if (window.directionHistory.length > 20) {
                window.directionHistory.shift();
            }
            
            // 方向の多数決を取る（最頻値を採用）
            const directionCounts = {};
            let maxCount = 0;
            let dominantDirection = 0;
            
            window.directionHistory.forEach(dir => {
                directionCounts[dir] = (directionCounts[dir] || 0) + 1;
                if (directionCounts[dir] > maxCount) {
                    maxCount = directionCounts[dir];
                    dominantDirection = dir;
                }
            });
            
            // カーブの方向として支配的な方向を使用
            const stableCurveTiltDirection = dominantDirection;
            
            // コーナー検出用のモデルを構築
            // 各位置の曲率情報を元に、コーナーの状態を判断するための特徴量を作成
            const cornerDetectionFeatures = {
                current: avgCurveAngle,               // 現在地点の曲率（平均化済み）
                ahead: filteredAheadAngles,           // 複数の先読み地点の曲率（フィルタリング済み）
                behind: filteredBehindAngles,         // 複数の後読み地点の曲率（フィルタリング済み）
                maxAhead: maxAheadAngle,              // 最大の先読み曲率
                maxBehind: maxBehindAngle,            // 最大の後読み曲率
                direction: stableCurveTiltDirection,  // 安定化された現在の曲がり方向
                aheadDirection: maxAheadDirection,    // 先のカーブの曲がり方向
                behindDirection: maxBehindDirection,  // 後ろのカーブの曲がり方向
                speed: carSpeed                       // 現在の速度
            };
            
            // コーナー検出情報を履歴に追加（状態変更の安定性向上のため）
            if (!Array.isArray(window.cornerDetectionHistory)) {
                window.cornerDetectionHistory = [];
            }
            window.cornerDetectionHistory.push(cornerDetectionFeatures);
            if (window.cornerDetectionHistory.length > 15) {
                window.cornerDetectionHistory.shift();
            }
            
            // 曲率の急激な変化を検出するための閾値
            const curvatureThreshold = 0.015;  // 通常のカーブ検出閾値
            const entryThreshold = 0.014;      // コーナー進入検出閾値
            const apexThreshold = 0.018;       // コーナー頂点検出閾値
            const exitThreshold = 0.015;       // コーナー出口検出閾値
            const hysteresis = 0.008;          // ヒステリシス
            
            // 状態変更の時間制限（急激な状態変更を防止）- デルタタイムに応じて調整
            const baseStateChangeDuration = 800; // 基本の最小状態変更間隔（ミリ秒）
            const speedBasedDuration = baseStateChangeDuration * (1.0 + speedFactor * 0.5); // 高速時はより長い間隔
            const minStateChangeDuration = Math.min(1200, speedBasedDuration); // 最大1.2秒まで
            
            const currentTime = Date.now();
            const canChangeState = (currentTime - window.stateChangeTime) > minStateChangeDuration;
            
            // コーナー検出履歴の安定性確認（必要なフレーム数を増やして安定性向上）
            const isStableAheadCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxAhead > entryThreshold).length >= 5;
            
            const isStableCurrentCurve = window.cornerDetectionHistory.filter(
                hist => hist.current > apexThreshold).length >= 5;
            
            const isStableBehindCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxBehind > exitThreshold).length >= 5;
            
            // 連続したフレームでの同一方向性の確認（方向の一貫性をチェック）
            const aheadDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.aheadDirection === arr[i-1].aheadDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            const behindDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.behindDirection === arr[i-1].behindDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            // 方向の一貫性が高い場合のみ状態遷移を許可（方向が安定している場合のみ）
            const directionStability = Math.min(aheadDirectionConsistency, behindDirectionConsistency);
            const hasStableDirection = directionStability > 0.7;
            
            // コーナー状態の遷移判定を安定性を考慮して行う
            let newCornerState = window.cornerState;
            
            if (canChangeState && hasStableDirection) {
                // コーナー進入検出（先の安定したカーブを検出）
                if (maxAheadAngle > entryThreshold && 
                    maxAheadAngle > (avgCurveAngle + hysteresis) &&
                    maxAheadDirection !== 0 && // 方向が0でない場合のみ（有効なカーブ方向）
                    isStableAheadCurve && 
                    window.cornerState !== 'entry') {
                    
                    newCornerState = 'entry';
                    window.stateChangeTime = currentTime;
                } 
                // コーナー中間（現在地点で大きな曲率を検出）
                else if (avgCurveAngle > apexThreshold && 
                        stableCurveTiltDirection !== 0 && // 有効なカーブ方向
                        isStableCurrentCurve &&
                        window.cornerState !== 'apex' && 
                        (window.cornerState === 'entry' || maxAheadAngle > entryThreshold)) {
                    
                    newCornerState = 'apex';
                    window.stateChangeTime = currentTime;
                } 
                // コーナー出口（後方の安定したカーブを検出）
                else if (maxBehindAngle > exitThreshold && 
                        maxBehindAngle > (avgCurveAngle + hysteresis) &&
                        maxBehindDirection !== 0 && // 有効なカーブ方向
                        isStableBehindCurve &&
                        window.cornerState === 'apex') {
                    
                    newCornerState = 'exit';
                    window.stateChangeTime = currentTime;
                } 
                // 直線区間（曲率が十分に小さくなった場合）
                else if (avgCurveAngle < (curvatureThreshold - hysteresis * 2) && 
                        maxBehindAngle < (exitThreshold - hysteresis) &&
                        maxAheadAngle < (entryThreshold - hysteresis) &&
                        window.cornerState === 'exit') {
                    
                    newCornerState = 'straight';
                    window.stateChangeTime = currentTime;
                }
            }
            
            // 状態が変更された場合、前の状態を記録
            if (newCornerState !== window.cornerState) {
                window.lastCornerState = window.cornerState;
                window.cornerState = newCornerState;
                console.log("コーナー状態変更: " + window.cornerState); // デバッグ用
            }
            
            // コーナーの曲がり方向を決定（より安定した方向を使用）
            // 安定化された方向を使用
            const cornerTiltDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // 各コーナー状態に基づいて目標オフセット値を設定
            let targetOffset = 0;
            
            // コーナー状態に基づいてオフセットを計算
            switch (window.cornerState) {
                case 'entry':
                    // 進入時はアウト側から入る（より大きなオフセット）
                    targetOffset = -pathOffsetAmount * 1.5 * cornerTiltDirection;
                    // 曲率に応じてオフセット量を調整（曲率に対する感度向上）
                    targetOffset *= Math.min(1.0, Math.pow(maxAheadAngle / 0.04, 0.7));
                    break;
                    
                case 'apex':
                    // 頂点ではイン側に寄せる（より強くインを攻める）
                    targetOffset = pathOffsetAmount * 1.2 * cornerTiltDirection;
                    // 曲率に応じて調整（より強めにインを攻める）
                    targetOffset *= Math.min(1.0, Math.pow(avgCurveAngle / 0.04, 0.6));
                    break;
                    
                case 'exit':
                    // 出口では再びアウト側に大きく膨らむ
                    targetOffset = -pathOffsetAmount * 1.8 * cornerTiltDirection;
                    // 曲率に応じて調整（より敏感に反応）
                    targetOffset *= Math.min(1.0, Math.pow(maxBehindAngle / 0.04, 0.7));
                    break;
                    
                case 'straight':
                default:
                    // 直線では少し中央から外側に寄せる（より自然なドライビングライン）
                    targetOffset = 0.5 * (window.lastCornerState === 'exit' ? -cornerTiltDirection : 0);
                    break;
            }
            
            // スピードが速いほどアウトを大きく取る（高速コーナリングの挙動向上）
            const speedFactorForOffset = speedFactor * 0.7; // 速度による追加オフセット（より強調）
            targetOffset *= (1 + speedFactorForOffset);
            
            // 道路からはみ出さないようにオフセットを制限
            // 車の幅を考慮した安全マージン（車の幅の半分+余裕）
            window.carWidth = 2.5; // 車の幅の概算
            window.safetyMargin = window.carWidth / 2 + 0.5; // 安全マージン
            
            // 道路の有効幅（道路の端からの安全マージンを引いた値）
            window.effectiveRoadHalfWidth = (roadWidth / 2) - window.safetyMargin;
            
            // オフセットが道路の有効幅を超えないように制限
            targetOffset = Math.max(-window.effectiveRoadHalfWidth, Math.min(window.effectiveRoadHalfWidth, targetOffset));
            
            window.targetPathOffset = targetOffset;
            
            // 実際のオフセット値を算出（より滑らかな補間）
            // 改良されたEasing補間関数を使用して自然な動きを実現
            const baseTransitionSpeed = 0.05; // 基本トランジション速度（より小さくして安定性向上）
            const speedAdjustedTransition = baseTransitionSpeed * (1.0 - speedFactor * 0.4); // 高速時は遅い変化
            const transitionSpeed = Math.max(0.02, speedAdjustedTransition); // 最小値を設定
            
            // Easing関数による二重スムージング - 非常に滑らかな動きを実現
            // 一時的な中間値を計算してからさらにスムージング
            if (typeof window.intermediateOffset === 'undefined') {
                window.intermediateOffset = window.lastPathOffset;
            }
            
            // 二段階のスムージングで非常に滑らかな動きを実現
            window.intermediateOffset = smootherValue(window.targetPathOffset, window.intermediateOffset, transitionSpeed * 1.5, deltaTime);
            const pathOffset = smootherValue(window.intermediateOffset, window.lastPathOffset, transitionSpeed, deltaTime);
            window.lastPathOffset = pathOffset;
            
            // 道路の有効幅はすでに計算済み（window.effectiveRoadHalfWidthを使用）
            
            // 接線方向に対して垂直なオフセットベクトルを計算
            const offsetVector = rightVector.clone().multiplyScalar(pathOffset);
            
            // 道路の端に近づいているかチェック
            const edgeProximityThreshold = 0.8; // 道路端からの距離が安全マージンの何倍以下で警告するか
            const edgeProximity = Math.abs(pathOffset) / window.effectiveRoadHalfWidth;
            
            // 初回実行時に既存の警告要素を削除（警告表示機能を無効化）
            if (window.edgeWarningElement && !window.edgeWarningRemovalAttempted) {
                if (window.edgeWarningElement.parentNode) {
                    window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                }
                window.edgeWarningElement = null;
                window.edgeWarningRemovalAttempted = true;
            }
            
            // 道路端に近づいている場合、自動補正と警告
            if (edgeProximity > edgeProximityThreshold) {
                // 道路端に近いほど強く中央方向への補正力を適用
                const correctionFactor = Math.pow((edgeProximity - edgeProximityThreshold) / (1 - edgeProximityThreshold), 2) * 0.3;
                const correctionDirection = pathOffset > 0 ? -1 : 1;
                const correctionVector = rightVector.clone().multiplyScalar(correctionFactor * correctionDirection);
                
                // 補正ベクトルを追加
                offsetVector.add(correctionVector);
                
                // 警告メッセージ表示部分を削除（ユーザーリクエストにより）
            } else if (window.edgeWarningElement) {
                // 既存の警告要素があれば非表示にして削除
                window.edgeWarningElement.style.opacity = '0';
                
                // 一定時間後に要素を完全に削除
                setTimeout(() => {
                    if (window.edgeWarningElement && window.edgeWarningElement.parentNode) {
                        window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                        window.edgeWarningElement = null;
                    }
                }, 500);
            }
            
            // 車の基本位置を取得
            const basePosition = point.clone();
            
            // オフセットを適用
            const offsetPosition = basePosition.add(offsetVector);
            
            // 車の位置を設定
            car.position.set(offsetPosition.x, carHeight, offsetPosition.z);
            
            // コーナーの状態をデバッグ表示
            const cornerStateEmoji = {
                'straight': '→',
                'entry': '↘',
                'apex': '↓',
                'exit': '↗'
            };
            const cornerEmoji = cornerStateEmoji[window.cornerState] || '→';
            
            // スタイルカラーをコーナー状態に応じて変更
            const cornerStateColor = {
                'straight': 'white',
                'entry': 'yellow',
                'apex': 'red',
                'exit': 'green'
            };
            const cornerColor = cornerStateColor[window.cornerState] || 'white';
            
            // ---------- 回転計算の残りの部分 ----------
            
            // 5. 回転行列を作成（3つの直交ベクトルから）
            const rotationMatrix = new THREE.Matrix4().makeBasis(
                rightVector,
                correctedUpVector,
                forwardVector.clone().negate() // THREE.jsの車モデルはZ-方向が前方なので反転
            );
            
            // 6. 回転行列からクォータニオンに変換
            const targetRotation = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
            
            // 7. 回転を直接適用（スムージングなし - 安定性優先）
            car.quaternion.copy(targetRotation);
            
            // 8. 上り下りの傾斜を反映（進行方向に合わせてピッチ角を適用）
            // combinedSlopeを使って車を傾ける（値を調整して傾きを強調）
            // マイナス符号を除去して傾斜の適用を正しく修正
            car.rotateX(combinedSlope * 1.5);
            
            // 9. カーブに応じた微小な横傾斜（Z軸回転）
            // 非常に小さな値に制限し、回転行列に影響を与えないようにする
            const maxTilt = 0.005; // 約0.3度に制限
            const tiltFactor = Math.min(maxTilt, curveAngle * carSpeed * 0.02);
            
            // 横傾斜を別途適用（既存の回転に小さな修正として追加）
            car.rotateZ(-tiltFactor * curveTiltDirection);
            
            // タイヤの回転と位置調整
            const wheelRotationSpeed = carSpeed * 0.3; // 回転速度係数を0.2から0.3に上げる
            
            // フロントタイヤのステアリング角度計算
            // 曲率が大きいほど、大きくステアリングする
            // curvatureDataから曲率を取得、方向も考慮
            const baseSteeringMultiplier = 3.5; // 基本ステアリング係数
            
            // コーナーの状態に応じてステアリング係数を調整（より自然な挙動）
            let steeringMultiplier = baseSteeringMultiplier;
            
            // コーナー進入時はより積極的にステアリング、頂点では維持、出口では徐々に戻す
            if (window.cornerState === 'entry') {
                // コーナー進入時は早めに大きくステアリング
                steeringMultiplier = baseSteeringMultiplier * 1.2;
            } else if (window.cornerState === 'apex') {
                // コーナー頂点では標準的なステアリング
                steeringMultiplier = baseSteeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // コーナー出口では徐々にステアリングを戻す
                steeringMultiplier = baseSteeringMultiplier * 0.8;
            }
            
            // スピードに応じた追加調整（高速時はより積極的にステアリング）
            steeringMultiplier *= (1 + speedFactor * 0.3);
            
            // 最終的なステアリング角度を計算
            // ステアリングの方向を修正
            // THREE.jsの座標系とステアリングの方向を正しく対応させる
            
            // コーナーの状態と方向に基づいてステアリング角度を計算
            let steeringAngle = 0;
            const steeringCornerDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // コーナー状態に応じたステアリング角度決定ロジック
            if (window.cornerState === 'entry') {
                // 進入時は先読みした曲率に基づいてステアリング
                steeringAngle = -steeringCornerDirection * Math.abs(maxAheadAngle) * steeringMultiplier;
            } else if (window.cornerState === 'apex') {
                // 頂点では現在の曲率に基づいてステアリング
                steeringAngle = -steeringCornerDirection * Math.abs(avgCurveAngle) * steeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // 出口では後ろの曲率に基づいてステアリング（徐々に戻す）
                steeringAngle = -steeringCornerDirection * Math.abs(maxBehindAngle) * steeringMultiplier;
            } else {
                // 直線ではわずかなステアリング（現在の曲率に基づく）
                steeringAngle = -curveTiltDirection * Math.abs(curveAngle) * steeringMultiplier * 0.5;
            }
            
            const maxSteeringAngle = Math.PI / 2.5; // 最大ステアリング角度
            
            // 直線走行時の微小なウォブリング効果（リアルさ向上）
            let wobblingEffect = 0;
            if (window.cornerState === 'straight') {
                // 時間に基づいて微小な振動を生成
                const wobbleFrequency = 2.0; // 揺れの頻度
                const wobbleAmount = 0.03; // 揺れの大きさ
                wobblingEffect = Math.sin(Date.now() / 200 * wobbleFrequency) * wobbleAmount;
                
                // 速度が速いほど揺れを小さく
                wobblingEffect *= (1 - speedFactor * 0.7);
            }
            
            // ウォブリング効果を追加した最終的なステアリング角度
            const finalSteeringAngle = steeringAngle + wobblingEffect;
            const clampedSteeringAngle = Math.max(-maxSteeringAngle, Math.min(maxSteeringAngle, finalSteeringAngle));
            
            // タイヤの高さを地面に合わせて調整
            for (let i = 0; i < wheels.length; i++) {
                // タイヤを回転
                wheels[i].rotation.x += wheelRotationSpeed;
                
                // タイヤの位置を調整
                const wheelGroup = wheelGroups[i];
                const isLeftSide = (i % 2 === 0); // 左側のタイヤかどうか
                const isFrontWheel = (i < 2); // 前輪かどうか
                
                // 前輪の場合、ステアリング角度を適用
                if (isFrontWheel) {
                    // Y軸周りの回転でステアリング効果を実現
                    wheelGroup.rotation.y = clampedSteeringAngle;
                }
                
                // タイヤの基本高さとオフセット
                const wheelBaseHeight = 0.5;
                
                // 傾きによる高さのわずかな調整（ほぼなし）
                const wheelTiltOffset = isLeftSide ? 
                    -tiltFactor * curveTiltDirection * 0.2 : // 左側タイヤ（効果を0.2に削減）
                    tiltFactor * curveTiltDirection * 0.2;   // 右側タイヤ（効果を0.2に削減）
                
                // タイヤの高さを設定
                wheelGroup.position.y = wheelBaseHeight + wheelTiltOffset;
            }
            
            // カメラの位置を更新
            updateCamera();
            
            // 画面描画
            renderer.render(scene, camera);
        }
        
        // カメラの位置と向きを更新
        function updateCamera() {
            switch (cameraMode) {
                case 0: // 俯瞰
                    camera.position.set(3 * 50 * 2.0, 350, 9 * 50 * 2.0); // より高い位置からの俯瞰視点（コース拡大と高低差に対応）
                    camera.lookAt(car.position);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 1: // 追従
                    // 車の後ろから少し上の位置（Z軸を正に変更して車の後ろに）
                    const followOffset = new THREE.Vector3(0, 12, 25); // 高さを少し上げる（起伏に対応）
                    // 車の向きに合わせてオフセットを回転
                    const rotatedOffset = followOffset.clone().applyQuaternion(car.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetCameraPos = new THREE.Vector3().addVectors(car.position, rotatedOffset);
                    camera.position.lerp(targetCameraPos, 0.1); // スムージング
                    
                    // カメラの注視点を車の位置に設定（少し前に）
                    const lookAheadOffset = new THREE.Vector3(0, -2, -20).applyQuaternion(car.quaternion);
                    const lookAtPoint = new THREE.Vector3().addVectors(car.position, lookAheadOffset);
                    camera.lookAt(lookAtPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 2: // 車載
                    // 運転席の位置（実際のドライバー目線の位置に）
                    const fpvOffset = new THREE.Vector3(0, 1.1, -12); // ドライバーの目の高さと位置に調整
                    // 車の向きに合わせてオフセットを回転
                    const rotatedFpvOffset = fpvOffset.clone().applyQuaternion(car.quaternion);
                    
                    // 車体の揺れを計算（カーブでの傾きを反映）
                    const curvatureData = calculateCurvature(carPosition);
                    const tiltAngle = curvatureData.angle * 0.2; // カーブでの傾き
                    
                    // 上下の揺れを追加（道路の起伏や速度による揺れ）
                    const bumpiness = Math.sin(Date.now() * 0.01) * 0.05 * carSpeed;
                    
                    // カメラ位置をスムーズに更新（揺れを加える）
                    const targetFpvCameraPos = new THREE.Vector3().addVectors(car.position, rotatedFpvOffset);
                    targetFpvCameraPos.y += bumpiness; // 上下の揺れを追加
                    camera.position.lerp(targetFpvCameraPos, 0.15); // スムージング（少し遅めに）
                    
                    // カメラの注視点を車の前方に設定（少し前と少し下を見るように）
                    const fpvAheadOffset = new THREE.Vector3(0, -1, -20).applyQuaternion(car.quaternion);
                    const fpvAtPoint = new THREE.Vector3().addVectors(car.position, fpvAheadOffset);
                    
                    // カメラの傾きを計算（カーブでの傾きを反映）
                    const fpvUpVector = new THREE.Vector3(Math.sin(tiltAngle), 1, 0);
                    camera.up.copy(fpvUpVector.normalize());
                    
                    // 車載視点のFOV(視野角)を調整して没入感を高める
                    camera.fov = 75; // 広い視野角に設定
                    camera.updateProjectionMatrix();
                    
                    // カメラの注視点を設定
                    camera.lookAt(fpvAtPoint);
                    break;
                case 3: // 斜め上視点
                    // 車の上と横から見る位置（車の傾きを強調して見せるため）
                    const diagonalOffset = new THREE.Vector3(50, 40, 20); // 右上からかなり離れた位置に配置
                    // 車の向きに合わせてオフセットを回転
                    const rotatedDiagOffset = diagonalOffset.clone().applyQuaternion(car.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetDiagCameraPos = new THREE.Vector3().addVectors(car.position, rotatedDiagOffset);
                    camera.position.lerp(targetDiagCameraPos, 0.1); // スムージング
                    
                    // 車をしっかり見る（少し前を見るように設定）
                    const diagLookOffset = new THREE.Vector3(0, -1, -5).applyQuaternion(car.quaternion);
                    const diagLookAtPoint = new THREE.Vector3().addVectors(car.position, diagLookOffset);
                    camera.lookAt(diagLookAtPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 4: // 車前方から後方を見る視点
                    // 車の前方の位置（Z軸を負に変更して車の前方に）
                    const frontOffset = new THREE.Vector3(0, 5, -30); // 車の前方、より離れた位置に変更
                    // 車の向きに合わせてオフセットを回転
                    const rotatedFrontOffset = frontOffset.clone().applyQuaternion(car.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetFrontCameraPos = new THREE.Vector3().addVectors(car.position, rotatedFrontOffset);
                    camera.position.lerp(targetFrontCameraPos, 0.1); // スムージング
                    
                    // カメラが車の後方を見るようにする
                    const lookBackOffset = new THREE.Vector3(0, 0, 20).applyQuaternion(car.quaternion);
                    const lookBackPoint = new THREE.Vector3().addVectors(car.position, lookBackOffset);
                    camera.lookAt(lookBackPoint);
                    
                    // 標準の視野角に戻す
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
            }
        }
        
        // リサイズ処理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // キーボードイベントの処理
        document.addEventListener('keydown', (event) => {
            // カメラモード切り替え
            if (event.key === '1') {
                cameraMode = 0; // 俯瞰
                updateButtonActiveState();
            } else if (event.key === '2') {
                cameraMode = 1; // 追従
                updateButtonActiveState();
            } else if (event.key === '3') {
                cameraMode = 2; // 車載
                updateButtonActiveState();
            } else if (event.key === '4') {
                cameraMode = 3; // 斜め上
                updateButtonActiveState();
            } else if (event.key === '5') {
                cameraMode = 4; // 前方
                updateButtonActiveState();
            }
        });

        // 視点切り替えボタンの設定
        function setupViewButtons() {
            const buttons = document.querySelectorAll('.viewButton');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    cameraMode = parseInt(button.getAttribute('data-view'));
                    updateButtonActiveState();
                    
                    // 視点切り替え時に現在の天気に応じて環境を更新
                    if (currentWeather === 'rain') {
                        updateEnvironmentForRain();
                    } else if (currentWeather === 'snow') {
                        updateEnvironmentForSnow();
                    } else {
                        // 晴れの場合は霧をなくす
                        scene.fog = null;
                    }
                });
            });
            
            // 初期表示時にボタンのアクティブ状態を更新
            updateButtonActiveState();
        }

        // ボタンのアクティブ状態を更新
        function updateButtonActiveState() {
            const buttons = document.querySelectorAll('.viewButton');
            buttons.forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // 初期化関数
        function init() {
            // 環境オブジェクトを配置
            placeEnvironmentObjects();
            
            // 視点切り替えボタンの設定
            setupViewButtons();
            
            // ミニマップの初期化
            initMinimap();
            
            // 天気トグルボタンのイベントリスナー
            document.getElementById('weatherToggleButton').addEventListener('click', function() {
                const weatherMenu = document.getElementById('weatherMenu');
                if (weatherMenu.style.display === 'none') {
                    weatherMenu.style.display = 'block';
                } else {
                    weatherMenu.style.display = 'none';
                }
            });
            
            // 天気オプションボタンのイベントリスナー
            document.querySelectorAll('.weatherOption').forEach(button => {
                button.addEventListener('click', function() {
                    const selectedWeather = this.getAttribute('data-weather');
                    
                    // 以前の天気をリセット
                    document.querySelectorAll('.weatherOption').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // 選択された天気をアクティブに
                    this.classList.add('active');
                    
                    // 天気を変更
                    changeWeather(selectedWeather);
                    
                    // メニューを閉じる
                    document.getElementById('weatherMenu').style.display = 'none';
                });
            });
            
            // アニメーションスタート
            log("アニメーション開始");
            animate();
            
            // 天気システムの初期化
            initWeatherSystem();
        }

        // ページ読み込み完了時に初期化を実行
        window.onload = init;

        // DOMContentLoadedイベントリスナーを削除（重複初期化防止のため）
        
        // ミニマップの初期化と描画
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // ミニマップの描画関数
            function drawMinimap() {
                // キャンバスをクリア
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 背景色
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // コースの座標を取得し、ミニマップの座標に変換
                const minimapPoints = [];
                const margin = 10; // マージン
                
                // コースの範囲を計算
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                trackPoints.forEach(point => {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minZ = Math.min(minZ, point[2]);
                    maxZ = Math.max(maxZ, point[2]);
                });
                
                // スケール係数を計算
                const mapWidth = canvas.width - margin * 2;
                const mapHeight = canvas.height - margin * 2;
                const scaleX = mapWidth / (maxX - minX);
                const scaleZ = mapHeight / (maxZ - minZ);
                const scale = Math.min(scaleX, scaleZ);
                
                // コースのポイントをミニマップ座標に変換
                trackPoints.forEach(point => {
                    const x = margin + (point[0] - minX) * scale;
                    const y = margin + (point[2] - minZ) * scale;
                    minimapPoints.push([x, y]);
                });
                
                // コースを描画（白い線）
                ctx.beginPath();
                ctx.moveTo(minimapPoints[0][0], minimapPoints[0][1]);
                for (let i = 1; i < minimapPoints.length; i++) {
                    ctx.lineTo(minimapPoints[i][0], minimapPoints[i][1]);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // スタート地点をマーク
                const startX = minimapPoints[0][0];
                const startY = minimapPoints[0][1];
                
                // スタートラインを描画
                ctx.beginPath();
                const tangent = new THREE.Vector3(
                    trackPoints[1][0] - trackPoints[0][0],
                    0,
                    trackPoints[1][2] - trackPoints[0][2]
                ).normalize();
                
                // 垂直方向のベクトルを計算
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // スタートラインの両端の座標を計算
                const lineLength = 8; // ラインの長さ
                const startLine1X = startX + perpendicular.x * lineLength;
                const startLine1Y = startY + perpendicular.z * lineLength;
                const startLine2X = startX - perpendicular.x * lineLength;
                const startLine2Y = startY - perpendicular.z * lineLength;
                
                // ラインを描画
                ctx.moveTo(startLine1X, startLine1Y);
                ctx.lineTo(startLine2X, startLine2Y);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // チェッカーフラッグパターンを描画
                const segments = 6;
                const segmentLength = lineLength * 2 / segments;
                
                for (let i = 0; i < segments; i++) {
                    if (i % 2 === 0) {
                        const segX1 = startLine2X + perpendicular.x * segmentLength * i;
                        const segY1 = startLine2Y + perpendicular.z * segmentLength * i;
                        const segX2 = segX1 + perpendicular.x * segmentLength;
                        const segY2 = segY1 + perpendicular.z * segmentLength;
                        
                        ctx.fillStyle = 'black';
                        
                        // 矩形を描画
                        ctx.beginPath();
                        ctx.moveTo(segX1, segY1);
                        ctx.lineTo(segX2, segY2);
                        ctx.lineTo(segX2 + tangent.x * 3, segY2 + tangent.z * 3);
                        ctx.lineTo(segX1 + tangent.x * 3, segY1 + tangent.z * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // 車の位置をミニマップ上で表示（赤い点）
                if (typeof carPosition !== 'undefined' && typeof carPath !== 'undefined') {
                    const point = carPath.getPointAt(carPosition);
                    const x = margin + (point.x - minX) * scale;
                    const y = margin + (point.z - minZ) * scale;
                    
                    // 車の向きを計算
                    const tangent = carPath.getTangentAt(carPosition).normalize();
                    const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                    
                    // 車を三角形で描画
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, -5);  // 先端
                    ctx.lineTo(-3, 3);  // 左下
                    ctx.lineTo(3, 3);   // 右下
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // ミニマップを定期的に更新
            setInterval(drawMinimap, 50);
        }

        // キーボードイベントを設定
        function setupKeyboardControls() {
            document.addEventListener('keydown', function(event) {
                switch(event.key) {
                    case '1':
                        cameraMode = 0; // 俯瞰
                        updateCameraButtonState();
                        break;
                    case '2':
                        cameraMode = 1; // 追従
                        updateCameraButtonState();
                        break;
                    case '3':
                        cameraMode = 2; // 車載
                        updateCameraButtonState();
                        break;
                    case '4':
                        cameraMode = 3; // 斜め上
                        updateCameraButtonState();
                        break;
                    case '5':
                        cameraMode = 4; // 前方
                        updateCameraButtonState();
                        break;
                }
            });

            // 視点切り替えボタンのイベントリスナー
            document.querySelectorAll('.viewButton').forEach(button => {
                button.addEventListener('click', function() {
                    cameraMode = parseInt(this.getAttribute('data-view'));
                    updateCameraButtonState();
                });
            });
        }

        // 時間モード切替ボタンのイベントリスナー
        document.getElementById('timeToggleButton').addEventListener('click', function() {
            useRealTime = !useRealTime;
            
            // ボタンの表示を更新
            if (useRealTime) {
                this.textContent = '🕒';
                this.title = '現在の時刻に連動（クリックで切替）';
                
                // 現実時間モードに戻ったら天気とカメラの自動変更をリセット
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 30000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 30000;
                
                // 現在地点の天気を取得して反映
                fetchCurrentWeather();
            } else {
                this.textContent = '⏩';
                this.title = 'ゲーム内時間モード（クリックで切替）';
                
                // 早送りモードに入ったら天気とカメラを自動更新開始
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 20000 + Math.random() * 20000;

                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 10000 + Math.random() * 5000;
            }
        });

        // DOMContentLoadedイベントリスナーは削除（init関数に移動済み）

        // ページ読み込み完了時に初期化を実行
        window.onload = init;

        // DOMContentLoadedイベントリスナーを削除（重複初期化防止のため）
        
        // ミニマップの初期化と描画
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // ミニマップの描画関数
            function drawMinimap() {
                // キャンバスをクリア
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 背景色
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // コースの座標を取得し、ミニマップの座標に変換
                const minimapPoints = [];
                const margin = 10; // マージン
                
                // コースの範囲を計算
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                trackPoints.forEach(point => {
                    minX = Math.min(minX, point[0]);
                    maxX = Math.max(maxX, point[0]);
                    minZ = Math.min(minZ, point[2]);
                    maxZ = Math.max(maxZ, point[2]);
                });
                
                // スケール係数を計算
                const mapWidth = canvas.width - margin * 2;
                const mapHeight = canvas.height - margin * 2;
                const scaleX = mapWidth / (maxX - minX);
                const scaleZ = mapHeight / (maxZ - minZ);
                const scale = Math.min(scaleX, scaleZ);
                
                // コースのポイントをミニマップ座標に変換
                trackPoints.forEach(point => {
                    const x = margin + (point[0] - minX) * scale;
                    const y = margin + (point[2] - minZ) * scale;
                    minimapPoints.push([x, y]);
                });
                
                // コースを描画（白い線）
                ctx.beginPath();
                ctx.moveTo(minimapPoints[0][0], minimapPoints[0][1]);
                for (let i = 1; i < minimapPoints.length; i++) {
                    ctx.lineTo(minimapPoints[i][0], minimapPoints[i][1]);
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // スタート地点をマーク
                const startX = minimapPoints[0][0];
                const startY = minimapPoints[0][1];
                
                // スタートラインを描画
                ctx.beginPath();
                const tangent = new THREE.Vector3(
                    trackPoints[1][0] - trackPoints[0][0],
                    0,
                    trackPoints[1][2] - trackPoints[0][2]
                ).normalize();
                
                // 垂直方向のベクトルを計算
                const perpendicular = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // スタートラインの両端の座標を計算
                const lineLength = 8; // ラインの長さ
                const startLine1X = startX + perpendicular.x * lineLength;
                const startLine1Y = startY + perpendicular.z * lineLength;
                const startLine2X = startX - perpendicular.x * lineLength;
                const startLine2Y = startY - perpendicular.z * lineLength;
                
                // ラインを描画
                ctx.moveTo(startLine1X, startLine1Y);
                ctx.lineTo(startLine2X, startLine2Y);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // チェッカーフラッグパターンを描画
                const segments = 6;
                const segmentLength = lineLength * 2 / segments;
                
                for (let i = 0; i < segments; i++) {
                    if (i % 2 === 0) {
                        const segX1 = startLine2X + perpendicular.x * segmentLength * i;
                        const segY1 = startLine2Y + perpendicular.z * segmentLength * i;
                        const segX2 = segX1 + perpendicular.x * segmentLength;
                        const segY2 = segY1 + perpendicular.z * segmentLength;
                        
                        ctx.fillStyle = 'black';
                        
                        // 矩形を描画
                        ctx.beginPath();
                        ctx.moveTo(segX1, segY1);
                        ctx.lineTo(segX2, segY2);
                        ctx.lineTo(segX2 + tangent.x * 3, segY2 + tangent.z * 3);
                        ctx.lineTo(segX1 + tangent.x * 3, segY1 + tangent.z * 3);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // 車の位置をミニマップ上で表示（赤い点）
                if (typeof carPosition !== 'undefined' && typeof carPath !== 'undefined') {
                    const point = carPath.getPointAt(carPosition);
                    const x = margin + (point.x - minX) * scale;
                    const y = margin + (point.z - minZ) * scale;
                    
                    // 車の向きを計算
                    const tangent = carPath.getTangentAt(carPosition).normalize();
                    const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                    
                    // 車を三角形で描画
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(0, -5);  // 先端
                    ctx.lineTo(-3, 3);  // 左下
                    ctx.lineTo(3, 3);   // 右下
                    ctx.closePath();
                    ctx.fillStyle = 'red';
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // ミニマップを定期的に更新
            setInterval(drawMinimap, 50);
        }

        // キーボードイベントを設定
        function setupKeyboardControls() {
            // ... existing code ...
        }

        
        // 天気システムの初期化
        function initWeatherSystem() {
            // 雪のパーティクルシステム
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 15000;
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSizes = new Float32Array(snowCount);
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                snowPositions[i] = Math.random() * 2000 - 1000; // x: -1000 to 1000
                snowPositions[i+1] = Math.random() * 1000; // y: 0 to 1000
                snowPositions[i+2] = Math.random() * 2000 - 1000; // z: -1000 to 1000
                snowSizes[i/3] = 3.0;
            }
            
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowGeometry.setAttribute('size', new THREE.BufferAttribute(snowSizes, 1));
            
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.0,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            snowParticles.visible = false;
            scene.add(snowParticles);
            
            // 雲のパーティクルシステム追加
            const cloudGeometry = new THREE.BufferGeometry();
            const cloudCount = 500; // 雲は雪より少なく
            const cloudPositions = new Float32Array(cloudCount * 3);
            const cloudSizes = new Float32Array(cloudCount);
            
            for (let i = 0; i < cloudCount * 3; i += 3) {
                cloudPositions[i] = Math.random() * 3000 - 1500; // x: -1500 to 1500 (広範囲に配置)
                cloudPositions[i+1] = 300 + Math.random() * 500; // y: 300 to 800 (高い位置に配置)
                cloudPositions[i+2] = Math.random() * 3000 - 1500; // z: -1500 to 1500
                cloudSizes[i/3] = 20.0 + Math.random() * 30.0; // 雲は大きめに
            }
            
            cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
            cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));
            
            // 雲のテクスチャを使用
            const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud10.png');
            
            const cloudMaterial = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 30.0,
                transparent: true,
                opacity: 0.7,
                map: cloudTexture,
                sizeAttenuation: true,
                depthWrite: false // 半透明のため、深度書き込みをオフ
            });
            
            cloudParticles = new THREE.Points(cloudGeometry, cloudMaterial);
            cloudParticles.visible = false;
            scene.add(cloudParticles);
            
            // 雨粒を縦長の形状に変更（インスタンシングを使用）
            // 雨粒の基本形状（細長い直方体）
            const rainDropGeometry = new THREE.BoxGeometry(0.1, 1.0, 0.1);
            const rainMaterial = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true, 
                opacity: 0.6
            });
            
            // インスタンス化されたメッシュを作成
            const rainCount = 15000;
            rainParticles = new THREE.InstancedMesh(rainDropGeometry, rainMaterial, rainCount);
            rainParticles.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // 位置を動的に更新
            rainParticles.visible = false;
            
            // 雨粒のインスタンスごとの初期位置とスケールを設定
            const matrix = new THREE.Matrix4();
            const position = new THREE.Vector3();
            const rotation = new THREE.Euler();
            const quaternion = new THREE.Quaternion();
            const scale = new THREE.Vector3(1, 1, 1);
            
            for (let i = 0; i < rainCount; i++) {
                position.x = Math.random() * 2000 - 1000;
                position.y = Math.random() * 1000;
                position.z = Math.random() * 2000 - 1000;
                
                // 若干ランダムな角度を付ける（雨が斜めに降っているように）
                rotation.x = 0;
                rotation.z = 0;
                rotation.y = Math.random() * Math.PI;
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                rainParticles.setMatrixAt(i, matrix);
            }
            
            rainParticles.instanceMatrix.needsUpdate = true;
            scene.add(rainParticles);
            
            // 初期天気の設定
            if (useRealTime) {
                // 現在地点の天気を取得して反映
                fetchCurrentWeather();
            } else {
                // ランダムな天気を設定
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
            }
        }
        
        // 天気を変更する関数
        function changeWeather(weather) {
            currentWeather = weather;
            
            // 天気ボタンのアイコンを更新
            const weatherButton = document.getElementById('weatherToggleButton');
            
            switch(weather) {
                case 'sunny':
                    weatherButton.textContent = '☀️';
                    weatherButton.title = '晴れ (クリックで変更)';
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = false;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = false;
                    
                    // 晴れの環境に更新
                    updateEnvironmentForSunny();
                    break;
                case 'cloudy':
                    weatherButton.textContent = '☁️';
                    weatherButton.title = '曇り (クリックで変更)';
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // 曇りの場合は霧を追加
                    updateEnvironmentForCloudy();
                    break;
                case 'rain':
                    weatherButton.textContent = '🌧';
                    weatherButton.title = '雨 (クリックで変更)';
                    isRaining = true;
                    isSnowing = false;
                    isCloudy = true; // 雨の時は曇りも有効
                    if (rainParticles) rainParticles.visible = true;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // 雨の場合は地面を濡れた感じに
                    updateEnvironmentForRain();
                    break;
                case 'snow':
                    weatherButton.textContent = '❄️';
                    weatherButton.title = '雪 (クリックで変更)';
                    isRaining = false;
                    isSnowing = true;
                    isCloudy = true; // 雪の時は曇りも有効
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = true;
                    if (cloudParticles) cloudParticles.visible = true;
                    
                    // 雪の場合は地面を白くする
                    updateEnvironmentForSnow();
                    break;
            }
        }
        
        // 曇りの環境更新
        function updateEnvironmentForCloudy() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) { // 俯瞰視点の場合
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.003);
            }
            
            // 曇りの空の色を設定（グレーがかった色）
            weatherSkyColor = new THREE.Color(0x8c8c8c);
            
            // 曇り時の芝生の色
            floor.material.color.setHex(0x2a552a);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // 雨の環境更新
        function updateEnvironmentForRain() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0x555555, 0.001);
            } else {
                scene.fog = new THREE.FogExp2(0x555555, 0.007);
            }
            
            // 雨の空の色を設定（暗いグレー）
            weatherSkyColor = new THREE.Color(0x4a4a4a);
            
            // 地面を濡れた感じに
            floor.material.color.setHex(0x1c4d1c);
            floor.material.roughness = 0.4;
            floor.material.metalness = 0.3;
            floor.material.needsUpdate = true;
        }
        
        // 雪の環境更新
        function updateEnvironmentForSnow() {
            // カメラモードに応じて霧の濃度を調整
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0005);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.005);
            }
            
            // 雪の空の色を設定（明るいグレー）
            weatherSkyColor = new THREE.Color(0xd8d8d8);
            
            // 地面を雪で覆われたように
            floor.material.color.setHex(0xf0f0f0);
            floor.material.roughness = 0.9;
            floor.material.metalness = 0.0;
            floor.material.needsUpdate = true;
        }
        
        // 晴れの環境更新
        function updateEnvironmentForSunny() {
            // 霧をなくす
            scene.fog = null;
            
            // 晴れの空の色を設定（明るい青空）
            weatherSkyColor = new THREE.Color(0x87CEEB);
            
            // 通常の芝生の色に戻す
            floor.material.color.setHex(0x336633);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // 天気の更新
        function updateWeather(deltaTime) {
            // 早送りモード時の自動天気変更とカメラ切り替え
            if (!useRealTime) {
                const currentTime = Date.now();
                
                // 天気の自動変更
                if (currentTime - lastWeatherChangeTime > weatherChangeInterval) {
                    const availableChoices = availableWeathers.filter(w => w !== currentWeather);
                    const nextWeather = availableChoices[Math.floor(Math.random() * availableChoices.length)];
                    changeWeather(nextWeather);
                    lastWeatherChangeTime = currentTime;
                    weatherChangeInterval = 20000 + Math.random() * 20000;
                    console.log("天気自動変更: " + nextWeather);
                }
                
                // カメラの自動切り替え
                if (currentTime - lastCameraChangeTime > cameraChangeInterval) {
                    const availableViews = availableCameraModes.filter(mode => mode !== cameraMode);
                    const nextCameraMode = availableViews[Math.floor(Math.random() * availableViews.length)];
                    cameraMode = nextCameraMode;
                    updateCameraButtonState();
                    
                    lastCameraChangeTime = currentTime;
                    cameraChangeInterval = 10000 + Math.random() * 5000;
                    console.log("カメラ自動切り替え: " + nextCameraMode);
                }
            }
            
            // 既存の天気更新処理
            if (isCloudy && cloudParticles) {
                // 雲のパーティクル更新
                const cloudPositions = cloudParticles.geometry.attributes.position.array;
                const cloudCount = cloudPositions.length / 3;
                
                // カメラモードに応じて雲の表示を調整
                if (cameraMode === 0) { // 俯瞰視点の場合
                    // 俯瞰視点では少し透明度を上げて薄く見せる
                    cloudParticles.material.opacity = 0.4;
                    // より広範囲に配置
                    cloudParticles.scale.set(3, 1, 3);
                } else {
                    // 通常視点では標準の表示
                    cloudParticles.material.opacity = 0.7;
                    cloudParticles.scale.set(1, 1, 1);
                }
                
                for (let i = 0; i < cloudCount * 3; i += 3) {
                    // X,Z座標をゆっくり動かす（雲が動く感じ）
                    cloudPositions[i] += Math.sin(currentFrameTime * 0.0001 + i * 0.01) * 0.3 * deltaTime;
                    cloudPositions[i+2] += Math.cos(currentFrameTime * 0.00015 + i * 0.01) * 0.3 * deltaTime;
                    
                    // 遠くに行きすぎたら反対側に配置
                    if (cloudPositions[i] > 1500) cloudPositions[i] = -1500;
                    if (cloudPositions[i] < -1500) cloudPositions[i] = 1500;
                    if (cloudPositions[i+2] > 1500) cloudPositions[i+2] = -1500;
                    if (cloudPositions[i+2] < -1500) cloudPositions[i+2] = 1500;
                }
                
                // カメラを中心に雲を配置
                cloudParticles.position.x = camera.position.x;
                cloudParticles.position.z = camera.position.z;
                
                cloudParticles.geometry.attributes.position.needsUpdate = true;
            }
        
            if (isRaining && rainParticles) {
                // 雨粒を更新（インスタンス化されたメッシュ版）
                const rainMatrix = new THREE.Matrix4();
                const rainPosition = new THREE.Vector3();
                const rainRotation = new THREE.Euler();
                const rainQuaternion = new THREE.Quaternion();
                const rainScale = new THREE.Vector3();
                
                // カメラモードに応じて雨の表示を調整
                if (cameraMode === 0) { // 俯瞰視点の場合
                    // 俯瞰視点では透明度を上げて薄く見せる
                    rainParticles.material.opacity = 0.3;
                    // 広範囲に配置するため大きなスケール
                    rainParticles.scale.set(3, 1, 3);
                } else {
                    // 通常視点では標準の表示
                    rainParticles.material.opacity = 0.6;
                    rainParticles.scale.set(1, 1, 1);
                }
                
                // カメラを中心に雨を配置
                rainParticles.position.x = camera.position.x;
                rainParticles.position.z = camera.position.z;
                
                // 各雨粒のインスタンスを更新
                for (let i = 0; i < rainParticles.count; i++) {
                    rainParticles.getMatrixAt(i, rainMatrix);
                    // 行列から位置、回転、スケールを抽出
                    rainMatrix.decompose(rainPosition, rainQuaternion, rainScale);
                    
                    // Y座標を下に移動（雨が降る）
                    rainPosition.y -= 10 * deltaTime;
                    
                    // 地面に到達したら上に戻す
                    if (rainPosition.y < 0) {
                        rainPosition.y = 1000;
                        // X,Z座標もランダムに配置し直す
                        rainPosition.x = Math.random() * 2000 - 1000;
                        rainPosition.z = Math.random() * 2000 - 1000;
                    }
                    
                    // 回転は維持
                    // スケールも維持
                    
                    // 新しい位置で行列を更新
                    rainMatrix.compose(rainPosition, rainQuaternion, rainScale);
                    rainParticles.setMatrixAt(i, rainMatrix);
                }
                
                rainParticles.instanceMatrix.needsUpdate = true;
            }
            
            if (isSnowing && snowParticles) {
                // 雪のパーティクル更新
                const snowPositions = snowParticles.geometry.attributes.position.array;
                const snowCount = snowPositions.length / 3;
                
                // カメラモードに応じて雪の表示を調整
                if (cameraMode === 0) { // 俯瞰視点の場合
                    // 俯瞰視点では少し透明度を上げて薄く見せる
                    snowParticles.material.opacity = 0.4;
                    // パーティクルのサイズを小さく
                    snowParticles.material.size = 1.0;
                    
                    // より広範囲に配置
                    snowParticles.scale.set(3, 1, 3);
                } else {
                    // 通常視点では標準の表示
                    snowParticles.material.opacity = 0.8;
                    snowParticles.material.size = 2.0;
                    snowParticles.scale.set(1, 1, 1);
                }
                
                for (let i = 0; i < snowCount * 3; i += 3) {
                    // Y座標を下に移動（雪が降る、雨より遅い）
                    snowPositions[i+1] -= 2 * deltaTime;
                    
                    // X,Z座標も少し揺らす（雪が舞う感じ）
                    snowPositions[i] += Math.sin(currentFrameTime * 0.001 + i * 0.1) * 0.2 * deltaTime;
                    snowPositions[i+2] += Math.cos(currentFrameTime * 0.0015 + i * 0.1) * 0.2 * deltaTime;
                    
                    // 地面に到達したら上に戻す
                    if (snowPositions[i+1] < 0) {
                        snowPositions[i+1] = 1000;
                        // X,Z座標もランダムに配置し直す
                        snowPositions[i] = Math.random() * 2000 - 1000;
                        snowPositions[i+2] = Math.random() * 2000 - 1000;
                    }
                }
                
                // カメラを中心に雪を配置
                snowParticles.position.x = camera.position.x;
                snowParticles.position.z = camera.position.z;
                
                snowParticles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // カメラモードボタンの表示を更新する関数
        function updateCameraButtonState() {
            document.querySelectorAll('.viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // 現在位置の天気を取得する関数
        async function fetchCurrentWeather() {
            try {
                // 現在位置を取得
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                log(`現在位置を取得しました: 緯度 ${lat}, 経度 ${lon}`);
                
                // OpenWeatherMap APIを呼び出し
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${weatherApiKey}&units=metric`);
                
                if (!response.ok) {
                    throw new Error('天気情報の取得に失敗しました');
                }
                
                const data = await response.json();
                log('現在の天気情報を取得しました: ' + data.weather[0].main);
                
                // 天気コードに基づいて天気を設定
                const weatherCode = data.weather[0].id;
                let gameWeather = 'sunny'; // デフォルト
                
                // 天気コードに基づいて天気を判定
                // 雪 (Snow): 600-622
                if (weatherCode >= 600 && weatherCode < 623) {
                    gameWeather = 'snow';
                }
                // 雨 (Rain): 500-531, 雷雨 (Thunderstorm): 200-232
                else if ((weatherCode >= 500 && weatherCode < 532) || (weatherCode >= 200 && weatherCode < 233)) {
                    gameWeather = 'rain';
                }
                // 曇り (Clouds): 801-804
                else if (weatherCode >= 801 && weatherCode < 805) {
                    gameWeather = 'cloudy';
                }
                // 晴れ (Clear): 800
                else if (weatherCode === 800) {
                    gameWeather = 'sunny';
                }
                // その他の天気（霧、霞など）は曇りとして扱う
                else {
                    gameWeather = 'cloudy';
                }
                
                log(`天気を変更します: ${gameWeather}`);
                
                // 天気を変更
                changeWeather(gameWeather);
                
                // 天気メニューのアクティブ状態を更新
                document.querySelectorAll('.weatherOption').forEach(button => {
                    if (button.getAttribute('data-weather') === gameWeather) {
                        button.classList.add('active');
                    } else {
                        button.classList.remove('active');
                    }
                });
                
                return gameWeather;
            } catch (error) {
                console.error('天気情報の取得エラー:', error);
                log('天気情報の取得に失敗しました。デフォルトの天気を使用します。');
                
                // エラーの場合はランダムな天気を設定
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
                
                return null;
            }
        }
    </script>
</body>
</html> 