<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>エンドレスカー - ロンドン市街地コース</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>
<body>
    <div id="info">エンドレスカー - ロンドン市街地コース</div>
    <script>
        // デバッグ用のログ
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
        
        log("スクリプト開始");
        
        // 基本設定
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x646464); // 初期の空の色を設定
        document.body.appendChild(renderer.domElement);
        
        log("Three.jsの基本設定完了");

        // 時間システムの追加
        let gameTime = 0; // ゲーム内時間（0～24）
        const timeSpeed = 0.005; // 時間の進む速度
        
        // 時間帯に応じた空の色と光の設定
        function updateDayNightCycle() {
            // 時間を更新
            gameTime = (gameTime + timeSpeed) % 24;
            
            // 時間帯に応じた空の色の設定
            let skyColor;
            let lightIntensity;
            let ambientIntensity;
            
            if (gameTime >= 5 && gameTime < 7) {
                // 朝焼け（5時～7時）
                const t = (gameTime - 5) / 2; // 0～1の範囲に正規化
                skyColor = new THREE.Color(0xff9966).lerp(new THREE.Color(0x87CEEB), t);
                lightIntensity = 0.5 + t * 0.5;
                ambientIntensity = 0.3 + t * 0.3;
            } else if (gameTime >= 7 && gameTime < 17) {
                // 昼間（7時～17時）
                skyColor = new THREE.Color(0x87CEEB);
                lightIntensity = 1.0;
                ambientIntensity = 0.6;
            } else if (gameTime >= 17 && gameTime < 19) {
                // 夕焼け（17時～19時）
                const t = (gameTime - 17) / 2; // 0～1の範囲に正規化
                skyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff7733), t);
                lightIntensity = 1.0 - t * 0.5;
                ambientIntensity = 0.6 - t * 0.3;
            } else if (gameTime >= 19 && gameTime < 21) {
                // 日没後（19時～21時）
                const t = (gameTime - 19) / 2; // 0～1の範囲に正規化
                skyColor = new THREE.Color(0xff7733).lerp(new THREE.Color(0x111133), t);
                lightIntensity = 0.5 - t * 0.4;
                ambientIntensity = 0.3 - t * 0.2;
            } else {
                // 夜間（21時～5時）
                if (gameTime >= 21) {
                    skyColor = new THREE.Color(0x111133);
                } else {
                    // 夜明け前（4時～5時）
                    const t = gameTime / 5; // 0～1の範囲に正規化
                    skyColor = new THREE.Color(0x111133).lerp(new THREE.Color(0xff9966), t);
                }
                lightIntensity = 0.1;
                ambientIntensity = 0.1;
            }
            
            // 空の色を設定
            renderer.setClearColor(skyColor.getHex());
            
            // 光源の強度を設定
            directionalLight.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            
            // 夜間は街灯を明るく
            updateStreetLights();
        }
        
        // 街灯の明るさを更新
        function updateStreetLights() {
            // 夜間（18時～6時）は街灯を点灯
            const isNight = (gameTime >= 18 || gameTime < 6);
            
            // すべての街灯を取得して更新
            scene.traverse((object) => {
                // 街灯のライト部分を見つける（ランプという名前のメッシュ）
                if (object.name === "streetlamp") {
                    const lampMaterial = object.material;
                    if (isNight) {
                        // 夜間は光を強くする
                        lampMaterial.emissiveIntensity = 0.8;
                        // 街灯の光のサイズを大きくする
                        if (object.scale.x < 1.2) {
                            object.scale.set(1.2, 1.2, 1.2);
                        }
                    } else {
                        // 昼間は光を弱くする
                        lampMaterial.emissiveIntensity = 0.1;
                        // 街灯の光のサイズを元に戻す
                        if (object.scale.x > 1.0) {
                            object.scale.set(1.0, 1.0, 1.0);
                        }
                    }
                }
            });
        }

        // 光源
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        // 都市の地面を作成
        const floorSize = 2500; // 床のサイズを調整してコースに最適化
        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x336633, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5; // 床の位置を下げる
        scene.add(floor);
        
        // 舗装された道路の幅
        const roadWidth = 16; // 道路の幅を維持
        
        // リッジレーサー風の上級コース定義（すべて地上・閉ループ化）
        const trackPoints = [
    // 新しいトラックポイント（x, y+高度, z）
    [200, 20, 350],      // 4,7,0
    [50, 20, 350],       // 1,7,0
    [0, 21, 250],        // 0,5,1
    [25, 22, 200],       // 0.5,4,2
    [60, 22, 215],       // 1.2,4.3,2
    [125, 22, 140],      // 2.5,2.8,2
    [100, 23, 50],       // 2,1,3
    [135, 22.5, 0],      // 2.7,0,2.5
    [200, 20, 50],       // 4,1,0
    [240, 20, 40],       // 4.8,0.8,0
    [295, 20, 90],       // 5.9,1.8,0
    [285, 21, 105],      // 5.7,2.1,1
    [210, 21, 110],      // 4.2,2.2,1
    [185, 22, 145],      // 3.7,2.9,3
    [150, 22, 235],      // 3,4.7,2
    [170, 21, 275],      // 3.4,5.5,1
    [220, 21, 275],      // 4.4,5.5,1
    [270, 22, 225],      // 5.4,4.5,2
    [285, 22, 180],      // 5.7,3.6,2
    [365, 21, 150],      // 7.3,3,1
    [400, 21, 165],      // 8,3.3,1
    [475, 22, 175],      // 9.5,3.5,2
    [450, 21, 250],      // 9,5,1
    [395, 21, 285],      // 7.9,5.7,1
    [350, 21, 265],      // 7,5.3,1
    [300, 20, 275],      // 6,5.5,0
    [245, 20, 350],      // 4.9,7,0
    [200, 20, 350]       // 4,7,0
];
        
        // 道路を作成
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);
        
        // 3Dパスポイントに変換
        const carPathPoints = [];
        for (let i = 0; i < trackPoints.length; i++) {
            // 高さ情報（Y軸）を考慮したポイントを作成
            carPathPoints.push(new THREE.Vector3(trackPoints[i][0], trackPoints[i][1] + 0.3, trackPoints[i][2]));
        }
        
        // カトマル・ロムスプラインで滑らかな曲線を作成
        const carPath = new THREE.CatmullRomCurve3(carPathPoints);
        carPath.closed = true; // 閉じたループに戻す
        
        // パスの詳細なポイントを取得（道路生成用）
        const detailedPathPoints = carPath.getPoints(500);
        
        // アスファルト部分を作成
        function createRoadSurface() {
            // 道路の左右のエッジを計算
            const leftEdgePoints = [];
            const rightEdgePoints = [];
            
            for (let i = 0; i < detailedPathPoints.length; i++) {
                const point = detailedPathPoints[i];
                const nextPoint = detailedPathPoints[(i + 1) % detailedPathPoints.length];
                
                // 進行方向ベクトルを計算
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                
                // 上向きベクトル（法線）を計算
                // 高さの変化を考慮した法線ベクトルを計算する（地形に沿った道路）
                const up = new THREE.Vector3(0, 1, 0);
                
                // 右向きベクトル（進行方向と上向きの外積）
                const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                
                // 修正した上向きベクトル（進行方向と右向きの外積）
                const correctedUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                
                // 道路の左右のエッジを計算（修正した法線ベクトルを使用）
                const leftEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(roadWidth / 2));
                const rightEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(-roadWidth / 2));
                
                // 高さを維持（道路面の高さは既にdetailedPathPointsに含まれる）
                // 道路を少し浮かせる（0.05）
                leftEdge.y += 0.05;
                rightEdge.y += 0.05;
                
                leftEdgePoints.push(leftEdge);
                rightEdgePoints.push(rightEdge);
            }
            
            // 道路の表面を三角形メッシュで作成
            const roadGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // すべてのポイントを頂点配列に追加
            for (let i = 0; i < leftEdgePoints.length; i++) {
                vertices.push(leftEdgePoints[i].x, leftEdgePoints[i].y, leftEdgePoints[i].z);
                vertices.push(rightEdgePoints[i].x, rightEdgePoints[i].y, rightEdgePoints[i].z);
            }
            
            // 三角形インデックスを作成
            for (let i = 0; i < leftEdgePoints.length - 1; i++) {
                const v0 = i * 2;
                const v1 = v0 + 1;
                const v2 = v0 + 2;
                const v3 = v0 + 3;
                
                // 2つの三角形で四角形を作成
                indices.push(v0, v1, v2);
                indices.push(v2, v1, v3);
            }
            
            // 最後の部分を閉じる
            const v0 = (leftEdgePoints.length - 1) * 2;
            const v1 = v0 + 1;
            const v2 = 0;
            const v3 = 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
            
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            roadGeometry.setIndex(indices);
            roadGeometry.computeVertexNormals();
            
            const roadMaterial = new THREE.MeshLambertMaterial({
                color: 0x777777, // 0x333333から0x777777に変更して道路を薄く（明るく）する
                side: THREE.DoubleSide
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadGroup.add(roadMesh);
            
            // 白線（実線）を作成 - 削除
            // createRoadLine(detailedPathPoints, 0.05, 0xFFFFFF);
            
            // 縁石を作成（コーナー部分） - 削除
            // createCurbstones();
            
            return roadMesh;
        }
        
        // 道路の白線を作成
        function createRoadLine(pathPoints, lineWidth, color) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.y = 0.1; // 道路の上に浮かせる
            roadGroup.add(line);
            
            return line;
        }
        
        // 縁石を作成（コーナー部分）
        function createCurbstones() {
            // コーナーの位置（パスの割合）
            const cornerPositions = [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.85];
            
            for (let i = 0; i < cornerPositions.length; i++) {
                const t = cornerPositions[i];
                const cornerLength = 0.05; // コーナーの長さ（パスの割合）
                
                for (let j = 0; j < 10; j++) {
                    const segmentT = t + (j * cornerLength / 10);
                    const point = carPath.getPointAt(segmentT);
                    const tangent = carPath.getTangentAt(segmentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (segmentT + 0.005) % 1;
                    const prevT = (segmentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // 縁石の位置（道路の外側）
                    const curbPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(roadWidth / 2)
                    );
                    
                    // 前後方向の傾斜角を計算（Y軸方向の変化から）
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // 赤白の縁石（交互）
                    const color = j % 2 === 0 ? 0xff0000 : 0xffffff;
                    
                    const curbGeometry = new THREE.BoxGeometry(1, 0.3, 1);
                    const curbMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                    
                    // 縁石の位置を道路の高さに合わせる
                    curb.position.copy(curbPosition);
                    curb.position.y = point.y + 0.1; // 道路面より少し浮かせる
                    
                    // 進行方向を向くように回転
                    const lookAtPos = new THREE.Vector3().addVectors(
                        curbPosition,
                        tangent
                    );
                    curb.lookAt(lookAtPos);
                    
                    // 上下の傾斜に合わせて追加の回転
                    curb.rotateX(slope);
                    
                    roadGroup.add(curb);
                }
            }
        }
        
        // ガードレールを作成（コース全体の外側）
        function createGuardrails() {
            // ガードレールの間隔（パスの割合）
            const railSpacing = 0.005; // より密に配置
            const postSpacing = 0.025; // 支柱の間隔
            
            // ガードレール用のグループを作成
            const guardrailGroup = new THREE.Group();
            roadGroup.add(guardrailGroup);
            
            // 道路の両側にガードレールを設置
            createSideGuardrail(1); // 右側
            createSideGuardrail(-1); // 左側
            
            // 特定の側（右側または左側）にガードレールを作成する関数
            function createSideGuardrail(side) {
                // 連続したガードレールのセグメントを格納する配列
                const railSegments = [];
                const railPosts = [];
                
                // ガードレール用の頂点とインデックスを収集
                const railVertices = [];
                const railIndices = [];
                const railUvs = [];
                
                let vertexIndex = 0;
                let currentT = 0;
                
                // ガードレールの頂点データを生成
                while (currentT < 1) {
                    const point = carPath.getPointAt(currentT);
                    const tangent = carPath.getTangentAt(currentT);
                    
                    // 次のポイントと前のポイントを取得して傾斜を計算
                    const nextT = (currentT + 0.005) % 1;
                    const prevT = (currentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // 垂直方向ベクトル（外側方向）
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ガードレールの位置（道路の外側、side=1で右側、side=-1で左側）
                    const railPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(side * (roadWidth / 2 + 1.2))
                    );
                    
                    // 前後方向の傾斜角を計算
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // ガードレールの高さ調整
                    const railHeight = point.y + 0.8; // 道路面から少し高く
                    
                    // ガードレールの上部と下部の頂点を追加
                    const topRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight + 0.4, // 上部の高さ
                        railPosition.z
                    );
                    
                    const bottomRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight, // 下部の高さ
                        railPosition.z
                    );
                    
                    // 支柱を作成（一定間隔ごと）
                    if (Math.abs(currentT % postSpacing) < railSpacing) {
                        const postGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6);
                        const postMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        
                        // 支柱の位置を設定
                        post.position.copy(new THREE.Vector3(
                            railPosition.x,
                            point.y + 0.5, // 地面からの高さ
                            railPosition.z
                        ));
                        
                        // 支柱を少し内側に傾ける
                        const postLookAt = new THREE.Vector3().addVectors(
                            post.position,
                            normal.clone().multiplyScalar(-0.1 * side) // 内側に少し傾ける
                        );
                        post.lookAt(postLookAt);
                        post.rotateX(Math.PI / 2); // 支柱の向きを修正
                        
                        // 上下の傾斜に合わせて追加の回転
                        post.rotateZ(slope); // X軸ではなくZ軸で回転（支柱の向きが変わっているため）
                        
                        guardrailGroup.add(post);
                        railPosts.push(post);
                    }
                    
                    // 頂点データを追加
                    railVertices.push(
                        topRailPos.x, topRailPos.y, topRailPos.z,
                        bottomRailPos.x, bottomRailPos.y, bottomRailPos.z
                    );
                    
                    // テクスチャ座標を追加
                    railUvs.push(
                        currentT * 20, 0, // 上部のUV座標
                        currentT * 20, 1  // 下部のUV座標
                    );
                    
                    // インデックスを追加（四角形を作成）
                    if (vertexIndex > 0) {
                        // 各セグメント間を三角形で接続
                        railIndices.push(
                            vertexIndex * 2 - 2, vertexIndex * 2, vertexIndex * 2 - 1, // 最初の三角形
                            vertexIndex * 2 - 1, vertexIndex * 2, vertexIndex * 2 + 1  // 二番目の三角形
                        );
                    }
                    
                    vertexIndex++;
                    currentT += railSpacing;
                }
                
                // 最後のセグメントを最初のセグメントと接続して閉じる
                railIndices.push(
                    (vertexIndex - 1) * 2, 0, (vertexIndex - 1) * 2 + 1, // 最初の三角形
                    (vertexIndex - 1) * 2 + 1, 0, 1  // 二番目の三角形
                );
                
                // ガードレールのジオメトリを作成
                const railGeometry = new THREE.BufferGeometry();
                railGeometry.setAttribute('position', new THREE.Float32BufferAttribute(railVertices, 3));
                railGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(railUvs, 2));
                railGeometry.setIndex(railIndices);
                railGeometry.computeVertexNormals();
                
                // 高速道路のガードレールらしい素材
                const railMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE0E0E0,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // ガードレールメッシュを作成
                const railMesh = new THREE.Mesh(railGeometry, railMaterial);
                guardrailGroup.add(railMesh);
            }
        }
        
        // 道路の可視化
        createRoadSurface();
        
        // ガードレールの作成
        createGuardrails();
        
        log("道路の作成完了");
        
        // ロンドン風の建物を追加
        function createLondonBuilding(x, z, type = Math.floor(Math.random() * 5)) {
            const building = new THREE.Group();
            
            // 建物の種類によって異なる形状と色を設定
            let width, depth, height, color;
            
            switch(type) {
                case 0: // ヴィクトリア様式の建物（レンガ色）
                    width = 10 + Math.random() * 5;
                    depth = 10 + Math.random() * 5;
                    height = 12 + Math.random() * 10;
                    color = 0xA0522D; // レンガ色
                    break;
                case 1: // モダンな高層ビル（青いガラス）
                    width = 8 + Math.random() * 8;
                    depth = 8 + Math.random() * 8;
                    height = 25 + Math.random() * 20;
                    color = 0x87CEEB; // 水色（ガラス）
                    break;
                case 2: // 歴史的な中層建築（石灰岩風）
                    width = 12 + Math.random() * 6;
                    depth = 12 + Math.random() * 6;
                    height = 15 + Math.random() * 8;
                    color = 0xDCDCDC; // 明るい灰色
                    break;
                case 3: // ロンドンの伝統的なテラスハウス
                    width = 15 + Math.random() * 10;
                    depth = 8 + Math.random() * 3;
                    height = 10 + Math.random() * 5;
                    color = 0xF5F5DC; // ベージュ
                    break;
                case 4: // ロンドンの代表的な建物
                    if (Math.random() > 0.7) {
                        // ビッグベン風の塔
                        width = 8;
                        depth = 8;
                        height = 40;
                        color = 0xDEB887; // 砂色
                        
                        // 本体
                        const tower = new THREE.Mesh(
                            new THREE.BoxGeometry(width, height, depth),
                            new THREE.MeshLambertMaterial({ color: color })
                        );
                        tower.position.y = height / 2;
                        building.add(tower);
                        
                        // 時計部分
                        const clockSize = width * 1.2;
                        const clockHeight = 6;
                        const clockTower = new THREE.Mesh(
                            new THREE.BoxGeometry(clockSize, clockHeight, clockSize),
                            new THREE.MeshLambertMaterial({ color: 0xFFFFFF })
                        );
                        clockTower.position.y = height - clockHeight / 2;
                        building.add(clockTower);
                        
                        // 尖塔
                        const spireHeight = 10;
                        const spire = new THREE.Mesh(
                            new THREE.ConeGeometry(width / 4, spireHeight, 4),
                            new THREE.MeshLambertMaterial({ color: 0x333333 })
                        );
                        spire.position.y = height + spireHeight / 2;
                        building.add(spire);
                        
                        building.position.set(x, 0, z);
                        scene.add(building);
                        return building;
                    } else {
                        // タワーブリッジ風の塔（2つの塔とその間の道）
                        width = 10;
                        depth = 10;
                        height = 30;
                        color = 0xD2B48C; // タン色
                        
                        // 左の塔
                        const leftTower = new THREE.Mesh(
                            new THREE.BoxGeometry(width, height, depth),
                            new THREE.MeshLambertMaterial({ color: color })
                        );
                        leftTower.position.set(-width * 1.5, height / 2, 0);
                        building.add(leftTower);
                        
                        // 右の塔
                        const rightTower = new THREE.Mesh(
                            new THREE.BoxGeometry(width, height, depth),
                            new THREE.MeshLambertMaterial({ color: color })
                        );
                        rightTower.position.set(width * 1.5, height / 2, 0);
                        building.add(rightTower);
                        
                        // 橋の部分
                        const bridge = new THREE.Mesh(
                            new THREE.BoxGeometry(width * 4, 2, depth),
                            new THREE.MeshLambertMaterial({ color: 0x333333 })
                        );
                        bridge.position.set(0, height * 0.6, 0);
                        building.add(bridge);
                        
                        building.position.set(x, 0, z);
                        scene.add(building);
                        return building;
                    }
            }
            
            // 標準的な建物の本体
            const buildingMesh = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth),
                new THREE.MeshLambertMaterial({ color: color })
            );
            buildingMesh.position.y = height / 2;
            building.add(buildingMesh);
            
            // 窓を追加
            const windowColor = 0x87CEEB;
            const windowSize = 1;
            const windowSpacing = 2.5;
            
            // 横方向の窓の数
            const windowsX = Math.floor(width / windowSpacing);
            // 縦方向の窓の数
            const windowsY = Math.floor(height / windowSpacing);
            // 奥行き方向の窓の数
            const windowsZ = Math.floor(depth / windowSpacing);
            
            // 前面と背面の窓
            for (let y = 0; y < windowsY; y++) {
                for (let x = 0; x < windowsX; x++) {
                    // 前面の窓
                    const frontWindow = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize),
                        new THREE.MeshLambertMaterial({ color: windowColor, side: THREE.DoubleSide })
                    );
                    frontWindow.position.set(
                        (x * windowSpacing) - (width / 2) + windowSpacing / 2,
                        (y * windowSpacing) + windowSpacing,
                        depth / 2 + 0.1
                    );
                    building.add(frontWindow);
                    
                    // 背面の窓
                    const backWindow = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize),
                        new THREE.MeshLambertMaterial({ color: windowColor, side: THREE.DoubleSide })
                    );
                    backWindow.position.set(
                        (x * windowSpacing) - (width / 2) + windowSpacing / 2,
                        (y * windowSpacing) + windowSpacing,
                        -depth / 2 - 0.1
                    );
                    backWindow.rotation.y = Math.PI;
                    building.add(backWindow);
                }
            }
            
            // 側面の窓
            for (let y = 0; y < windowsY; y++) {
                for (let z = 0; z < windowsZ; z++) {
                    // 左側面の窓
                    const leftWindow = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize),
                        new THREE.MeshLambertMaterial({ color: windowColor, side: THREE.DoubleSide })
                    );
                    leftWindow.position.set(
                        -width / 2 - 0.1,
                        (y * windowSpacing) + windowSpacing,
                        (z * windowSpacing) - (depth / 2) + windowSpacing / 2
                    );
                    leftWindow.rotation.y = -Math.PI / 2;
                    building.add(leftWindow);
                    
                    // 右側面の窓
                    const rightWindow = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize),
                        new THREE.MeshLambertMaterial({ color: windowColor, side: THREE.DoubleSide })
                    );
                    rightWindow.position.set(
                        width / 2 + 0.1,
                        (y * windowSpacing) + windowSpacing,
                        (z * windowSpacing) - (depth / 2) + windowSpacing / 2
                    );
                    rightWindow.rotation.y = Math.PI / 2;
                    building.add(rightWindow);
                }
            }
            
            // 建物を少しランダムに回転
            building.rotation.y = Math.random() * Math.PI * 2;
            
            building.position.set(x, 0, z);
            scene.add(building);
            
            return building;
        }
        
        // 街灯を作成する関数
        function createStreetLight(x, z) {
            const streetLight = new THREE.Group();
            
            // 支柱
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.4, 8, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 4;
            streetLight.add(pole);
            
            // ランプ
            const lampGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const lampMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF99,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.1 // 初期状態では暗い
            });
            const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
            lamp.position.y = 8;
            lamp.name = "streetlamp"; // 名前を設定して後で特定できるようにする
            streetLight.add(lamp);
            
            // ランプカバー
            const coverGeometry = new THREE.CylinderGeometry(1.2, 0.6, 1, 8);
            const coverMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const cover = new THREE.Mesh(coverGeometry, coverMaterial);
            cover.position.y = 7.2;
            streetLight.add(cover);
            
            streetLight.position.set(x, 0, z);
            scene.add(streetLight);
            
            return streetLight;
        }
        
        // コースの周りにランダムに建物と街灯を配置
        function createCityEnvironment() {
            const minDistanceFromRoad = roadWidth + 30; // 道路からの最小距離を拡大
            
            // 周辺環境のランドマークをランダムな主要な位置に配置
            const landmarkPositions = [];
            for (let i = 0; i < 18; i++) { // ランドマークの数を増加
                const angle = Math.random() * Math.PI * 2;
                const distance = 400 + Math.random() * 600; // 距離を拡大
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // 他のランドマークや道路との距離を確認
                let tooClose = false;
                
                // 他のランドマークとの距離チェック
                for (const pos of landmarkPositions) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                    if (dist < 200) { // 最小距離を拡大
                        tooClose = true;
                        break;
                    }
                }
                
                // 道路との距離をチェック
                for (let j = 0; j < detailedPathPoints.length; j += 10) {
                    const point = detailedPathPoints[j];
                    const dist = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(z - point.z, 2));
                    if (dist < minDistanceFromRoad) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    landmarkPositions.push({ x, z });
                    createLondonBuilding(x, z, 6); // ランドマークのサイズを拡大
                }
            }
            
            // 通常の建物をより多く配置
            for (let i = 0; i < 250; i++) { // 建物の数を増加
                const r = 120 + Math.random() * 400; // 距離を拡大
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                // 他の建物や道路との距離を確認
                let tooClose = false;
                
                // ランドマークとの距離チェック
                for (const pos of landmarkPositions) {
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                    if (dist < 80) { // 最小距離を拡大
                        tooClose = true;
                        break;
                    }
                }
                
                // 道路との距離をチェック
                for (let j = 0; j < detailedPathPoints.length; j += 10) {
                    const point = detailedPathPoints[j];
                    const dist = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(z - point.z, 2));
                    if (dist < minDistanceFromRoad) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    const buildingType = Math.floor(Math.random() * 4);
                    createLondonBuilding(x, z, buildingType);
                }
            }
            
            // 街灯を道路沿いに配置
            for (let t = 0; t < 1; t += 0.04) { // 密度を下げる（0.01→0.04）
                const pathPoint = carPath.getPointAt(t);
                const tangent = carPath.getTangentAt(t);
                
                // 道路の横に街灯を交互に配置
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // tの値によって左右を切り替え
                if (Math.round(t * 100) % 2 === 0) {
                    // 右側に配置
                    const lightPosition = new THREE.Vector3().addVectors(
                        pathPoint,
                        normal.clone().multiplyScalar(roadWidth / 2 + 3)
                    );
                    createStreetLight(lightPosition.x, lightPosition.z);
                } else {
                    // 左側に配置
                    const oppositePosition = new THREE.Vector3().addVectors(
                        pathPoint,
                        normal.clone().multiplyScalar(-(roadWidth / 2 + 3))
                    );
                    createStreetLight(oppositePosition.x, oppositePosition.z);
                }
            }
        }
        
        // 都市環境を作成
        createCityEnvironment();
        
        // 詳細な車のモデルを作成
        function createDetailedCar() {
            const car = new THREE.Group();
            
            // 車体ベース（ランボルギーニ風の低く、幅広いウェッジ型）
            const carBodyGeometry = new THREE.BoxGeometry(2.4, 0.4, 4.8);
            const carBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー（ランボルギーニ風）
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.65; // 車体をさらに高くする
            car.add(carBody);
            
            // フロント部分（先端が低くなるように）
            const frontGeometry = new THREE.BoxGeometry(2.2, 0.25, 1.2);
            const frontMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー
            const front = new THREE.Mesh(frontGeometry, frontMaterial);
            front.position.set(0, 0.55, -1.8); // 高さ調整
            car.add(front);
            
            // リア部分（エンジンカバー）
            const rearGeometry = new THREE.BoxGeometry(2.2, 0.25, 2.0);
            const rearMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー
            const rear = new THREE.Mesh(rearGeometry, rearMaterial);
            rear.position.set(0, 0.75, 1.4); // 高さ調整
            car.add(rear);
            
            // サイドフェンダー（タイヤを覆う部分）
            const fenderMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー
            
            // 左前フェンダー
            const leftFrontFenderGeometry = new THREE.BoxGeometry(0.4, 0.4, 1.2);
            const leftFrontFender = new THREE.Mesh(leftFrontFenderGeometry, fenderMaterial);
            leftFrontFender.position.set(-1.1, 0.65, -1.7); // 高さと形状を調整
            car.add(leftFrontFender);
            
            // 右前フェンダー
            const rightFrontFenderGeometry = new THREE.BoxGeometry(0.4, 0.4, 1.2);
            const rightFrontFender = new THREE.Mesh(rightFrontFenderGeometry, fenderMaterial);
            rightFrontFender.position.set(1.1, 0.65, -1.7); // 高さと形状を調整
            car.add(rightFrontFender);
            
            // 左後フェンダー
            const leftRearFenderGeometry = new THREE.BoxGeometry(0.4, 0.4, 1.2);
            const leftRearFender = new THREE.Mesh(leftRearFenderGeometry, fenderMaterial);
            leftRearFender.position.set(-1.2, 0.65, 1.7); // 高さと形状を調整
            car.add(leftRearFender);
            
            // 右後フェンダー
            const rightRearFenderGeometry = new THREE.BoxGeometry(0.4, 0.4, 1.2);
            const rightRearFender = new THREE.Mesh(rightRearFenderGeometry, fenderMaterial);
            rightRearFender.position.set(1.2, 0.65, 1.7); // 高さと形状を調整
            car.add(rightRearFender);
            
            // フロントガラス（低く傾斜をつける）
            const windshieldGeometry = new THREE.BoxGeometry(1.8, 0.35, 1.4);
            const windshieldMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 1.0, -0.4); // 高さ調整
            // フロントガラスを傾ける
            windshield.rotation.x = Math.PI * 0.08;
            car.add(windshield);
            
            // リアウィング（大型）
            const spoilerGeometry = new THREE.BoxGeometry(2.2, 0.1, 0.6);
            const spoilerMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const spoiler = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
            spoiler.position.set(0, 1.15, 2.2); // 高さ調整
            car.add(spoiler);
            
            // スポイラーの支柱
            const pillarGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            
            const pillarLeft = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillarLeft.position.set(0.8, 0.95, 2.2); // 高さ調整
            car.add(pillarLeft);
            
            const pillarRight = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillarRight.position.set(-0.8, 0.95, 2.2); // 高さ調整
            car.add(pillarRight);
            
            // ヘッドライト
            const headlightGeometry = new THREE.BoxGeometry(0.4, 0.1, 0.1);
            const headlightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFCC,
                emissiveIntensity: 0.5
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            leftHeadlight.position.set(0.7, 0.65, -2.35); // 高さ調整
            car.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
            rightHeadlight.position.set(-0.7, 0.65, -2.35); // 高さ調整
            car.add(rightHeadlight);
            
            // テールライト
            const taillightGeometry = new THREE.BoxGeometry(0.8, 0.1, 0.1);
            const taillightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            });
            
            const taillight = new THREE.Mesh(taillightGeometry, taillightMaterial);
            taillight.position.set(0, 0.85, 2.35); // 高さ調整
            car.add(taillight);
            
            // サイドエアインテーク（ランボルギーニの特徴的なエアインテーク）
            const leftIntakeGeometry = new THREE.BoxGeometry(0.1, 0.3, 1.0);
            const intakeMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const leftIntake = new THREE.Mesh(leftIntakeGeometry, intakeMaterial);
            leftIntake.position.set(1.15, 0.75, 0.5); // 高さ調整
            car.add(leftIntake);
            
            const rightIntakeGeometry = new THREE.BoxGeometry(0.1, 0.3, 1.0);
            const rightIntake = new THREE.Mesh(rightIntakeGeometry, intakeMaterial);
            rightIntake.position.set(-1.15, 0.75, 0.5); // 高さ調整
            car.add(rightIntake);
            
            // ドア（シザードア風）
            const doorGeometry = new THREE.BoxGeometry(0.1, 0.3, 1.8);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー
            
            const leftDoor = new THREE.Mesh(doorGeometry, doorMaterial);
            leftDoor.position.set(1.15, 0.85, -0.5); // 高さ調整
            car.add(leftDoor);
            
            const rightDoor = new THREE.Mesh(doorGeometry, doorMaterial);
            rightDoor.position.set(-1.15, 0.85, -0.5); // 高さ調整
            car.add(rightDoor);
            
            // タイヤを作成する関数
            function createWheel(x, z) {
                const wheelGroup = new THREE.Group();
                
                // タイヤ本体
                const wheelGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.35, 16); // さらに小さく
                const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheelGroup.add(wheel);
                
                // ホイール部分
                const hubGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.36, 10);
                const hubMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 }); // シルバー
                const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                hub.rotation.z = Math.PI / 2;
                wheelGroup.add(hub);
                
                // ホイールのセンターキャップ
                const capGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.37, 8);
                const capMaterial = new THREE.MeshLambertMaterial({ color: 0x0052CC }); // ブルー（車体と同じ色）
                const cap = new THREE.Mesh(capGeometry, capMaterial);
                cap.rotation.z = Math.PI / 2;
                wheelGroup.add(cap);
                
                // スポークを追加
                for (let i = 0; i < 5; i++) {
                    const spokeGeometry = new THREE.BoxGeometry(0.05, 0.02, 0.3);
                    const spokeMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
                    spoke.rotation.z = Math.PI / 2;
                    spoke.rotation.x = (Math.PI * 2 / 5) * i;
                    spoke.position.y = 0;
                    wheelGroup.add(spoke);
                }
                
                wheelGroup.position.set(x, 0.4, z); // タイヤの位置をさらに下げる
                car.add(wheelGroup);
                
                return { wheel, wheelGroup };
            }
            
            // 4つのタイヤを作成（前輪は若干内側に、後輪は外側に）
            const frontLeftWheel = createWheel(-1, -1.7);
            const frontRightWheel = createWheel(1, -1.7);
            const rearLeftWheel = createWheel(-1.1, 1.7);
            const rearRightWheel = createWheel(1.1, 1.7);
            
            const wheels = [
                frontLeftWheel.wheel,
                frontRightWheel.wheel,
                rearLeftWheel.wheel,
                rearRightWheel.wheel
            ];
            
            const wheelGroups = [
                frontLeftWheel.wheelGroup,
                frontRightWheel.wheelGroup,
                rearLeftWheel.wheelGroup,
                rearRightWheel.wheelGroup
            ];
            
            // 車の向きベクトル（常に上方向）
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // 車の初期位置（スタート地点）
            car.position.copy(carPath.getPointAt(0));
            car.position.y = 1.0; // 地面からの高さをさらに上げる
            
            // 車の初期方向
            const initialTangent = carPath.getTangentAt(0);
            const initialDirection = new THREE.Vector3(initialTangent.x, 0, initialTangent.z).normalize();
            
            // 車の向きを設定（Y軸は常に上）
            const initialTarget = new THREE.Vector3().addVectors(car.position, initialDirection);
            car.lookAt(initialTarget);
            
            scene.add(car);
            
            return { car, wheels, wheelGroups, upVector };
        }
        
        const { car, wheels, wheelGroups, upVector } = createDetailedCar();
        
        log("車の作成完了");
        
        // カメラモード（0: 俯瞰, 1: 追従, 2: 車載, 3: 斜め視点）
        let cameraMode = 3; // デフォルトを斜め視点モードに設定
        
        // カメラ位置の初期設定（斜め視点向け）
        camera.position.set(100, 70, 90); // 斜め視点の初期位置
        camera.lookAt(car.position);
        
        // 車の位置パラメータ
        let carPosition = 0; // パス上の位置（0から1）
        let carSpeed = 0.5;  // 車の速度（0.3から0.5に上げる）
        let targetSpeed = 0.5; // 目標速度（0.3から0.5に上げる）
        
        // 速度の範囲を設定（60km/h～200km/h）
        const MIN_SPEED = 0.4; // 最低速度を上げる（0.2から0.4に）
        const MAX_SPEED = 1.0; // 最高速度を上げる（0.67から1.0に）
        const ACCELERATION_RATE = 0.01; // 加速率を上げる（0.008から0.01に）
        const DECELERATION_RATE = 0.02; // 減速率も上げる（0.015から0.02に）
        
        // 前回の位置と回転を保存（スムージング用）
        let lastCarPosition = new THREE.Vector3();
        let lastCarRotation = new THREE.Quaternion();
        let lastCarUp = new THREE.Vector3(0, 1, 0);
        // 前回の傾き角度を保存（滑らかな変化のため）
        let lastTiltAngle = 0;
        
        // 初期位置設定
        lastCarPosition.copy(car.position);
        lastCarRotation.copy(car.quaternion);
        
        // カメラ切り替え
        window.addEventListener('keydown', (e) => {
            if (e.key === '1' || e.key === '１') {
                cameraMode = 0; // 俯瞰
                log("カメラモード: 俯瞰");
            } else if (e.key === '2' || e.key === '２') {
                cameraMode = 1; // 追従
                log("カメラモード: 追従");
            } else if (e.key === '3' || e.key === '３') {
                cameraMode = 2; // 車載
                log("カメラモード: 車載");
            } else if (e.key === '4' || e.key === '４') {
                cameraMode = 3; // 斜め上視点
                log("カメラモード: 斜め上視点");
            }
        });
        
        // 情報表示を更新
        function updateInfo() {
            const info = document.getElementById('info');
            const cameraModeText = ['俯瞰', '追従', '車載', '斜め上視点'][cameraMode];
            
            // 時間の表示を整形
            const hours = Math.floor(gameTime);
            const minutes = Math.floor((gameTime % 1) * 60);
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            
            // 時間帯のテキスト
            let timeOfDay;
            if (gameTime >= 5 && gameTime < 10) {
                timeOfDay = "朝";
            } else if (gameTime >= 10 && gameTime < 17) {
                timeOfDay = "昼";
            } else if (gameTime >= 17 && gameTime < 19) {
                timeOfDay = "夕方";
            } else {
                timeOfDay = "夜";
            }
            
            // 速度をkm/hに変換
            const speedKmph = Math.round(carSpeed * 180); // 係数を200から180に下げて最高速度を180km/hに調整
            
            info.innerHTML = `エンドレスカー - ロンドン市街地コース<br>
            時間: ${timeString} (${timeOfDay})<br>
            速度: ${speedKmph} km/h<br>
            カメラ: ${cameraModeText}<br>
            「1,2,3,4」キーでカメラ切替`;
        }
        
        // 多点サンプリングで曲率を計算（より安定した値を得るため）
        function calculateCurvature(t, samplePoints = 15, sampleDistance = 0.005) {
            const angles = [];
            
            // 複数のサンプル点で角度を計算し平均を取る
            for (let i = 0; i < samplePoints - 1; i++) {
                const currentPos = (t + i * sampleDistance) % 1;
                const nextPos = (currentPos + sampleDistance) % 1;
                const nextNextPos = (nextPos + sampleDistance) % 1;
                
                const point = carPath.getPointAt(currentPos);
                const nextPoint = carPath.getPointAt(nextPos);
                const nextNextPoint = carPath.getPointAt(nextNextPos);
                
                const v1 = new THREE.Vector2(nextPoint.x - point.x, nextPoint.z - point.z).normalize();
                const v2 = new THREE.Vector2(nextNextPoint.x - nextPoint.x, nextNextPoint.z - nextPoint.z).normalize();
                
                // 2つのベクトル間の角度
                const angle = Math.acos(Math.min(1, Math.max(-1, v1.dot(v2))));
                angles.push(angle);
            }
            
            // 角度の平均値を計算
            const avgAngle = angles.reduce((sum, angle) => sum + angle, 0) / angles.length;
            
            // 曲がる方向の判定（中央のサンプルポイントで判定）
            const middleIndex = Math.floor(samplePoints / 2);
            const currentPos = (t + middleIndex * sampleDistance) % 1;
            const nextPos = (currentPos + sampleDistance) % 1;
            const nextNextPos = (nextPos + sampleDistance) % 1;
            
            const pointStart = carPath.getPointAt(currentPos);
            const pointNext = carPath.getPointAt(nextPos);
            const pointNextNext = carPath.getPointAt(nextNextPos);
            
            const vec1 = new THREE.Vector2(pointNext.x - pointStart.x, pointNext.z - pointStart.z).normalize();
            const vec2 = new THREE.Vector2(pointNextNext.x - pointNext.x, pointNextNext.z - pointNext.z).normalize();
            
            // 曲がり方向を判定（外積）
            const crossProduct = vec1.x * vec2.y - vec1.y * vec2.x;
            const tiltDirection = Math.sign(crossProduct);
            
            return { angle: avgAngle, direction: tiltDirection };
        }
        
        // 前方のカーブを予測する関数
        function predictUpcomingCurve(currentPosition, lookAheadDistance = 0.05) {
            // 現在の位置から少し先の位置でのカーブ強度を取得
            const upcomingPos = (currentPosition + lookAheadDistance) % 1;
            const curvatureData = calculateCurvature(upcomingPos);
            return curvatureData.angle;
        }
        
        // 速度を更新する関数（スローインファーストアウト）
        function updateSpeed() {
            // 現在のカーブ強度を取得
            const currentCurvature = calculateCurvature(carPosition).angle;
            
            // 前方のカーブ強度を予測
            const upcomingCurvature = predictUpcomingCurve(carPosition, 0.05);
            
            // カーブ強度に基づいて目標速度を計算
            // 曲率が大きいほど速度を下げる
            const curvatureThreshold = 0.03; // カーブ検出の閾値（少し下げてより早くカーブを検知）
            
            if (upcomingCurvature > curvatureThreshold) {
                // カーブが近づいている場合（スローイン）
                // カーブ強度に応じて目標速度を下げる
                const curveFactor = Math.min(1, upcomingCurvature / 0.08); // カーブ強度を0-1の範囲に正規化（値を小さくしてより敏感に）
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7); // べき乗を使って急激な減速を実現
            } else if (currentCurvature > curvatureThreshold / 2) {
                // カーブ中の場合
                const curveFactor = Math.min(1, currentCurvature / 0.08);
                targetSpeed = MAX_SPEED - (MAX_SPEED - MIN_SPEED) * Math.pow(curveFactor, 0.7);
            } else {
                // カーブを抜けた場合（ファーストアウト）
                targetSpeed = MAX_SPEED;
            }
            
            // 下り坂では少し加速、上り坂では少し減速
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const point = carPath.getPointAt(carPosition);
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // 傾斜を計算
            const slope = Math.atan2(nextPoint.y - prevPoint.y, 
                Math.sqrt(Math.pow(nextPoint.x - prevPoint.x, 2) + Math.pow(nextPoint.z - prevPoint.z, 2)));
            
            // 傾斜に応じて速度を調整（下り坂で加速、上り坂で減速）
            if (slope < -0.01) {
                // 下り坂
                targetSpeed *= (1.0 - slope); // 傾斜が大きいほど加速
            } else if (slope > 0.01) {
                // 上り坂
                targetSpeed *= (1.0 - slope * 0.5); // 傾斜が大きいほど減速
            }
            
            // 現在の速度を目標速度に徐々に近づける（加速・減速）
            if (carSpeed < targetSpeed) {
                // 加速（ゆっくり）
                carSpeed = Math.min(targetSpeed, carSpeed + ACCELERATION_RATE);
            } else if (carSpeed > targetSpeed) {
                // 減速（素早く）
                carSpeed = Math.max(targetSpeed, carSpeed - DECELERATION_RATE);
            }
        }
        
        // 前フレームと現在フレームの値を補間する関数
        function smoothValue(current, last, factor) {
            return last * (1 - factor) + current * factor;
        }
        
        // より滑らかなEasing補間を行う関数（2次のベジェ曲線に基づくなめらかな補間）
        function smootherValue(target, current, speed, deltaTime = 1) {
            // デフォルトのデルタタイムは1フレーム分（60fpsを想定）
            const delta = (target - current);
            
            // 非常に小さな変化は無視する（ノイズによる微小変動を防止）
            if (Math.abs(delta) < 0.001) {
                return current;
            }
            
            // より自然な動きのために3次のベジェ曲線のイージングを適用
            // これにより、目標値に近づくほど徐々に減速する効果が得られる
            const easeFactor = Math.min(1.0, speed * deltaTime);
            
            // 改良されたスムーズステップ関数（より高次の関数で滑らかさを向上）
            const t = Math.max(0, Math.min(1, easeFactor));
            const easeFactorCubic = t * t * (3 - 2 * t);
            const easeFactorQuintic = t * t * t * (t * (t * 6 - 15) + 10); // より滑らかな5次関数
            
            // 二つの関数をブレンド（大きな変化には5次関数、小さな変化には3次関数を適用）
            const blendFactor = Math.min(1.0, Math.abs(delta) / 0.5);
            const finalEaseFactor = easeFactorCubic * (1 - blendFactor) + easeFactorQuintic * blendFactor;
            
            return current + delta * finalEaseFactor;
        }
        
        // 過去フレームの時間を記録する変数
        let lastFrameTime = Date.now();
        
        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            
            // フレーム間のデルタタイムを計算
            const currentFrameTime = Date.now();
            const deltaTime = (currentFrameTime - lastFrameTime) / 16.67; // 60fpsを基準にした値
            lastFrameTime = currentFrameTime;
            
            // 時間の更新と昼夜サイクルの適用
            updateDayNightCycle();
            
            // 速度を更新（カーブに応じて）
            updateSpeed();
            
            // 車の位置を更新
            carPosition += carSpeed * 0.001;
            if (carPosition >= 1) carPosition -= 1;
            
            // 道路上の位置を厳密に取得
            const point = carPath.getPointAt(carPosition);
            
            // パスの接線ベクトルを取得（進行方向）
            const tangent = carPath.getTangentAt(carPosition).normalize();
            // XZ平面上の接線ベクトル（高さを無視）
            const flatTangent = new THREE.Vector3(tangent.x, 0, tangent.z).normalize();
            
            // 次のポイントと前のポイントを取得して傾斜を計算（上り下りの計算用）
            const nextPos = (carPosition + 0.01) % 1;
            const prevPos = (carPosition - 0.01 + 1) % 1;
            const nextPoint = carPath.getPointAt(nextPos);
            const prevPoint = carPath.getPointAt(prevPos);
            
            // 前後方向の傾斜角を計算（Y軸方向の変化から）
            const forwardSlope = Math.atan2(nextPoint.y - point.y, 
                Math.sqrt(Math.pow(nextPoint.x - point.x, 2) + Math.pow(nextPoint.z - point.z, 2)));
            
            // サンプリング範囲を拡大して、より正確な傾斜を取得
            // 少し広い範囲で前後の傾斜を計算してより安定させる
            const farNextPos = (carPosition + 0.02) % 1;
            const farPrevPos = (carPosition - 0.02 + 1) % 1;
            const farNextPoint = carPath.getPointAt(farNextPos);
            const farPrevPoint = carPath.getPointAt(farPrevPos);
            
            // 広い範囲での前後方向の傾斜角を計算（急な坂での対応向上）
            const farForwardSlope = Math.atan2(farNextPoint.y - farPrevPoint.y, 
                Math.sqrt(Math.pow(farNextPoint.x - farPrevPoint.x, 2) + Math.pow(farNextPoint.z - farPrevPoint.z, 2)));
            
            // 近距離と遠距離の傾斜を組み合わせて、より安定した傾斜値を得る
            const combinedSlope = (forwardSlope * 0.7 + farForwardSlope * 0.3);
            
            // 曲率を計算
            const curvatureData = calculateCurvature(carPosition);
            const curveAngle = curvatureData.angle;
            const curveTiltDirection = curvatureData.direction;
            
            // ノイズフィルタリング - 非常に小さな曲率変化を無視
            // これにより、わずかな道路の揺れなどによる不要な反応を防止
            const minCurvatureThreshold = 0.005; // 最小閾値以下は真っ直ぐとみなす
            const filteredCurveAngle = Math.abs(curveAngle) < minCurvatureThreshold ? 0 : curveAngle;
            const filteredDirection = filteredCurveAngle === 0 ? 0 : curveTiltDirection;
            
            // 車の高さは道路の高さに合わせる
            const carHeight = point.y + 0.3; // 道路の高さに対して少しオフセット
            
            // スピードファクターを先に計算（他の場所で使用するため）
            const speedFactor = Math.min(1.0, carSpeed / 0.7); // 速度による調整係数
            
            // ---------- 車の回転方向の計算（先に行う） ----------
            
            // 1. 進行方向ベクトル（常にXZ平面に平行）
            const forwardVector = flatTangent;
            
            // 2. 上向きベクトル（常に世界座標のY軸方向）
            const upVector = new THREE.Vector3(0, 1, 0);
            
            // 3. 右向きベクトル（進行方向と上向きの外積）
            const rightVector = new THREE.Vector3().crossVectors(forwardVector, upVector).normalize();
            
            // 4. 最終的な上向きベクトル（右向きと進行方向の外積で再計算、厳密に直交させる）
            const correctedUpVector = new THREE.Vector3().crossVectors(rightVector, forwardVector).normalize();
            
            // ---------- アウトインアウト走法のための詳細な路線計算 ----------
            
            // 道路の幅に応じてオフセット量を調整（より大きなオフセットに調整）
            const pathOffsetAmount = 4.0;
            
            // 曲率をより正確に計算するためのパラメータ
            const detailedSamplePoints = 20;
            const detailedSampleDistance = 0.004;
            
            // コーナー検出のための複数のポイントをサンプリング
            const lookAheadDistances = [0.15, 0.1, 0.05, 0.03];
            const lookBehindDistances = [0.05, 0.02];
            
            // 各距離でのカーブデータを取得（フィルタリングを適用）
            const filteredAheadCurveData = lookAheadDistances.map(dist => {
                const data = calculateCurvature((carPosition + dist) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            const filteredBehindCurveData = lookBehindDistances.map(dist => {
                const data = calculateCurvature((carPosition - dist + 1) % 1, detailedSamplePoints, detailedSampleDistance);
                return {
                    angle: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.angle,
                    direction: Math.abs(data.angle) < minCurvatureThreshold ? 0 : data.direction
                };
            });
            
            // フィルタリングされた曲率を使用
            const filteredAheadAngles = filteredAheadCurveData.map(data => data.angle);
            const filteredBehindAngles = filteredBehindCurveData.map(data => data.angle);
            
            // 最大の曲率とその方向を特定
            const maxAheadAngle = Math.max(...filteredAheadAngles);
            const maxAheadIndex = filteredAheadAngles.indexOf(maxAheadAngle);
            const maxAheadDirection = filteredAheadCurveData[maxAheadIndex].direction;
            
            const maxBehindAngle = Math.max(...filteredBehindAngles);
            const maxBehindIndex = filteredBehindAngles.indexOf(maxBehindAngle);
            const maxBehindDirection = filteredBehindCurveData[maxBehindIndex].direction;
            
            // オフセット計算用の変数の初期化
            if (typeof lastPathOffset === 'undefined') {
                window.lastPathOffset = 0;
                window.lastCornerState = 'straight';
                window.cornerState = 'straight';
                window.stateChangeTime = 0;
                window.cornerHistory = []; 
                window.targetPathOffset = 0;
                window.cornerDetectionHistory = [];
                window.directionHistory = [];
                window.intermediateOffset = 0;
            }
            
            // 現在の曲率を履歴に追加（最新の30サンプルを保持）
            if (!Array.isArray(window.cornerHistory)) {
                window.cornerHistory = [];
            }
            window.cornerHistory.push(filteredCurveAngle);
            if (window.cornerHistory.length > 30) {
                window.cornerHistory.shift();
            }
            
            // 曲率履歴の平均を計算（ノイズを除去）- 重み付き平均を導入して最新の値をより重視
            let totalWeight = 0;
            let weightedSum = 0;
            for (let i = 0; i < window.cornerHistory.length; i++) {
                // 新しいデータほど重みを大きくする（最新のデータが最も重要）
                const weight = Math.pow(1.1, i);
                weightedSum += window.cornerHistory[window.cornerHistory.length - 1 - i] * weight;
                totalWeight += weight;
            }
            const avgCurveAngle = weightedSum / totalWeight;
            
            // 方向の一貫性確認のため、方向履歴も保持
            if (!Array.isArray(window.directionHistory)) {
                window.directionHistory = [];
            }
            window.directionHistory.push(filteredDirection); // フィルタリングされた方向を使用
            if (window.directionHistory.length > 20) {
                window.directionHistory.shift();
            }
            
            // 方向の多数決を取る（最頻値を採用）
            const directionCounts = {};
            let maxCount = 0;
            let dominantDirection = 0;
            
            window.directionHistory.forEach(dir => {
                directionCounts[dir] = (directionCounts[dir] || 0) + 1;
                if (directionCounts[dir] > maxCount) {
                    maxCount = directionCounts[dir];
                    dominantDirection = dir;
                }
            });
            
            // カーブの方向として支配的な方向を使用
            const stableCurveTiltDirection = dominantDirection;
            
            // コーナー検出用のモデルを構築
            // 各位置の曲率情報を元に、コーナーの状態を判断するための特徴量を作成
            const cornerDetectionFeatures = {
                current: avgCurveAngle,               // 現在地点の曲率（平均化済み）
                ahead: filteredAheadAngles,           // 複数の先読み地点の曲率（フィルタリング済み）
                behind: filteredBehindAngles,         // 複数の後読み地点の曲率（フィルタリング済み）
                maxAhead: maxAheadAngle,              // 最大の先読み曲率
                maxBehind: maxBehindAngle,            // 最大の後読み曲率
                direction: stableCurveTiltDirection,  // 安定化された現在の曲がり方向
                aheadDirection: maxAheadDirection,    // 先のカーブの曲がり方向
                behindDirection: maxBehindDirection,  // 後ろのカーブの曲がり方向
                speed: carSpeed                       // 現在の速度
            };
            
            // コーナー検出情報を履歴に追加（状態変更の安定性向上のため）
            if (!Array.isArray(window.cornerDetectionHistory)) {
                window.cornerDetectionHistory = [];
            }
            window.cornerDetectionHistory.push(cornerDetectionFeatures);
            if (window.cornerDetectionHistory.length > 15) {
                window.cornerDetectionHistory.shift();
            }
            
            // 曲率の急激な変化を検出するための閾値
            const curvatureThreshold = 0.015;  // 通常のカーブ検出閾値
            const entryThreshold = 0.014;      // コーナー進入検出閾値
            const apexThreshold = 0.018;       // コーナー頂点検出閾値
            const exitThreshold = 0.015;       // コーナー出口検出閾値
            const hysteresis = 0.008;          // ヒステリシス
            
            // 状態変更の時間制限（急激な状態変更を防止）- デルタタイムに応じて調整
            const baseStateChangeDuration = 800; // 基本の最小状態変更間隔（ミリ秒）
            const speedBasedDuration = baseStateChangeDuration * (1.0 + speedFactor * 0.5); // 高速時はより長い間隔
            const minStateChangeDuration = Math.min(1200, speedBasedDuration); // 最大1.2秒まで
            
            const currentTime = Date.now();
            const canChangeState = (currentTime - window.stateChangeTime) > minStateChangeDuration;
            
            // コーナー検出履歴の安定性確認（必要なフレーム数を増やして安定性向上）
            const isStableAheadCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxAhead > entryThreshold).length >= 5;
            
            const isStableCurrentCurve = window.cornerDetectionHistory.filter(
                hist => hist.current > apexThreshold).length >= 5;
            
            const isStableBehindCurve = window.cornerDetectionHistory.filter(
                hist => hist.maxBehind > exitThreshold).length >= 5;
            
            // 連続したフレームでの同一方向性の確認（方向の一貫性をチェック）
            const aheadDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.aheadDirection === arr[i-1].aheadDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            const behindDirectionConsistency = window.cornerDetectionHistory.filter(
                (hist, i, arr) => i > 0 && hist.behindDirection === arr[i-1].behindDirection).length / 
                Math.max(1, window.cornerDetectionHistory.length - 1);
            
            // 方向の一貫性が高い場合のみ状態遷移を許可（方向が安定している場合のみ）
            const directionStability = Math.min(aheadDirectionConsistency, behindDirectionConsistency);
            const hasStableDirection = directionStability > 0.7;
            
            // コーナー状態の遷移判定を安定性を考慮して行う
            let newCornerState = window.cornerState;
            
            if (canChangeState && hasStableDirection) {
                // コーナー進入検出（先の安定したカーブを検出）
                if (maxAheadAngle > entryThreshold && 
                    maxAheadAngle > (avgCurveAngle + hysteresis) &&
                    maxAheadDirection !== 0 && // 方向が0でない場合のみ（有効なカーブ方向）
                    isStableAheadCurve && 
                    window.cornerState !== 'entry') {
                    
                    newCornerState = 'entry';
                    window.stateChangeTime = currentTime;
                } 
                // コーナー中間（現在地点で大きな曲率を検出）
                else if (avgCurveAngle > apexThreshold && 
                        stableCurveTiltDirection !== 0 && // 有効なカーブ方向
                        isStableCurrentCurve &&
                        window.cornerState !== 'apex' && 
                        (window.cornerState === 'entry' || maxAheadAngle > entryThreshold)) {
                    
                    newCornerState = 'apex';
                    window.stateChangeTime = currentTime;
                } 
                // コーナー出口（後方の安定したカーブを検出）
                else if (maxBehindAngle > exitThreshold && 
                        maxBehindAngle > (avgCurveAngle + hysteresis) &&
                        maxBehindDirection !== 0 && // 有効なカーブ方向
                        isStableBehindCurve &&
                        window.cornerState === 'apex') {
                    
                    newCornerState = 'exit';
                    window.stateChangeTime = currentTime;
                } 
                // 直線区間（曲率が十分に小さくなった場合）
                else if (avgCurveAngle < (curvatureThreshold - hysteresis * 2) && 
                        maxBehindAngle < (exitThreshold - hysteresis) &&
                        maxAheadAngle < (entryThreshold - hysteresis) &&
                        window.cornerState === 'exit') {
                    
                    newCornerState = 'straight';
                    window.stateChangeTime = currentTime;
                }
            }
            
            // 状態が変更された場合、前の状態を記録
            if (newCornerState !== window.cornerState) {
                window.lastCornerState = window.cornerState;
                window.cornerState = newCornerState;
                console.log("コーナー状態変更: " + window.cornerState); // デバッグ用
            }
            
            // コーナーの曲がり方向を決定（より安定した方向を使用）
            // 安定化された方向を使用
            const cornerTiltDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // 各コーナー状態に基づいて目標オフセット値を設定
            let targetOffset = 0;
            
            // コーナー状態に基づいてオフセットを計算
            switch (window.cornerState) {
                case 'entry':
                    // 進入時はアウト側から入る（より大きなオフセット）
                    targetOffset = -pathOffsetAmount * 1.5 * cornerTiltDirection;
                    // 曲率に応じてオフセット量を調整（曲率に対する感度向上）
                    targetOffset *= Math.min(1.0, Math.pow(maxAheadAngle / 0.04, 0.7));
                    break;
                    
                case 'apex':
                    // 頂点ではイン側に寄せる（より強くインを攻める）
                    targetOffset = pathOffsetAmount * 1.2 * cornerTiltDirection;
                    // 曲率に応じて調整（より強めにインを攻める）
                    targetOffset *= Math.min(1.0, Math.pow(avgCurveAngle / 0.04, 0.6));
                    break;
                    
                case 'exit':
                    // 出口では再びアウト側に大きく膨らむ
                    targetOffset = -pathOffsetAmount * 1.8 * cornerTiltDirection;
                    // 曲率に応じて調整（より敏感に反応）
                    targetOffset *= Math.min(1.0, Math.pow(maxBehindAngle / 0.04, 0.7));
                    break;
                    
                case 'straight':
                default:
                    // 直線では少し中央から外側に寄せる（より自然なドライビングライン）
                    targetOffset = 0.5 * (window.lastCornerState === 'exit' ? -cornerTiltDirection : 0);
                    break;
            }
            
            // スピードが速いほどアウトを大きく取る（高速コーナリングの挙動向上）
            const speedFactorForOffset = speedFactor * 0.7; // 速度による追加オフセット（より強調）
            targetOffset *= (1 + speedFactorForOffset);
            
            // 道路からはみ出さないようにオフセットを制限
            // 車の幅を考慮した安全マージン（車の幅の半分+余裕）
            window.carWidth = 2.5; // 車の幅の概算
            window.safetyMargin = window.carWidth / 2 + 0.5; // 安全マージン
            
            // 道路の有効幅（道路の端からの安全マージンを引いた値）
            window.effectiveRoadHalfWidth = (roadWidth / 2) - window.safetyMargin;
            
            // オフセットが道路の有効幅を超えないように制限
            targetOffset = Math.max(-window.effectiveRoadHalfWidth, Math.min(window.effectiveRoadHalfWidth, targetOffset));
            
            window.targetPathOffset = targetOffset;
            
            // 実際のオフセット値を算出（より滑らかな補間）
            // 改良されたEasing補間関数を使用して自然な動きを実現
            const baseTransitionSpeed = 0.05; // 基本トランジション速度（より小さくして安定性向上）
            const speedAdjustedTransition = baseTransitionSpeed * (1.0 - speedFactor * 0.4); // 高速時は遅い変化
            const transitionSpeed = Math.max(0.02, speedAdjustedTransition); // 最小値を設定
            
            // Easing関数による二重スムージング - 非常に滑らかな動きを実現
            // 一時的な中間値を計算してからさらにスムージング
            if (typeof window.intermediateOffset === 'undefined') {
                window.intermediateOffset = window.lastPathOffset;
            }
            
            // 二段階のスムージングで非常に滑らかな動きを実現
            window.intermediateOffset = smootherValue(window.targetPathOffset, window.intermediateOffset, transitionSpeed * 1.5, deltaTime);
            const pathOffset = smootherValue(window.intermediateOffset, window.lastPathOffset, transitionSpeed, deltaTime);
            window.lastPathOffset = pathOffset;
            
            // 道路の有効幅はすでに計算済み（window.effectiveRoadHalfWidthを使用）
            
            // 接線方向に対して垂直なオフセットベクトルを計算
            const offsetVector = rightVector.clone().multiplyScalar(pathOffset);
            
            // 道路の端に近づいているかチェック
            const edgeProximityThreshold = 0.8; // 道路端からの距離が安全マージンの何倍以下で警告するか
            const edgeProximity = Math.abs(pathOffset) / window.effectiveRoadHalfWidth;
            
            // 初回実行時に既存の警告要素を削除（警告表示機能を無効化）
            if (window.edgeWarningElement && !window.edgeWarningRemovalAttempted) {
                if (window.edgeWarningElement.parentNode) {
                    window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                }
                window.edgeWarningElement = null;
                window.edgeWarningRemovalAttempted = true;
            }
            
            // 道路端に近づいている場合、自動補正と警告
            if (edgeProximity > edgeProximityThreshold) {
                // 道路端に近いほど強く中央方向への補正力を適用
                const correctionFactor = Math.pow((edgeProximity - edgeProximityThreshold) / (1 - edgeProximityThreshold), 2) * 0.3;
                const correctionDirection = pathOffset > 0 ? -1 : 1;
                const correctionVector = rightVector.clone().multiplyScalar(correctionFactor * correctionDirection);
                
                // 補正ベクトルを追加
                offsetVector.add(correctionVector);
                
                // 警告メッセージ表示部分を削除（ユーザーリクエストにより）
            } else if (window.edgeWarningElement) {
                // 既存の警告要素があれば非表示にして削除
                window.edgeWarningElement.style.opacity = '0';
                
                // 一定時間後に要素を完全に削除
                setTimeout(() => {
                    if (window.edgeWarningElement && window.edgeWarningElement.parentNode) {
                        window.edgeWarningElement.parentNode.removeChild(window.edgeWarningElement);
                        window.edgeWarningElement = null;
                    }
                }, 500);
            }
            
            // 車の基本位置を取得
            const basePosition = point.clone();
            
            // オフセットを適用
            const offsetPosition = basePosition.add(offsetVector);
            
            // 車の位置を設定
            car.position.set(offsetPosition.x, carHeight, offsetPosition.z);
            
            // コーナーの状態をデバッグ表示
            const cornerStateEmoji = {
                'straight': '→',
                'entry': '↘',
                'apex': '↓',
                'exit': '↗'
            };
            const cornerEmoji = cornerStateEmoji[window.cornerState] || '→';
            
            // スタイルカラーをコーナー状態に応じて変更
            const cornerStateColor = {
                'straight': 'white',
                'entry': 'yellow',
                'apex': 'red',
                'exit': 'green'
            };
            const cornerColor = cornerStateColor[window.cornerState] || 'white';
            
            // 既存の情報表示に追加（スタイルを適用）
            const infoElement = document.getElementById('info');
            const originalContent = infoElement.innerHTML;
            
            // <br>タグで分割し、最初の4行のみを保持
            const lines = originalContent.split('<br>');
            const mainInfo = lines.slice(0, 4).join('<br>');
            
            // 新しいコーナー情報を追加
            infoElement.innerHTML = `${mainInfo}<br>
            <span style="color:${cornerColor}">${cornerEmoji} ${window.cornerState.toUpperCase()}: ${Math.abs(pathOffset).toFixed(1)}</span>`;
            
            // ---------- 回転計算の残りの部分 ----------
            
            // 5. 回転行列を作成（3つの直交ベクトルから）
            const rotationMatrix = new THREE.Matrix4().makeBasis(
                rightVector,
                correctedUpVector,
                forwardVector.clone().negate() // THREE.jsの車モデルはZ-方向が前方なので反転
            );
            
            // 6. 回転行列からクォータニオンに変換
            const targetRotation = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
            
            // 7. 回転を直接適用（スムージングなし - 安定性優先）
            car.quaternion.copy(targetRotation);
            
            // 8. 上り下りの傾斜を反映（進行方向に合わせてピッチ角を適用）
            // combinedSlopeを使って車を傾ける（値を調整して傾きを強調）
            // マイナス符号を除去して傾斜の適用を正しく修正
            car.rotateX(combinedSlope * 1.5);
            
            // 9. カーブに応じた微小な横傾斜（Z軸回転）
            // 非常に小さな値に制限し、回転行列に影響を与えないようにする
            const maxTilt = 0.005; // 約0.3度に制限
            const tiltFactor = Math.min(maxTilt, curveAngle * carSpeed * 0.02);
            
            // 横傾斜を別途適用（既存の回転に小さな修正として追加）
            car.rotateZ(-tiltFactor * curveTiltDirection);
            
            // タイヤの回転と位置調整
            const wheelRotationSpeed = carSpeed * 0.3; // 回転速度係数を0.2から0.3に上げる
            
            // フロントタイヤのステアリング角度計算
            // 曲率が大きいほど、大きくステアリングする
            // curvatureDataから曲率を取得、方向も考慮
            const baseSteeringMultiplier = 3.5; // 基本ステアリング係数
            
            // コーナーの状態に応じてステアリング係数を調整（より自然な挙動）
            let steeringMultiplier = baseSteeringMultiplier;
            
            // コーナー進入時はより積極的にステアリング、頂点では維持、出口では徐々に戻す
            if (window.cornerState === 'entry') {
                // コーナー進入時は早めに大きくステアリング
                steeringMultiplier = baseSteeringMultiplier * 1.2;
            } else if (window.cornerState === 'apex') {
                // コーナー頂点では標準的なステアリング
                steeringMultiplier = baseSteeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // コーナー出口では徐々にステアリングを戻す
                steeringMultiplier = baseSteeringMultiplier * 0.8;
            }
            
            // スピードに応じた追加調整（高速時はより積極的にステアリング）
            steeringMultiplier *= (1 + speedFactor * 0.3);
            
            // 最終的なステアリング角度を計算
            // ステアリングの方向を修正
            // THREE.jsの座標系とステアリングの方向を正しく対応させる
            
            // コーナーの状態と方向に基づいてステアリング角度を計算
            let steeringAngle = 0;
            const steeringCornerDirection = window.cornerState === 'exit' ? 
                maxBehindDirection : (window.cornerState === 'entry' ? 
                maxAheadDirection : stableCurveTiltDirection);
            
            // コーナー状態に応じたステアリング角度決定ロジック
            if (window.cornerState === 'entry') {
                // 進入時は先読みした曲率に基づいてステアリング
                steeringAngle = -steeringCornerDirection * Math.abs(maxAheadAngle) * steeringMultiplier;
            } else if (window.cornerState === 'apex') {
                // 頂点では現在の曲率に基づいてステアリング
                steeringAngle = -steeringCornerDirection * Math.abs(avgCurveAngle) * steeringMultiplier;
            } else if (window.cornerState === 'exit') {
                // 出口では後ろの曲率に基づいてステアリング（徐々に戻す）
                steeringAngle = -steeringCornerDirection * Math.abs(maxBehindAngle) * steeringMultiplier;
            } else {
                // 直線ではわずかなステアリング（現在の曲率に基づく）
                steeringAngle = -curveTiltDirection * Math.abs(curveAngle) * steeringMultiplier * 0.5;
            }
            
            const maxSteeringAngle = Math.PI / 2.5; // 最大ステアリング角度
            
            // 直線走行時の微小なウォブリング効果（リアルさ向上）
            let wobblingEffect = 0;
            if (window.cornerState === 'straight') {
                // 時間に基づいて微小な振動を生成
                const wobbleFrequency = 2.0; // 揺れの頻度
                const wobbleAmount = 0.03; // 揺れの大きさ
                wobblingEffect = Math.sin(Date.now() / 200 * wobbleFrequency) * wobbleAmount;
                
                // 速度が速いほど揺れを小さく
                wobblingEffect *= (1 - speedFactor * 0.7);
            }
            
            // ウォブリング効果を追加した最終的なステアリング角度
            const finalSteeringAngle = steeringAngle + wobblingEffect;
            const clampedSteeringAngle = Math.max(-maxSteeringAngle, Math.min(maxSteeringAngle, finalSteeringAngle));
            
            // タイヤの高さを地面に合わせて調整
            for (let i = 0; i < wheels.length; i++) {
                // タイヤを回転
                wheels[i].rotation.x += wheelRotationSpeed;
                
                // タイヤの位置を調整
                const wheelGroup = wheelGroups[i];
                const isLeftSide = (i % 2 === 0); // 左側のタイヤかどうか
                const isFrontWheel = (i < 2); // 前輪かどうか
                
                // 前輪の場合、ステアリング角度を適用
                if (isFrontWheel) {
                    // Y軸周りの回転でステアリング効果を実現
                    wheelGroup.rotation.y = clampedSteeringAngle;
                }
                
                // タイヤの基本高さとオフセット
                const wheelBaseHeight = 0.5;
                
                // 傾きによる高さのわずかな調整（ほぼなし）
                const wheelTiltOffset = isLeftSide ? 
                    -tiltFactor * curveTiltDirection * 0.2 : // 左側タイヤ（効果を0.2に削減）
                    tiltFactor * curveTiltDirection * 0.2;   // 右側タイヤ（効果を0.2に削減）
                
                // タイヤの高さを設定
                wheelGroup.position.y = wheelBaseHeight + wheelTiltOffset;
            }
            
            // カメラの位置を更新
            updateCamera();
            
            // 情報表示を更新
            updateInfo();
            
            // 画面描画
            renderer.render(scene, camera);
        }
        
        // カメラの位置と向きを更新
        function updateCamera() {
            switch (cameraMode) {
                case 0: // 俯瞰
                    camera.position.set(0, 200, 0); // より高い位置からの俯瞰視点（コース拡大と高低差に対応）
                    camera.lookAt(car.position);
                    break;
                    
                case 1: // 追従
                    // 車の後ろから少し上の位置（Z軸を正に変更して車の後ろに）
                    const followOffset = new THREE.Vector3(0, 12, 25); // 高さを少し上げる（起伏に対応）
                    // 車の向きに合わせてオフセットを回転
                    const rotatedOffset = followOffset.clone().applyQuaternion(car.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetCameraPos = new THREE.Vector3().addVectors(car.position, rotatedOffset);
                    camera.position.lerp(targetCameraPos, 0.1); // スムージング
                    
                    // カメラの注視点を車の位置に設定（少し前に）
                    const lookAheadOffset = new THREE.Vector3(0, -2, -20).applyQuaternion(car.quaternion);
                    const lookAtPoint = new THREE.Vector3().addVectors(car.position, lookAheadOffset);
                    camera.lookAt(lookAtPoint);
                    break;
                    
                case 2: // 車載
                    // 車のフロントガラス位置
                    const fpvOffset = new THREE.Vector3(0, 1.5, -0.5);
                    fpvOffset.applyQuaternion(car.quaternion);
                    camera.position.copy(car.position).add(fpvOffset);
                    
                    // 車の前方を見る
                    const lookOffset = new THREE.Vector3(0, 1, -10); // Z値を負に変更して前方を見るように修正
                    lookOffset.applyQuaternion(car.quaternion);
                    camera.lookAt(car.position.clone().add(lookOffset));
                    break;
                    
                case 3: // 斜め上視点
                    // 車の上と横から見る位置（車の傾きを強調して見せるため）
                    const diagonalOffset = new THREE.Vector3(50, 40, 20); // 右上からかなり離れた位置に配置
                    // 車の向きに合わせてオフセットを回転
                    const rotatedDiagOffset = diagonalOffset.clone().applyQuaternion(car.quaternion);
                    
                    // カメラ位置をスムーズに更新
                    const targetDiagCameraPos = new THREE.Vector3().addVectors(car.position, rotatedDiagOffset);
                    camera.position.lerp(targetDiagCameraPos, 0.1); // スムージング
                    
                    // 車をしっかり見る（少し前を見るように設定）
                    const diagLookOffset = new THREE.Vector3(0, -1, -5).applyQuaternion(car.quaternion);
                    const diagLookAtPoint = new THREE.Vector3().addVectors(car.position, diagLookOffset);
                    camera.lookAt(diagLookAtPoint);
                    break;
            }
        }
        
        // リサイズ処理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // アニメーションスタート
        log("アニメーション開始");
        animate();
        
        // 初期情報表示の更新
        updateInfo();
    </script>
</body>
</html> 