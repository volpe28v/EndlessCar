<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¨ãƒ³ãƒ‰ãƒ¬ã‚¹ã‚«ãƒ¼ - ãƒ­ãƒ³ãƒ‰ãƒ³å¸‚è¡—åœ°ã‚³ãƒ¼ã‚¹</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 170px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            max-width: calc(100% - 190px); /* ãƒœã‚¿ãƒ³å¹…ã‚’è€ƒæ…®ã—ã¦èª¿æ•´ */
            z-index: 10;
        }
        #viewButtons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
            flex-wrap: nowrap;
            justify-content: flex-start;
            max-width: 60px;
        }
        
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .button-separator {
            width: 100%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            margin: 5px 0;
        }
        
        .weather-button {
            font-size: 16px !important;
            padding: 2px 6px !important;
        }
        
        .weather-button.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        
        /* ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #minimap-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 150px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            z-index: 99;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        #minimap {
            width: 100%;
            height: 100%;
        }
        
        #minimap-label {
            position: absolute;
            top: 5px;
            left: 5px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }
        
        .viewButton {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid white;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin-bottom: 3px;
            min-width: 30px;
            text-align: center; /* ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸­å¤®æƒãˆ */
            width: 100%; /* ãƒœã‚¿ãƒ³ã®å¹…ã‚’è¦ªè¦ç´ ã«åˆã‚ã›ã‚‹ */
        }
        .viewButton:hover {
            background-color: rgba(50, 50, 50, 0.7);
        }
        .viewButton:active {
            transform: scale(0.95);
        }
        .viewButton.active {
            background-color: rgba(100, 100, 255, 0.7);
        }
        /* ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å‘ã‘èª¿æ•´ */
        @media (max-width: 480px) {
            #info {
                left: 120px;
                font-size: 12px;
            }
            .viewButton {
                padding: 3px 4px;
                font-size: 10px;
                min-width: 24px;
            }
            #viewButtons {
                gap: 2px;
                max-width: 45px; /* ã‚¹ãƒãƒ›å‘ã‘ã«ã•ã‚‰ã«å°ã•ã */
            }
            
            #minimap-container {
                width: 100px;
                height: 80px;
                right: 55px;
            }
            
            /* ã‚¹ãƒãƒ›å‘ã‘æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ä½ç½®èª¿æ•´ */
            #timeToggle {
                right: 55px;
                top: 160px; /* è¦–ç‚¹ãƒœã‚¿ãƒ³ã®ä¸‹ã«é…ç½® */
            }
            
            /* ã‚¹ãƒãƒ›å‘ã‘å¤©æ°—ãƒœã‚¿ãƒ³ä½ç½®èª¿æ•´ã‚’å‰Šé™¤ */
            #weatherToggle {
                right: 55px;
                top: 210px; /* æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®ä¸‹ã«é…ç½® */
            }
        }
        
        #timeWeatherInfo {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        #timeToggleButton {
            background: none;
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            padding: 0;
            margin: 0 5px;
        }
        
        #timeToggleButton:hover {
            opacity: 0.8;
        }
        
        /* å¤©æ°—ãƒœã‚¿ãƒ³ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«è¿½åŠ  */
        .weather-button {
            font-size: 16px !important;
            padding: 2px 6px !important;
        }
        
        /* ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .button-separator {
            width: 100%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            margin: 5px 0;
        }
        /* BGMã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #bgmControl {
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
</head>
<body>
    <div id="viewButtons">
        <div class="button-group view-buttons">
            <button class="viewButton" data-view="0" title="ä¿¯ç°è¦–ç‚¹ (1)">ä¿¯ç°</button>
            <button class="viewButton" data-view="1" title="è¿½å¾“è¦–ç‚¹ (2)">è¿½å¾“</button>
            <button class="viewButton" data-view="2" title="è»Šè¼‰è¦–ç‚¹ (3)">è»Šè¼‰</button>
            <button class="viewButton active" data-view="3" title="æ–œã‚ä¸Šè¦–ç‚¹ (4)">æ–œã‚</button>
            <button class="viewButton" data-view="4" title="å‰æ–¹è¦–ç‚¹ (5)">å‰æ–¹</button>
        </div>
        <div class="button-separator"></div>
        <div class="button-group weather-buttons">
            <button class="viewButton weather-button" data-weather="sunny" title="æ™´ã‚Œ">â˜€ï¸</button>
            <button class="viewButton weather-button" data-weather="cloudy" title="æ›‡ã‚Š">â˜ï¸</button>
            <button class="viewButton weather-button" data-weather="rain" title="é›¨">ğŸŒ§ï¸</button>
            <button class="viewButton weather-button" data-weather="snow" title="é›ª">â„ï¸</button>
        </div>
    </div>
    <div id="minimap-container">
        <canvas id="minimap" width="150" height="120"></canvas>
    </div>
    <div id="info">
        <div id="timeWeatherInfo" style="font-family: 'Helvetica', sans-serif;">
            <button id="timeToggleButton" title="ç¾åœ¨ã®æ™‚åˆ»ã«é€£å‹•ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰">ğŸ•’</button>
            <span id="currentTime">--:--</span>
            <span style="margin: 0 5px;">|</span>
            <span id="currentWeatherText">-</span>
        </div>
    </div>
    <script type="module">
        import { Car } from './Car.js';
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ãƒ­ã‚°
        function log(message) {
            console.log(`[${new Date().toISOString()}] ${message}`);
        }
        
        log("ã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹");
        
        // åŸºæœ¬è¨­å®š
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x646464); // åˆæœŸã®ç©ºã®è‰²ã‚’è¨­å®š
        document.body.appendChild(renderer.domElement);
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å®šæ•°ã®å®šç¾©
        const HORIZONTAL_SCALE = 100; // x,zåº§æ¨™ã®ã‚¹ã‚±ãƒ¼ãƒ«
        const VERTICAL_SCALE = 4;     // yåº§æ¨™(é«˜ã•)ã®ã‚¹ã‚±ãƒ¼ãƒ«
        const roadWidth = 16;         // é“è·¯ã®å¹…
        
        // ãƒˆãƒ©ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®å®šç¾©
        const originalTrackPoints = [
            [4, 0, 7],     // 4,7,0
            [1, 0, 7],     // 1,7,0
            [0, 1, 5],     // 0,5,1
            [0.5, 2, 4],   // 0.5,4,2
            [1.2, 2, 4.3], // 1.2,4.3,2
            [2.5, 2, 2.8], // 2.5,2.8,2
            [2, 5, 1],     // 2,1,3
            [2.7, 3, 0],   // 2.7,0,2.5
            [4, 0, 1],     // 4,1,0
            [4.4, 0, 0.8], // 4.4,0.8,0
            [5.9, 0, 1.8], // 5.9,1.8,0
            [5.7, 1, 2.1], // 5.7,2.1,1
            [4.2, 1, 2.2], // 4.2,2.2,1
            [3.7, 2, 2.9], // 3.7,2.9,2
            [3, 2, 4.7],   // 3,4.7,2
            [3.4, 1, 5.5], // 3.4,5.5,1
            [4.4, 1, 5.5], // 4.4,5.5,1
            [5.4, 2, 4.5], // 5.4,4.5,2
            [5.7, 2, 3.6], // 5.7,3.6,2
            [7.3, 1, 3],   // 7.3,3,1
            [8, 1, 3.3],   // 8,3.3,1
            [9.5, 2, 3.5], // 9.5,3.5,2
            [9, 1, 5],     // 9,5,1
            [7.9, 1, 5.7], // 7.9,5.7,1
            [7, 1, 5.3],   // 7,5.3,1
            [6, 0, 5.5],   // 6,5.5,0
            [4.9, 0, 7],   // 4.9,7,0
            [4, 0, 7]      // 4,7,0
        ];
        
        // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¦trackPointsã‚’ç”Ÿæˆ
        const trackPoints = originalTrackPoints.map(point => [
            point[0] * HORIZONTAL_SCALE,
            point[1] * VERTICAL_SCALE,
            point[2] * HORIZONTAL_SCALE
        ]);
        
        // é“è·¯ã‚’ä½œæˆ
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);
        
        // 3Dãƒ‘ã‚¹ãƒã‚¤ãƒ³ãƒˆã«å¤‰æ›
        const carPathPoints = [];
        for (let i = 0; i < trackPoints.length; i++) {
            // é«˜ã•æƒ…å ±ï¼ˆYè»¸ï¼‰ã‚’è€ƒæ…®ã—ãŸãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆ
            carPathPoints.push(new THREE.Vector3(trackPoints[i][0], trackPoints[i][1] + 0.3, trackPoints[i][2]));
        }
        
        // ã‚«ãƒˆãƒãƒ«ãƒ»ãƒ­ãƒ ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³ã§æ»‘ã‚‰ã‹ãªæ›²ç·šã‚’ä½œæˆ
        const carPath = new THREE.CatmullRomCurve3(carPathPoints);
        carPath.closed = true; // é–‰ã˜ãŸãƒ«ãƒ¼ãƒ—ã«æˆ»ã™
        
        // ãƒ‘ã‚¹ã®è©³ç´°ãªãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ï¼ˆé“è·¯ç”Ÿæˆç”¨ï¼‰
        const detailedPathPoints = carPath.getPoints(500);
        
 
        
        // è»Šã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—
        const cars = [];
        let currentCarIndex = 0;
        
        // è»Šã‚’ä½œæˆã—ã¦é…åˆ—ã«è¿½åŠ ã™ã‚‹é–¢æ•°
        function createCars(count = 1) {
            // æ—¢å­˜ã®è»Šã‚’ã‚¯ãƒªã‚¢
            for (let car of cars) {
                if (car.object) {
                    scene.remove(car.object);
                }
            }
            cars.length = 0;
            
            // æ–°ã—ã„è»Šã‚’ä½œæˆ
            for (let i = 0; i < count; i++) {
                const car = new Car(carPath);
                car.position = i * (1.0 / count); // å‡ç­‰ã«é…ç½®
                car.createObject(scene);
                cars.push(car);
            }
            for (let i = 0; i < count; i++) {
                const car = cars[i];
                car.setOtherCars(cars.filter(c => c !== car));  
            }
            
            log(`${count}å°ã®è»Šã‚’ä½œæˆã—ã¾ã—ãŸ`);
        }
        
        // åˆæœŸçŠ¶æ…‹ã§ã¯3å°ã®è»Šã‚’ä½œæˆ
        createCars(10);
        
        log("è»Šã®ä½œæˆå®Œäº†");
        
        // ã‚«ãƒ¡ãƒ©ä½ç½®ã®åˆæœŸè¨­å®šï¼ˆæ–œã‚è¦–ç‚¹å‘ã‘ï¼‰
        camera.position.set(100, 70, 90);
        
        log("Three.jsã®åŸºæœ¬è¨­å®šå®Œäº†");
        
        // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ ã®è¿½åŠ 
        let gameTime = 5.0; // æœ5æ™‚ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
        let timeSpeed = 0.01; // æ™‚é–“ã®é€²ã¿é€Ÿåº¦ (0.01 = ç¾å®Ÿã®100å€é€Ÿ)
        let isNight = false;
        let isNightMode = false;
        let useRealTime = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç¾åœ¨æ™‚åˆ»ãƒ¢ãƒ¼ãƒ‰
        let lastCameraChangeTime = Date.now(); // æœ€å¾Œã«ã‚«ãƒ¡ãƒ©ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚åˆ»
        let cameraChangeInterval = 30000; // ã‚«ãƒ¡ãƒ©å¤‰æ›´ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        let availableCameraModes = [0, 1, 2, 3, 4]; // åˆ©ç”¨å¯èƒ½ãªã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰

        // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®è¿½åŠ 
        let currentWeather = 'sunny'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ™´ã‚Œ
        let rainParticles;
        let snowParticles;
        let cloudParticles; // é›²ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¿½åŠ 
        let driftSmokeParticles; // ãƒ‰ãƒªãƒ•ãƒˆç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
        let driftSmokeData; // ãƒ‰ãƒªãƒ•ãƒˆç…™ãƒ‡ãƒ¼ã‚¿
        let isRaining = false;
        let isSnowing = false;
        let isCloudy = false; // æ›‡ã‚Šãƒ•ãƒ©ã‚°è¿½åŠ 
        let lastWeatherChangeTime = Date.now(); // æœ€å¾Œã«å¤©æ°—ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚åˆ»
        let weatherChangeInterval = 30000; // å¤©æ°—å¤‰æ›´ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        let availableWeathers = ['sunny', 'cloudy', 'rain', 'snow']; // åˆ©ç”¨å¯èƒ½ãªå¤©æ°—ã®é…åˆ—
        let currentFrameTime = Date.now(); // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å®šç¾©
        let weatherApiKey = '2416f36c5b6368d2de6d3016e34ae8f8'; // OpenWeatherMap APIã‚­ãƒ¼
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å¤©æ°—ã®è‰²ã®å½±éŸ¿ã‚’ä¿æŒ
        let weatherSkyColor = new THREE.Color(0x87CEEB); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ™´ã‚Œã®ç©ºã®è‰²

        // æ™‚é–“å¸¯ã«å¿œã˜ãŸç©ºã®è‰²ã¨å…‰ã®è¨­å®š
        function updateDayNightCycle() {
            // æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦æ™‚é–“ã‚’æ›´æ–°
            if (useRealTime) {
                // ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—
                const now = new Date();
                gameTime = now.getHours() + now.getMinutes() / 60;
            } else {
                // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®æ™‚é–“ã‚’æ—©å›ã—ã§é€²ã‚ã‚‹
                gameTime = (gameTime + timeSpeed) % 24;
            }
            
            updateTimeDisplay(); // æ™‚åˆ»è¡¨ç¤ºã‚’æ›´æ–°
            
            // æ™‚é–“å¸¯ã«å¿œã˜ãŸç©ºã®è‰²ã®è¨­å®š
            let timeSkyColor;
            let lightIntensity;
            let ambientIntensity;
            
            isNight = false;
            if (gameTime >= 5 && gameTime < 7) {
                // æœç„¼ã‘ï¼ˆ5æ™‚ï½7æ™‚ï¼‰
                const t = (gameTime - 5) / 2;
                timeSkyColor = new THREE.Color(0xff9966).lerp(new THREE.Color(0x87CEEB), t);
                lightIntensity = 0.5 + t * 0.5;
                ambientIntensity = 0.3 + t * 0.3;
            } else if (gameTime >= 7 && gameTime < 17) {
                // æ˜¼é–“ï¼ˆ7æ™‚ï½17æ™‚ï¼‰
                timeSkyColor = new THREE.Color(0x87CEEB);
                lightIntensity = 1.0;
                ambientIntensity = 0.6;
            } else if (gameTime >= 17 && gameTime < 19) {
                // å¤•ç„¼ã‘ï¼ˆ17æ™‚ï½19æ™‚ï¼‰
                const t = (gameTime - 17) / 2;
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xff7733), t);
                lightIntensity = 1.0 - t * 0.5;
                ambientIntensity = 0.6 - t * 0.3;
            } else if (gameTime >= 19 && gameTime < 21) {
                // æ—¥æ²¡å¾Œï¼ˆ19æ™‚ï½21æ™‚ï¼‰
                const t = (gameTime - 19) / 2;
                timeSkyColor = new THREE.Color(0xff7733).lerp(new THREE.Color(0x111133), t);
                lightIntensity = 0.5 - t * 0.4;
                ambientIntensity = 0.3 - t * 0.2;
                isNight = true;
            } else {
                // å¤œé–“ï¼ˆ21æ™‚ï½5æ™‚ï¼‰
                if (gameTime >= 21) {
                    timeSkyColor = new THREE.Color(0x111133);
                } else {
                    // å¤œæ˜ã‘å‰ï¼ˆ0æ™‚ï½5æ™‚ï¼‰
                    const t = gameTime / 5;
                    timeSkyColor = new THREE.Color(0x111133).lerp(new THREE.Color(0xff9966), t);
                }
                lightIntensity = 0.1;
                ambientIntensity = 0.1;
                isNight = true;
            }
            
            // æ™‚é–“å¸¯ã®è‰²ã¨å¤©æ°—ã®è‰²ã‚’åˆæˆ
            let finalColor;
            if (currentWeather === 'sunny') {
                finalColor = timeSkyColor;
            } else {
                // å¤©æ°—ã«ã‚ˆã‚‹è‰²ã®å½±éŸ¿ã‚’å¼·ã‚ã‚‹ï¼ˆ0.7ã¯å¤©æ°—ã®å½±éŸ¿åº¦ï¼‰
                finalColor = timeSkyColor.clone().lerp(weatherSkyColor, 0.7);
            }
            
            // ç©ºã®è‰²ã‚’è¨­å®š
            renderer.setClearColor(finalColor.getHex());
            
            // å…‰æºã®å¼·åº¦ã‚’è¨­å®š
            directionalLight.intensity = lightIntensity;
            ambientLight.intensity = ambientIntensity;
            
            // å¤œé–“ã¯è¡—ç¯ã‚’æ˜ã‚‹ã
            updateStreetLights(isNight);
        }
        
        // è¡—ç¯ã®æ˜ã‚‹ã•ã‚’æ›´æ–°
        function updateStreetLights(isNight) {
            // è¡—ç¯ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ãƒ©ã‚¤ãƒˆã‚’æ›´æ–°
            scene.traverse((object) => {
                if (object.userData && object.userData.isStreetlight) {
                    // è¡—ç¯æœ¬ä½“ã®ç™ºå…‰ã‚’è¨­å®š
                    if (object.material && object.material.emissive) {
                        if (isNight) {
                            // å¤œé–“ã¯æ˜ã‚‹ãç™ºå…‰
                            object.material.emissive.set(0xFFDD99);
                            object.material.emissiveIntensity = 1.0;
                        } else {
                            // æ˜¼é–“ã¯ç™ºå…‰ã‚’å¼±ã‚ã‚‹
                            object.material.emissive.set(0x333333);
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                    
                    // é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•ã‚’è¨­å®š
                    if (object.userData.pointLight) {
                        const pointLight = object.userData.pointLight;
                        if (isNight) {
                            // å¤œé–“ã¯ãƒ©ã‚¤ãƒˆã‚’æ˜ã‚‹ã
                            pointLight.intensity = 2.5;
                            pointLight.distance = 50;
                        } else {
                            // æ˜¼é–“ã¯ãƒ©ã‚¤ãƒˆã‚’å¼±ãï¼ˆå®Œå…¨ã«æ¶ˆã•ãªã„ï¼‰
                            pointLight.intensity = 0.2;
                            pointLight.distance = 10;
                        }
                    }
                }
            });
        }

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);
        
        // éƒ½å¸‚ã®åœ°é¢ã‚’ä½œæˆ
        const floorSize = 5000; // åºŠã®ã‚µã‚¤ã‚ºã‚’2500ã‹ã‚‰2.0å€ã®5000ã«æ‹¡å¤§
        const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x336633, 
            roughness: 0.8, 
            metalness: 0.2 
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -5; // åºŠã®ä½ç½®ã‚’ä¸‹ã’ã‚‹
        scene.add(floor);
        
        // èˆ—è£…ã•ã‚ŒãŸé“è·¯ã®å¹…
        
        // ã‚¢ã‚¹ãƒ•ã‚¡ãƒ«ãƒˆéƒ¨åˆ†ã‚’ä½œæˆ
        function createRoadSurface() {
            // é“è·¯ã®å·¦å³ã®ã‚¨ãƒƒã‚¸ã‚’è¨ˆç®—
            const leftEdgePoints = [];
            const rightEdgePoints = [];
            
            for (let i = 0; i < detailedPathPoints.length; i++) {
                const point = detailedPathPoints[i];
                const nextPoint = detailedPathPoints[(i + 1) % detailedPathPoints.length];
                
                // é€²è¡Œæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
                const direction = new THREE.Vector3().subVectors(nextPoint, point).normalize();
                
                // ä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ³•ç·šï¼‰ã‚’è¨ˆç®—
                // é«˜ã•ã®å¤‰åŒ–ã‚’è€ƒæ…®ã—ãŸæ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ã™ã‚‹ï¼ˆåœ°å½¢ã«æ²¿ã£ãŸé“è·¯ï¼‰
                const up = new THREE.Vector3(0, 1, 0);
                
                // å³å‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã¨ä¸Šå‘ãã®å¤–ç©ï¼‰
                const right = new THREE.Vector3().crossVectors(direction, up).normalize();
                
                // ä¿®æ­£ã—ãŸä¸Šå‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆé€²è¡Œæ–¹å‘ã¨å³å‘ãã®å¤–ç©ï¼‰
                const correctedUp = new THREE.Vector3().crossVectors(right, direction).normalize();
                
                // é“è·¯ã®å·¦å³ã®ã‚¨ãƒƒã‚¸ã‚’è¨ˆç®—ï¼ˆä¿®æ­£ã—ãŸæ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ï¼‰
                const leftEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(roadWidth / 2));
                const rightEdge = new THREE.Vector3().addVectors(point, right.clone().multiplyScalar(-roadWidth / 2));
                
                // é«˜ã•ã‚’ç¶­æŒï¼ˆé“è·¯é¢ã®é«˜ã•ã¯æ—¢ã«detailedPathPointsã«å«ã¾ã‚Œã‚‹ï¼‰
                // é“è·¯ã‚’å°‘ã—æµ®ã‹ã›ã‚‹ï¼ˆ0.05ï¼‰
                leftEdge.y += 0.05;
                rightEdge.y += 0.05;
                
                leftEdgePoints.push(leftEdge);
                rightEdgePoints.push(rightEdge);
            }
            
            // é“è·¯ã®è¡¨é¢ã‚’ä¸‰è§’å½¢ãƒ¡ãƒƒã‚·ãƒ¥ã§ä½œæˆ
            const roadGeometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            
            // ã™ã¹ã¦ã®ãƒã‚¤ãƒ³ãƒˆã‚’é ‚ç‚¹é…åˆ—ã«è¿½åŠ 
            for (let i = 0; i < leftEdgePoints.length; i++) {
                vertices.push(leftEdgePoints[i].x, leftEdgePoints[i].y, leftEdgePoints[i].z);
                vertices.push(rightEdgePoints[i].x, rightEdgePoints[i].y, rightEdgePoints[i].z);
            }
            
            // ä¸‰è§’å½¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
            for (let i = 0; i < leftEdgePoints.length - 1; i++) {
                const v0 = i * 2;
                const v1 = v0 + 1;
                const v2 = v0 + 2;
                const v3 = v0 + 3;
                
                // 2ã¤ã®ä¸‰è§’å½¢ã§å››è§’å½¢ã‚’ä½œæˆ
                indices.push(v0, v1, v2);
                indices.push(v2, v1, v3);
            }
            
            // æœ€å¾Œã®éƒ¨åˆ†ã‚’é–‰ã˜ã‚‹
            const v0 = (leftEdgePoints.length - 1) * 2;
            const v1 = v0 + 1;
            const v2 = 0;
            const v3 = 1;
            
            indices.push(v0, v1, v2);
            indices.push(v2, v1, v3);
            
            roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            roadGeometry.setIndex(indices);
            roadGeometry.computeVertexNormals();
            
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,    // ã‚ˆã‚Šæš—ã‚ã®ã‚°ãƒ¬ãƒ¼ã«
                roughness: 0.98,    // roughnessã‚’æœ€å¤§é™ã«è¿‘ãè¨­å®š
                metalness: 0.05,    // metalnessã‚’ã•ã‚‰ã«ä¸‹ã’ã¦å…‰ã®åå°„ã‚’æŠ‘ãˆã‚‹
                side: THREE.DoubleSide
            });
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadGroup.add(roadMesh);
            
            // ç™½ç·šï¼ˆå®Ÿç·šï¼‰ã‚’ä½œæˆ - å‰Šé™¤
            // createRoadLine(detailedPathPoints, 0.05, 0xFFFFFF);
            
            // ç¸çŸ³ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼éƒ¨åˆ†ï¼‰ - å‰Šé™¤
            // createCurbstones();
            
            return roadMesh;
        }
        
        // é“è·¯ã®ç™½ç·šã‚’ä½œæˆ
        function createRoadLine(pathPoints, lineWidth, color) {
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
            const lineMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: lineWidth });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.position.y = 0.1; // é“è·¯ã®ä¸Šã«æµ®ã‹ã›ã‚‹
            roadGroup.add(line);
            
            return line;
        }
        
        // ç¸çŸ³ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ãƒŠãƒ¼éƒ¨åˆ†ï¼‰
        function createCurbstones() {
            // ã‚³ãƒ¼ãƒŠãƒ¼ã®ä½ç½®ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const cornerPositions = [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.85];
            
            for (let i = 0; i < cornerPositions.length; i++) {
                const t = cornerPositions[i];
                const cornerLength = 0.05; // ã‚³ãƒ¼ãƒŠãƒ¼ã®é•·ã•ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
                
                for (let j = 0; j < 10; j++) {
                    const segmentT = t + (j * cornerLength / 10);
                    const point = carPath.getPointAt(segmentT);
                    const tangent = carPath.getTangentAt(segmentT);
                    
                    // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¨å‰ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å‚¾æ–œã‚’è¨ˆç®—
                    const nextT = (segmentT + 0.005) % 1;
                    const prevT = (segmentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ç¸çŸ³ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ï¼‰
                    const curbPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(roadWidth / 2)
                    );
                    
                    // å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—ï¼ˆYè»¸æ–¹å‘ã®å¤‰åŒ–ã‹ã‚‰ï¼‰
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // èµ¤ç™½ã®ç¸çŸ³ï¼ˆäº¤äº’ï¼‰
                    const color = j % 2 === 0 ? 0xff0000 : 0xffffff;
                    
                    const curbGeometry = new THREE.BoxGeometry(1, 0.3, 1);
                    const curbMaterial = new THREE.MeshLambertMaterial({ color: color });
                    const curb = new THREE.Mesh(curbGeometry, curbMaterial);
                    
                    // ç¸çŸ³ã®ä½ç½®ã‚’é“è·¯ã®é«˜ã•ã«åˆã‚ã›ã‚‹
                    curb.position.copy(curbPosition);
                    curb.position.y = point.y + 0.1; // é“è·¯é¢ã‚ˆã‚Šå°‘ã—æµ®ã‹ã›ã‚‹
                    
                    // é€²è¡Œæ–¹å‘ã‚’å‘ãã‚ˆã†ã«å›è»¢
                    const lookAtPos = new THREE.Vector3().addVectors(
                        curbPosition,
                        tangent
                    );
                    curb.lookAt(lookAtPos);
                    
                    // ä¸Šä¸‹ã®å‚¾æ–œã«åˆã‚ã›ã¦è¿½åŠ ã®å›è»¢
                    curb.rotateX(slope);
                    
                    roadGroup.add(curb);
                }
            }
        }
        
        // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’ä½œæˆï¼ˆã‚³ãƒ¼ã‚¹å…¨ä½“ã®å¤–å´ï¼‰
        function createGuardrails() {
            // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é–“éš”ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const railSpacing = 0.005; // ã‚ˆã‚Šå¯†ã«é…ç½®
            const postSpacing = 0.025; // æ”¯æŸ±ã®é–“éš”
            
            // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            const guardrailGroup = new THREE.Group();
            roadGroup.add(guardrailGroup);
            
            // é“è·¯ã®ä¸¡å´ã«ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’è¨­ç½®
            createSideGuardrail(1); // å³å´
            createSideGuardrail(-1); // å·¦å´
            
            // ç‰¹å®šã®å´ï¼ˆå³å´ã¾ãŸã¯å·¦å´ï¼‰ã«ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createSideGuardrail(side) {
                // é€£ç¶šã—ãŸã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æ ¼ç´ã™ã‚‹é…åˆ—
                const railSegments = [];
                const railPosts = [];
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ç”¨ã®é ‚ç‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åé›†
                const railVertices = [];
                const railIndices = [];
                const railUvs = [];
                
                let vertexIndex = 0;
                let currentT = 0;
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                while (currentT < 1) {
                    const point = carPath.getPointAt(currentT);
                    const tangent = carPath.getTangentAt(currentT);
                    
                    // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¨å‰ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã—ã¦å‚¾æ–œã‚’è¨ˆç®—
                    const nextT = (currentT + 0.005) % 1;
                    const prevT = (currentT - 0.005 + 1) % 1;
                    const nextPoint = carPath.getPointAt(nextT);
                    const prevPoint = carPath.getPointAt(prevT);
                    
                    // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                    const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ã€side=1ã§å³å´ã€side=-1ã§å·¦å´ï¼‰
                    const railPosition = new THREE.Vector3().addVectors(
                        point,
                        normal.clone().multiplyScalar(side * (roadWidth / 2 + 1.2))
                    );
                    
                    // å‰å¾Œæ–¹å‘ã®å‚¾æ–œè§’ã‚’è¨ˆç®—
                    const slopeDistance = Math.sqrt(
                        Math.pow(nextPoint.x - prevPoint.x, 2) + 
                        Math.pow(nextPoint.z - prevPoint.z, 2));
                    const slope = Math.atan2(nextPoint.y - prevPoint.y, slopeDistance);
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®é«˜ã•èª¿æ•´
                    const railHeight = point.y + 0.8; // é“è·¯é¢ã‹ã‚‰å°‘ã—é«˜ã
                    
                    // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä¸Šéƒ¨ã¨ä¸‹éƒ¨ã®é ‚ç‚¹ã‚’è¿½åŠ 
                    const topRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight + 0.4, // ä¸Šéƒ¨ã®é«˜ã•
                        railPosition.z
                    );
                    
                    const bottomRailPos = new THREE.Vector3(
                        railPosition.x,
                        railHeight, // ä¸‹éƒ¨ã®é«˜ã•
                        railPosition.z
                    );
                    
                    // æ”¯æŸ±ã‚’ä½œæˆï¼ˆä¸€å®šé–“éš”ã”ã¨ï¼‰
                    if (Math.abs(currentT % postSpacing) < railSpacing) {
                        const postGeometry = new THREE.CylinderGeometry(0.08, 0.08, 1.0, 6);
                        const postMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                        const post = new THREE.Mesh(postGeometry, postMaterial);
                        
                        // æ”¯æŸ±ã®ä½ç½®ã‚’è¨­å®š
                        post.position.copy(new THREE.Vector3(
                            railPosition.x,
                            point.y + 0.5, // åœ°é¢ã‹ã‚‰ã®é«˜ã•
                            railPosition.z
                        ));
                        
                        // æ”¯æŸ±ã‚’å°‘ã—å†…å´ã«å‚¾ã‘ã‚‹
                        const postLookAt = new THREE.Vector3().addVectors(
                            post.position,
                            normal.clone().multiplyScalar(-0.1 * side) // å†…å´ã«å°‘ã—å‚¾ã‘ã‚‹
                        );
                        post.lookAt(postLookAt);
                        post.rotateX(Math.PI / 2); // æ”¯æŸ±ã®å‘ãã‚’ä¿®æ­£
                        
                        // ä¸Šä¸‹ã®å‚¾æ–œã«åˆã‚ã›ã¦è¿½åŠ ã®å›è»¢
                        post.rotateZ(slope); // Xè»¸ã§ã¯ãªãZè»¸ã§å›è»¢ï¼ˆæ”¯æŸ±ã®å‘ããŒå¤‰ã‚ã£ã¦ã„ã‚‹ãŸã‚ï¼‰
                        
                        guardrailGroup.add(post);
                        railPosts.push(post);
                    }
                    
                    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
                    railVertices.push(
                        topRailPos.x, topRailPos.y, topRailPos.z,
                        bottomRailPos.x, bottomRailPos.y, bottomRailPos.z
                    );
                    
                    // ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã‚’è¿½åŠ 
                    railUvs.push(
                        currentT * 20, 0, // ä¸Šéƒ¨ã®UVåº§æ¨™
                        currentT * 20, 1  // ä¸‹éƒ¨ã®UVåº§æ¨™
                    );
                    
                    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ ï¼ˆå››è§’å½¢ã‚’ä½œæˆï¼‰
                    if (vertexIndex > 0) {
                        // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé–“ã‚’ä¸‰è§’å½¢ã§æ¥ç¶š
                        railIndices.push(
                            vertexIndex * 2 - 2, vertexIndex * 2, vertexIndex * 2 - 1, // æœ€åˆã®ä¸‰è§’å½¢
                            vertexIndex * 2 - 1, vertexIndex * 2, vertexIndex * 2 + 1  // äºŒç•ªç›®ã®ä¸‰è§’å½¢
                        );
                    }
                    
                    vertexIndex++;
                    currentT += railSpacing;
                }
                
                // æœ€å¾Œã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¨æ¥ç¶šã—ã¦é–‰ã˜ã‚‹
                railIndices.push(
                    (vertexIndex - 1) * 2, 0, (vertexIndex - 1) * 2 + 1, // æœ€åˆã®ä¸‰è§’å½¢
                    (vertexIndex - 1) * 2 + 1, 0, 1  // äºŒç•ªç›®ã®ä¸‰è§’å½¢
                );
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                const railGeometry = new THREE.BufferGeometry();
                railGeometry.setAttribute('position', new THREE.Float32BufferAttribute(railVertices, 3));
                railGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(railUvs, 2));
                railGeometry.setIndex(railIndices);
                railGeometry.computeVertexNormals();
                
                // é«˜é€Ÿé“è·¯ã®ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã‚‰ã—ã„ç´ æ
                const railMaterial = new THREE.MeshLambertMaterial({
                    color: 0xE0E0E0,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ãƒ¡ãƒƒã‚·ãƒ¥ã‚’ä½œæˆ
                const railMesh = new THREE.Mesh(railGeometry, railMaterial);
                guardrailGroup.add(railMesh);
            }
        }
        
        // é“è·¯ã®å¯è¦–åŒ–
        createRoadSurface();
        
        // é«˜å±¤é“è·¯ã®æŸ±ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
        function createRoadPillars() {
            const pillarGroup = new THREE.Group();
            roadGroup.add(pillarGroup);
            
            // æŸ±ã®é–“éš”ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const pillarSpacing = 0.04; // ç´„25æœ¬ã®æŸ±
            
            // ã‚³ãƒ¼ã‚¹å…¨ä½“ã«æŸ±ã‚’é…ç½®
            let currentT = 0;
            while (currentT < 1) {
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // åœ°ä¸Šã‹ã‚‰ã®é«˜ã•ãŒ1ä»¥ä¸Šã®å ´åˆã®ã¿æŸ±ã‚’è¨­ç½®
                if (point.y > 1) {
                    // é“è·¯ã®å·¦å³ã«æŸ±ã‚’è¨­ç½®
                    createSinglePillar(point, tangent, 1);  // å³å´
                    createSinglePillar(point, tangent, -1); // å·¦å´
                }
                
                currentT += pillarSpacing;
            }
            
            // 1æœ¬ã®æŸ±ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
            function createSinglePillar(point, tangent, side) {
                // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // æŸ±ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ï¼‰
                const pillarPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 - 1))
                );
                
                // æŸ±ã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆåœ°ä¸Šã‹ã‚‰é“è·¯é¢ã¾ã§ï¼‰
                const pillarHeight = point.y;
                
                // æŸ±ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ãƒãƒ†ãƒªã‚¢ãƒ«
                const pillarGeometry = new THREE.BoxGeometry(2, pillarHeight, 2);
                const pillarMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x888888,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                
                // æŸ±ã®ä½ç½®ã‚’è¨­å®šï¼ˆYåº§æ¨™ã¯é«˜ã•ã®åŠåˆ†ï¼‰
                pillar.position.set(
                    pillarPosition.x,
                    pillarHeight / 2,
                    pillarPosition.z
                );
                
                pillarGroup.add(pillar);
            }
        }
        
        // é«˜å±¤é“è·¯ã®æŸ±ã‚’ç”Ÿæˆ
        createRoadPillars();
        
        // ã‚¬ãƒ¼ãƒ‰ãƒ¬ãƒ¼ãƒ«ã®ä½œæˆ
        createGuardrails();
        
        log("é“è·¯ã®ä½œæˆå®Œäº†");
        
        // ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®ï¼ˆãƒ“ãƒ«ã¯å‰Šé™¤ã—ã¦æ˜Ÿç©ºã®ã¿ã«ï¼‰
        function placeEnvironmentObjects() {
            log("ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…ç½®é–‹å§‹");
            
            // è¡—ç¯ã‚’é…ç½®
            createStreetlights();
            
            log("ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…ç½®å®Œäº†");
        }
        
        // è¡—ç¯ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createStreetlights() {
            // è¡—ç¯ã®é–“éš”ï¼ˆãƒ‘ã‚¹ã®å‰²åˆï¼‰
            const streetlightSpacing = 0.04; // ã‚³ãƒ¼ã‚¹å…¨ä½“ã§ç´„25æœ¬ã®è¡—ç¯
            
            // è¡—ç¯ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            const streetlightGroup = new THREE.Group();
            roadGroup.add(streetlightGroup);
            
            // ã‚³ãƒ¼ã‚¹å…¨ä½“ã«è¡—ç¯ã‚’é…ç½®
            let currentT = 0;
            while (currentT < 1) {
                // ãƒ‘ã‚¹ä¸Šã®ä½ç½®ã¨æ¥ç·šã‚’å–å¾—
                const point = carPath.getPointAt(currentT);
                const tangent = carPath.getTangentAt(currentT);
                
                // å‚ç›´æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå¤–å´æ–¹å‘ï¼‰
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                // é“è·¯ã®å³å´ã«è¡—ç¯ã‚’è¨­ç½®
                createSingleStreetlight(point, normal, 1); // å³å´
                
                currentT += streetlightSpacing;
            }
            
            // 1æœ¬ã®è¡—ç¯ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createSingleStreetlight(point, normal, side) {
                // è¡—ç¯ã®ä½ç½®ï¼ˆé“è·¯ã®å¤–å´ï¼‰
                const lightPosition = new THREE.Vector3().addVectors(
                    point,
                    normal.clone().multiplyScalar(side * (roadWidth / 2 + 2.0))
                );
                
                // è¡—ç¯ã®æ”¯æŸ±
                const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 8, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                
                // æ”¯æŸ±ã®ä½ç½®ã‚’è¨­å®š
                pole.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 4, // åœ°é¢ã‹ã‚‰ã®é«˜ã•
                    lightPosition.z
                ));
                
                // æ”¯æŸ±ã‚’å‚ç›´ã«ç«‹ã¦ã‚‹
                pole.rotation.x = Math.PI / 2;
                
                streetlightGroup.add(pole);
                
                // è¡—ç¯ã®é ­éƒ¨
                const headGeometry = new THREE.BoxGeometry(1.0, 0.4, 0.4);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    emissive: 0xFFDD99,
                    emissiveIntensity: 0.1 // åˆæœŸå€¤ã¯ä½ã
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // é ­éƒ¨ã®ä½ç½®ã‚’è¨­å®š
                head.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // æ”¯æŸ±ã®ä¸Šéƒ¨
                    lightPosition.z
                ));
                
                // é ­éƒ¨ã‚’é“è·¯ã«å‘ã‘ã‚‹
                head.lookAt(new THREE.Vector3(
                    point.x,
                    point.y + 8,
                    point.z
                ));
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã«è¡—ç¯ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                head.userData.isStreetlight = true;
                
                streetlightGroup.add(head);
                
                // è¡—ç¯ã®ãƒ©ã‚¤ãƒˆ
                const light = new THREE.PointLight(0xFFDD99, 0.2, 10, 2);
                light.position.copy(new THREE.Vector3(
                    lightPosition.x,
                    point.y + 8, // æ”¯æŸ±ã®ä¸Šéƒ¨
                    lightPosition.z
                ));
                
                // ãƒ©ã‚¤ãƒˆã‚’è¡—ç¯ã®é ­éƒ¨ã«é–¢é€£ä»˜ã‘ã‚‹
                head.userData.pointLight = light;
                
                streetlightGroup.add(light);
            }
        }
        
        // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ï¼ˆ0: ä¿¯ç°, 1: è¿½å¾“, 2: è»Šè¼‰, 3: æ–œã‚è¦–ç‚¹ï¼‰
        let cameraMode = 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’æ–œã‚è¦–ç‚¹ãƒ¢ãƒ¼ãƒ‰ã«è¨­å®š
        
        // ã‚«ãƒ¡ãƒ©ä½ç½®ã®åˆæœŸè¨­å®šï¼ˆæ–œã‚è¦–ç‚¹å‘ã‘ï¼‰
        camera.position.set(100, 70, 90); // æ–œã‚è¦–ç‚¹ã®åˆæœŸä½ç½®
        
        // éå»ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹å¤‰æ•°
        let lastFrameTime = Date.now();
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            const metrics = {};
            const startTime = performance.now();
            let lastCheck = startTime;
            
            // ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã‚’è¨ˆç®—
            currentFrameTime = Date.now();
            const deltaTime = (currentFrameTime - lastFrameTime) / 16.67;
            lastFrameTime = currentFrameTime;
            
            // æ˜¼å¤œã‚µã‚¤ã‚¯ãƒ«ã®æ›´æ–°
            updateDayNightCycle();
            metrics.dayNightCycle = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // å¤©æ°—ã®æ›´æ–°
            updateWeather(deltaTime);
            metrics.weather = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰æ™‚ã®è»Šã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ
            if (!useRealTime && currentFrameTime - lastCarChangeTime > carChangeInterval) {
                // ç¾åœ¨ã®è»Šä»¥å¤–ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
                const availableCars = Array.from({length: cars.length}, (_, i) => i).filter(i => i !== currentCarIndex);
                currentCarIndex = availableCars[Math.floor(Math.random() * availableCars.length)];
                
                lastCarChangeTime = currentFrameTime;
                carChangeInterval = 20000 + Math.random() * 10000; // 20-30ç§’ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé–“éš”
            }
            
            // è»Šã®æ›´æ–°
            for (let i = 0; i < cars.length; i++) {
                const car = cars[i];
                car.update(deltaTime, isNight);
            }
            metrics.carUpdates = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
            updateCamera();
            metrics.camera = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®æ›´æ–°
            updateMinimap();
            metrics.minimap = performance.now() - lastCheck;
            lastCheck = performance.now();
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            renderer.render(scene, camera);
            metrics.rendering = performance.now() - lastCheck;
            
            // å…¨ä½“ã®å®Ÿè¡Œæ™‚é–“
            metrics.total = performance.now() - startTime;
            
            // 100ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å‡ºåŠ›
            frameCount++;
            if (frameCount % 100 === 0) {
                console.log('Frame Performance Metrics:');
                console.table(metrics);
            }
        }
        
        // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã¨å‘ãã‚’æ›´æ–°
        function updateCamera() {
            const currentCar = cars[currentCarIndex];
            if (!currentCar || !currentCar.object) return;

            switch (cameraMode) {
                case 0: // ä¿¯ç°
                    // è»Šã®çœŸä¸Šã‹ã‚‰ã®è¿½å¾“è¦–ç‚¹
                    const topOffset = new THREE.Vector3(0, 100, 0); // é«˜ã•100ã®çœŸä¸Š
                    const targetTopCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, topOffset);
                    camera.position.lerp(targetTopCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚ºãªè¿½å¾“
                    camera.lookAt(currentCar.object.position);
                    
                    // è¦–é‡è§’ã‚’åºƒã‚ã«è¨­å®šã—ã¦è¦‹ã‚„ã™ã
                    camera.fov = 70;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 1: // è¿½å¾“
                    // è»Šã®å¾Œã‚ã‹ã‚‰å°‘ã—ä¸Šã®ä½ç½®ï¼ˆZè»¸ã‚’æ­£ã«å¤‰æ›´ã—ã¦è»Šã®å¾Œã‚ã«ï¼‰
                    const followOffset = new THREE.Vector3(0, 10, 20); // é«˜ã•ã‚’å°‘ã—ä¸Šã’ã‚‹ï¼ˆèµ·ä¼ã«å¯¾å¿œï¼‰
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedOffset = followOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedOffset);
                    camera.position.lerp(targetCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // ã‚«ãƒ¡ãƒ©ã®æ³¨è¦–ç‚¹ã‚’è»Šã®ä½ç½®ã«è¨­å®šï¼ˆå°‘ã—å‰ã«ï¼‰
                    const lookAheadOffset = new THREE.Vector3(0, -2, -20).applyQuaternion(currentCar.object.quaternion);
                    const lookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, lookAheadOffset);
                    camera.lookAt(lookAtPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 2: // è»Šè¼‰
                    // è»Šã®å¾Œã‚ã‹ã‚‰å°‘ã—ä¸Šã®ä½ç½®ï¼ˆZè»¸ã‚’æ­£ã«å¤‰æ›´ã—ã¦è»Šã®å¾Œã‚ã«ï¼‰
                    const fpvOffset = new THREE.Vector3(0, 3, -12); // é«˜ã•ã‚’å°‘ã—ä¸Šã’ã‚‹ï¼ˆèµ·ä¼ã«å¯¾å¿œï¼‰
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedFpvOffset = fpvOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetFpvCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedFpvOffset);
                    camera.position.lerp(targetFpvCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // ã‚«ãƒ¡ãƒ©ã®æ³¨è¦–ç‚¹ã‚’è»Šã®ä½ç½®ã«è¨­å®šï¼ˆå°‘ã—å‰ã«ï¼‰
                    const fpvLookAheadOffset = new THREE.Vector3(0, -2, -30).applyQuaternion(currentCar.object.quaternion);
                    const fpvLookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, fpvLookAheadOffset);
                    camera.lookAt(fpvLookAtPoint);
                    
                    camera.fov = 75;
                    camera.updateProjectionMatrix();

                    break;
                case 3: // æ–œã‚ä¸Šè¦–ç‚¹
                    // è»Šã®ä¸Šã¨æ¨ªã‹ã‚‰è¦‹ã‚‹ä½ç½®ï¼ˆè»Šã®å‚¾ãã‚’å¼·èª¿ã—ã¦è¦‹ã›ã‚‹ãŸã‚ï¼‰
                    const diagonalOffset = new THREE.Vector3(50, 40, 20); // å³ä¸Šã‹ã‚‰ã‹ãªã‚Šé›¢ã‚ŒãŸä½ç½®ã«é…ç½®
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedDiagOffset = diagonalOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetDiagCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedDiagOffset);
                    camera.position.lerp(targetDiagCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // è»Šã‚’ã—ã£ã‹ã‚Šè¦‹ã‚‹ï¼ˆå°‘ã—å‰ã‚’è¦‹ã‚‹ã‚ˆã†ã«è¨­å®šï¼‰
                    const diagLookOffset = new THREE.Vector3(0, -1, -5).applyQuaternion(currentCar.object.quaternion);
                    const diagLookAtPoint = new THREE.Vector3().addVectors(currentCar.object.position, diagLookOffset);
                    camera.lookAt(diagLookAtPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
                    
                case 4: // è»Šå‰æ–¹ã‹ã‚‰å¾Œæ–¹ã‚’è¦‹ã‚‹è¦–ç‚¹
                    // è»Šã®å‰æ–¹ã®ä½ç½®ï¼ˆZè»¸ã‚’è² ã«å¤‰æ›´ã—ã¦è»Šã®å‰æ–¹ã«ï¼‰
                    const frontOffset = new THREE.Vector3(0, 5, -32); // è»Šã®å‰æ–¹ã€ã‚ˆã‚Šé›¢ã‚ŒãŸä½ç½®ã«å¤‰æ›´
                    // è»Šã®å‘ãã«åˆã‚ã›ã¦ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢
                    const rotatedFrontOffset = frontOffset.clone().applyQuaternion(currentCar.object.quaternion);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«æ›´æ–°
                    const targetFrontCameraPos = new THREE.Vector3().addVectors(currentCar.object.position, rotatedFrontOffset);
                    camera.position.lerp(targetFrontCameraPos, 0.1); // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
                    
                    // ã‚«ãƒ¡ãƒ©ãŒè»Šã®å¾Œæ–¹ã‚’è¦‹ã‚‹ã‚ˆã†ã«ã™ã‚‹
                    const lookBackOffset = new THREE.Vector3(0, 0, 20).applyQuaternion(currentCar.object.quaternion);
                    const lookBackPoint = new THREE.Vector3().addVectors(currentCar.object.position, lookBackOffset);
                    camera.lookAt(lookBackPoint);
                    
                    // æ¨™æº–ã®è¦–é‡è§’ã«æˆ»ã™
                    camera.fov = 60;
                    camera.updateProjectionMatrix();
                    break;
            }
        }
        
        // ãƒªã‚µã‚¤ã‚ºå‡¦ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®è¨­å®š
        function setupViewButtons() {
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                button.addEventListener('click', () => {
                    cameraMode = parseInt(button.getAttribute('data-view'));
                    updateButtonActiveState();
                });
            });
        }

        // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
        function updateButtonActiveState() {
            // è¦–ç‚¹ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°ï¼ˆ.view-buttonså†…ã®ãƒœã‚¿ãƒ³ã®ã¿ï¼‰
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // åˆæœŸåŒ–é–¢æ•°
        function init() {
            // ç’°å¢ƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é…ç½®
            placeEnvironmentObjects();
            
            // è¦–ç‚¹åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®è¨­å®š
            setupViewButtons();
            
            // å¤©æ°—ãƒœã‚¿ãƒ³ã®è¨­å®š
            setupWeatherButtons();
            
            // åˆæœŸå¤©æ°—ã®ãƒœã‚¿ãƒ³ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
            updateWeatherButtonState(currentWeather);
            
            // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
            document.getElementById('minimap-container').addEventListener('click', () => {
                // ã‚¿ãƒ–ã‚­ãƒ¼ã¨åŒã˜å‹•ä½œï¼šæ¬¡ã®è»Šã«åˆ‡ã‚Šæ›¿ãˆ
                currentCarIndex = (currentCarIndex + 1) % cars.length;
            });
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆ
            log("ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹");
            animate();
            
            // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
            initWeatherSystem();
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        window.onload = init;


        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
        function setupKeyboardControls() {
            document.addEventListener('keydown', (event) => {
                switch (event.key) {
                    case 'Tab':
                        // Tabã‚­ãƒ¼ã§è»Šã‚’åˆ‡ã‚Šæ›¿ãˆ
                        event.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®Tabå‹•ä½œã‚’é˜²æ­¢
                        currentCarIndex = (currentCarIndex + 1) % cars.length;
                        break;
                    case '1':
                        cameraMode = 0; // ä¿¯ç°
                        updateCameraButtonState();
                        break;
                    case '2':
                        cameraMode = 1; // è¿½å¾“
                        updateCameraButtonState();
                        break;
                    case '3':
                        cameraMode = 2; // è»Šè¼‰
                        updateCameraButtonState();
                        break;
                    case '4':
                        cameraMode = 3; // æ–œã‚
                        updateCameraButtonState();
                        break;
                    case '5':
                        cameraMode = 4; // å‰æ–¹
                        updateCameraButtonState();
                        break;
                }
            });
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
        setupKeyboardControls();

        // æ™‚é–“ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('timeToggleButton').addEventListener('click', function() {
            useRealTime = !useRealTime;
            
            // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°
            if (useRealTime) {
                this.textContent = 'ğŸ•’';
                this.title = 'ç¾åœ¨ã®æ™‚åˆ»ã«é€£å‹•ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰';
                
                // ç¾å®Ÿæ™‚é–“ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã£ãŸã‚‰å¤©æ°—ã¨ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•å¤‰æ›´ã‚’ãƒªã‚»ãƒƒãƒˆ
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 30000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 30000;
                
                // ç¾åœ¨åœ°ç‚¹ã®å¤©æ°—ã‚’å–å¾—ã—ã¦åæ˜ 
                fetchCurrentWeather();
            } else {
                this.textContent = 'â©';
                this.title = 'ã‚²ãƒ¼ãƒ å†…æ™‚é–“ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§åˆ‡æ›¿ï¼‰';
                
                // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰ã«å…¥ã£ãŸã‚‰å¤©æ°—è¡¨ç¤ºã‚’éè¡¨ç¤ºã«
                updateWeatherDisplay(null, false);
                
                // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰ã«å…¥ã£ãŸã‚‰å¤©æ°—ã¨ã‚«ãƒ¡ãƒ©ã‚’è‡ªå‹•æ›´æ–°é–‹å§‹
                lastWeatherChangeTime = Date.now();
                weatherChangeInterval = 20000 + Math.random() * 20000;
                lastCameraChangeTime = Date.now();
                cameraChangeInterval = 10000 + Math.random() * 5000;
            }
        });

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã¯å‰Šé™¤ï¼ˆinité–¢æ•°ã«ç§»å‹•æ¸ˆã¿ï¼‰

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ–ã‚’å®Ÿè¡Œ
        window.onload = init;

        // DOMContentLoadedã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ï¼ˆé‡è¤‡åˆæœŸåŒ–é˜²æ­¢ã®ãŸã‚ï¼‰
        
        // å¤©æ°—ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
        function initWeatherSystem() {
            // é›ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
            createSnowParticles();
            
            // é›¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
            createRainParticles();
            
            // é›²ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ è¿½åŠ 
            const cloudGeometry = new THREE.BufferGeometry();
            const cloudCount = 500; // é›²ã¯é›ªã‚ˆã‚Šå°‘ãªã
            const cloudPositions = new Float32Array(cloudCount * 3);
            const cloudSizes = new Float32Array(cloudCount);
            
            for (let i = 0; i < cloudCount * 3; i += 3) {
                cloudPositions[i] = Math.random() * 3000 - 1500; // x: -1500 to 1500 (åºƒç¯„å›²ã«é…ç½®)
                cloudPositions[i+1] = 300 + Math.random() * 500; // y: 300 to 800 (é«˜ã„ä½ç½®ã«é…ç½®)
                cloudPositions[i+2] = Math.random() * 3000 - 1500; // z: -1500 to 1500
                cloudSizes[i/3] = 20.0 + Math.random() * 30.0; // é›²ã¯å¤§ãã‚ã«
            }
            
            cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3));
            cloudGeometry.setAttribute('size', new THREE.BufferAttribute(cloudSizes, 1));
            
            // é›²ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨
            const cloudTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud10.png');
            
            const cloudMaterial = new THREE.PointsMaterial({
                color: 0xcccccc,
                size: 30.0,
                transparent: true,
                opacity: 0.7,
                map: cloudTexture,
                sizeAttenuation: true,
                depthWrite: false // åŠé€æ˜ã®ãŸã‚ã€æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ã‚ªãƒ•
            });
            
            cloudParticles = new THREE.Points(cloudGeometry, cloudMaterial);
            cloudParticles.visible = false;
            scene.add(cloudParticles);
            
            // åˆæœŸå¤©æ°—ã®è¨­å®š
            if (useRealTime) {
                // ç¾åœ¨åœ°ç‚¹ã®å¤©æ°—ã‚’å–å¾—ã—ã¦åæ˜ 
                fetchCurrentWeather();
            } else {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªå¤©æ°—ã‚’è¨­å®š
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather);
            }
        }
        
        // å¤©æ°—ã‚’å¤‰æ›´ã™ã‚‹é–¢æ•°
        function changeWeather(weather, isFromCurrentLocation = false, temperature = null, windSpeed = null) {
            currentWeather = weather;
            updateWeatherDisplay(weather, isFromCurrentLocation, temperature, windSpeed);
            updateWeatherButtonState(weather);
            
            switch(weather) {
                case 'sunny':
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = false;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = false;
                    updateEnvironmentForSunny();
                    break;
                    
                case 'cloudy':
                    isRaining = false;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForCloudy();
                    break;
                    
                case 'rain':
                    isRaining = true;
                    isSnowing = false;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = true;
                    if (snowParticles) snowParticles.visible = false;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForRain();
                    break;
                    
                case 'snow':
                    isRaining = false;
                    isSnowing = true;
                    isCloudy = true;
                    if (rainParticles) rainParticles.visible = false;
                    if (snowParticles) snowParticles.visible = true;
                    if (cloudParticles) cloudParticles.visible = true;
                    updateEnvironmentForSnow();
                    break;
            }
        }
        
        // æ›‡ã‚Šã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForCloudy() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) { // ä¿¯ç°è¦–ç‚¹ã®å ´åˆ
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.003);
            }
            
            // æ›‡ã‚Šã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆã‚°ãƒ¬ãƒ¼ãŒã‹ã£ãŸè‰²ï¼‰
            weatherSkyColor = new THREE.Color(0x8c8c8c);
            
            // æ›‡ã‚Šæ™‚ã®èŠç”Ÿã®è‰²
            floor.material.color.setHex(0x2a552a);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // é›¨ã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForRain() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0x555555, 0.001);
            } else {
                scene.fog = new THREE.FogExp2(0x555555, 0.007);
            }
            
            // é›¨ã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæš—ã„ã‚°ãƒ¬ãƒ¼ï¼‰
            weatherSkyColor = new THREE.Color(0x4a4a4a);
            
            // åœ°é¢ã‚’æ¿¡ã‚ŒãŸæ„Ÿã˜ã«
            floor.material.color.setHex(0x1c4d1c);
            floor.material.roughness = 0.9; // ã‚ˆã‚Šåå°„ã™ã‚‹ã‚ˆã†ã«
            floor.material.metalness = 0.5; // ã‚ˆã‚Šé‡‘å±æ„Ÿã‚’å¢—ã‚„ã—ã¦åå°„ã‚’å¼·ã‚ã‚‹
            floor.material.needsUpdate = true;
        }
        
        // é›ªã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForSnow() {
            // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦éœ§ã®æ¿ƒåº¦ã‚’èª¿æ•´
            if (cameraMode === 0) {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0005);
            } else {
                scene.fog = new THREE.FogExp2(0xaaaaaa, 0.005);
            }
            
            // é›ªã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæ˜ã‚‹ã„ã‚°ãƒ¬ãƒ¼ï¼‰
            weatherSkyColor = new THREE.Color(0xd8d8d8);
            
            // åœ°é¢ã‚’é›ªã§è¦†ã‚ã‚ŒãŸã‚ˆã†ã«
            floor.material.color.setHex(0xf0f0f0);
            floor.material.roughness = 0.9;
            floor.material.metalness = 0.0
            floor.material.needsUpdate = true;
        }
        
        // æ™´ã‚Œã®ç’°å¢ƒæ›´æ–°
        function updateEnvironmentForSunny() {
            // éœ§ã‚’ãªãã™
            scene.fog = null;
            
            // æ™´ã‚Œã®ç©ºã®è‰²ã‚’è¨­å®šï¼ˆæ˜ã‚‹ã„é’ç©ºï¼‰
            weatherSkyColor = new THREE.Color(0x87CEEB);
            
            // é€šå¸¸ã®èŠç”Ÿã®è‰²ã«æˆ»ã™
            floor.material.color.setHex(0x336633);
            floor.material.roughness = 0.8;
            floor.material.metalness = 0.2;
            floor.material.needsUpdate = true;
        }
        
        // å¤©æ°—ã®æ›´æ–°
        function updateWeather(deltaTime) {
            // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰æ™‚ã®è‡ªå‹•å¤©æ°—å¤‰æ›´ã¨ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆ
            if (!useRealTime) {
                const currentTime = Date.now();
                
                // å¤©æ°—ã®è‡ªå‹•å¤‰æ›´
                if (currentTime - lastWeatherChangeTime > weatherChangeInterval) {
                    const availableChoices = availableWeathers.filter(w => w !== currentWeather);
                    const nextWeather = availableChoices[Math.floor(Math.random() * availableChoices.length)];
                    changeWeather(nextWeather);
                    lastWeatherChangeTime = currentTime;
                    weatherChangeInterval = 20000 + Math.random() * 20000;
                }
                
                // ã‚«ãƒ¡ãƒ©ã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ
                if (currentTime - lastCameraChangeTime > cameraChangeInterval) {
                    const availableViews = availableCameraModes.filter(mode => mode !== cameraMode);
                    const nextCameraMode = availableViews[Math.floor(Math.random() * availableViews.length)];
                    cameraMode = nextCameraMode;
                    updateCameraButtonState();
                    
                    lastCameraChangeTime = currentTime;
                    cameraChangeInterval = 10000 + Math.random() * 5000;
                }
            }
            
            // é›²ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (isCloudy && cloudParticles) {
                cloudParticles.visible = true;
                cloudParticles.position.x = camera.position.x;
                cloudParticles.position.z = camera.position.z;
            } else if (cloudParticles) {
                cloudParticles.visible = false;
            }
            
            // é›¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (isRaining && rainParticles) {
                const positions = rainParticles.userData.positions;
                const speeds = rainParticles.userData.speeds;
                const swayFactors = rainParticles.userData.swayFactors;
                const phases = rainParticles.userData.phases;
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < positions.length; i += 6) {
                    const index = i / 6;
                    
                    positions[i + 1] -= speeds[index] * deltaTime;
                    positions[i + 4] -= speeds[index] * deltaTime;
                    
                    const swayAmount = swayFactors[index];
                    const phase = phases[index];
                    const swayX = Math.sin(time + phase) * swayAmount * 0.1 * deltaTime;
                    const swayZ = Math.cos(time * 0.8 + phase) * swayAmount * 0.1 * deltaTime;
                    
                    positions[i] += swayX;
                    positions[i + 2] += swayZ;
                    positions[i + 3] += swayX;
                    positions[i + 5] += swayZ;
                    
                    if (positions[i + 4] < 0) {
                        const x = Math.random() * 2000 - 1000;
                        const y = 1000;
                        const z = Math.random() * 2000 - 1000;
                        
                        positions[i] = x;
                        positions[i + 1] = y;
                        positions[i + 2] = z;
                        
                        positions[i + 3] = x;
                        positions[i + 4] = y - 10;
                        positions[i + 5] = z;
                    }
                }
                
                rainParticles.position.x = camera.position.x;
                rainParticles.position.z = camera.position.z;
                
                rainParticles.geometry.attributes.position.needsUpdate = true;
            } else if (rainParticles) {
                rainParticles.visible = false;
            }
            
            // é›ªã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            if (isSnowing && snowParticles) {
                const positions = snowParticles.userData.positions;
                const speeds = snowParticles.userData.speeds;
                const swayFactors = snowParticles.userData.swayFactors;
                const phases = snowParticles.userData.phases;
                const time = Date.now() * 0.001; // ç§’å˜ä½ã®æ™‚é–“
                
                for (let i = 0; i < positions.length; i += 3) {
                    const index = i / 3;
                    
                    // Yåº§æ¨™ï¼ˆè½ä¸‹ï¼‰ã®æ›´æ–°
                    positions[i + 1] -= speeds[index] * deltaTime;
                    
                    // Xåº§æ¨™ã¨Zåº§æ¨™ã®æºã‚Œã‚’æ›´æ–°ï¼ˆã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã‚’ä½¿ç”¨ï¼‰
                    const swayAmount = swayFactors[index];
                    const phase = phases[index];
                    positions[i] += Math.sin(time + phase) * swayAmount * 0.1 * deltaTime;
                    positions[i + 2] += Math.cos(time * 0.8 + phase) * swayAmount * 0.1 * deltaTime;
                    
                    // åœ°é¢ã«åˆ°é”ã—ãŸã‚‰ä¸Šã«æˆ»ã™
                    if (positions[i + 1] < 0) {
                        positions[i] = Math.random() * 2000 - 1000;     // X
                        positions[i + 1] = 1000;                        // Y
                        positions[i + 2] = Math.random() * 2000 - 1000; // Z
                    }
                }
                
                // ã‚«ãƒ¡ãƒ©ã‚’ä¸­å¿ƒã«é›ªã‚’é…ç½®
                snowParticles.position.x = camera.position.x;
                snowParticles.position.z = camera.position.z;
                
                snowParticles.geometry.attributes.position.needsUpdate = true;
            } else if (snowParticles) {
                snowParticles.visible = false;
            }
        }

        // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateCameraButtonState() {
            document.querySelectorAll('.view-buttons .viewButton').forEach(button => {
                const viewMode = parseInt(button.getAttribute('data-view'));
                if (viewMode === cameraMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // ç¾åœ¨ä½ç½®ã®å¤©æ°—ã‚’å–å¾—ã™ã‚‹é–¢æ•°
        async function fetchCurrentWeather() {
            try {
                // ç¾åœ¨ä½ç½®ã‚’å–å¾—
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const lat = position.coords.latitude;
                const lon = position.coords.longitude;
                
                log(`ç¾åœ¨ä½ç½®ã‚’å–å¾—ã—ã¾ã—ãŸ: ç·¯åº¦ ${lat}, çµŒåº¦ ${lon}`);
                
                // OpenWeatherMap APIã‚’å‘¼ã³å‡ºã—
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${weatherApiKey}&units=metric`);
                
                if (!response.ok) {
                    throw new Error('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                const data = await response.json();
                
                // æ°—æ¸©ã¨é¢¨é€Ÿã‚’å–å¾—
                const temperature = data.main.temp;
                const windSpeed = data.wind.speed;
                
                // æ°—æ¸©ã¨é¢¨é€Ÿã‚’ä¿å­˜
                currentTemperature = temperature;
                currentWindSpeed = windSpeed;
                
                log(`æ°—æ¸©: ${temperature}â„ƒ, é¢¨é€Ÿ: ${windSpeed}m/s`);
                
                // å¤©æ°—ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦å¤©æ°—ã‚’è¨­å®š
                const weatherCode = data.weather[0].id;
                let gameWeather = 'sunny'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                
                // å¤©æ°—ã‚³ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦å¤©æ°—ã‚’åˆ¤å®š
                if (weatherCode >= 600 && weatherCode < 623) {
                    gameWeather = 'snow';
                } else if ((weatherCode >= 500 && weatherCode < 532) || (weatherCode >= 200 && weatherCode < 233)) {
                    gameWeather = 'rain';
                } else if (weatherCode >= 801 && weatherCode < 805) {
                    gameWeather = 'cloudy';
                } else if (weatherCode === 800) {
                    gameWeather = 'sunny';
                } else {
                    gameWeather = 'cloudy';
                }
                
                log(`å¤©æ°—ã‚’å¤‰æ›´ã—ã¾ã™: ${gameWeather}`);
                
                // å¤©æ°—ã‚’å¤‰æ›´ï¼ˆæ°—æ¸©ã¨é¢¨é€Ÿã‚‚æ¸¡ã™ï¼‰
                changeWeather(gameWeather, true, temperature, windSpeed);
                
                return gameWeather;
            } catch (error) {
                console.error('å¤©æ°—æƒ…å ±ã®å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
                log('å¤©æ°—æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¤©æ°—ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚');
                
                updateWeatherDisplay('-', false); // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¤©æ°—è¡¨ç¤ºã‚’éè¡¨ç¤ºã«
                
                // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ ãªå¤©æ°—ã‚’è¨­å®šï¼ˆè¡¨ç¤ºã¯ã—ãªã„ï¼‰
                const randomWeather = availableWeathers[Math.floor(Math.random() * availableWeathers.length)];
                changeWeather(randomWeather, false);
                
                return null;
            }
        }

        // æ™‚åˆ»è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateTimeDisplay() {
            const timeDisplay = document.getElementById('currentTime');
            if (useRealTime) {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                timeDisplay.textContent = `${hours}:${minutes}`;
            } else {
                const hours = Math.floor(gameTime).toString().padStart(2, '0');
                const minutes = Math.floor((gameTime % 1) * 60).toString().padStart(2, '0');
                timeDisplay.textContent = `${hours}:${minutes}`;
            }
        }

        // å¤©æ°—è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateWeatherDisplay(weather, isFromCurrentLocation = false, temperature = null, windSpeed = null) {
            const weatherDisplay = document.getElementById('currentWeatherText');
            
            // æ—©é€ã‚Šãƒ¢ãƒ¼ãƒ‰ã¾ãŸã¯ç¾åœ¨åœ°ã‹ã‚‰ã®å¤©æ°—ã§ãªã„å ´åˆã¯éè¡¨ç¤º
            if (!useRealTime || !isFromCurrentLocation) {
                weatherDisplay.textContent = '-';
                return;
            }
            
            const weatherMap = {
                'sunny': 'â˜€ï¸',
                'cloudy': 'â˜ï¸',
                'rain': 'ğŸŒ§ï¸',
                'snow': 'â„ï¸'
            };
            
            let displayText = weatherMap[weather] || '-';
            displayText += ` ${Math.round(temperature)}â„ƒ`;
            displayText += ` ${Math.round(windSpeed)}m/s `;
            
            weatherDisplay.textContent = displayText;
        }

        // å¤©æ°—ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ä¿®æ­£
        function setupWeatherButtons() {
            document.querySelectorAll('.weather-button').forEach(button => {
                button.addEventListener('click', function() {
                    const selectedWeather = this.getAttribute('data-weather');
                    
                    // ä»¥å‰ã®å¤©æ°—ã‚’ãƒªã‚»ãƒƒãƒˆ
                    document.querySelectorAll('.weather-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // é¸æŠã•ã‚ŒãŸå¤©æ°—ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
                    this.classList.add('active');
                    
                    // å¤©æ°—ã‚’å¤‰æ›´ï¼ˆæ‰‹å‹•å¤‰æ›´ãªã®ã§isFromCurrentLocation = falseï¼‰
                    changeWeather(selectedWeather, false);
                });
            });
        }

        // å¤©æ°—ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateWeatherButtonState(weather) {
            document.querySelectorAll('.weather-button').forEach(button => {
                if (button.getAttribute('data-weather') === weather) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«æ°—æ¸©ã¨é¢¨é€Ÿã‚’è¿½åŠ 
        let currentTemperature = null;
        let currentWindSpeed = null;

        // é›¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
        function createRainParticles() {
            const rainGeometry = new THREE.BufferGeometry();
            const rainCount = 7500; // 15000ã‹ã‚‰7500ã«æ¸›ã‚‰ã™
            
            // é›¨ç²’ã®ä½ç½®é…åˆ—ã‚’ä½œæˆï¼ˆå„é›¨ç²’ã®é–‹å§‹ç‚¹ã¨çµ‚ç‚¹ï¼‰
            const rainPositions = new Float32Array(rainCount * 6); // 2ç‚¹ï¼ˆé–‹å§‹ç‚¹ã¨çµ‚ç‚¹ï¼‰ã§1ã¤ã®ç·šã‚’è¡¨ç¾
            const rainSpeeds = new Float32Array(rainCount);
            const rainSwayFactors = new Float32Array(rainCount);
            const rainPhases = new Float32Array(rainCount);
            
            for (let i = 0; i < rainCount; i++) {
                const baseIndex = i * 6;
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 1000;
                const z = Math.random() * 2000 - 1000;
                
                // ç·šã®é–‹å§‹ç‚¹
                rainPositions[baseIndex] = x;
                rainPositions[baseIndex + 1] = y;
                rainPositions[baseIndex + 2] = z;
                
                // ç·šã®çµ‚ç‚¹ï¼ˆé–‹å§‹ç‚¹ã‚ˆã‚Š10å˜ä½ä¸‹ï¼‰
                rainPositions[baseIndex + 3] = x;
                rainPositions[baseIndex + 4] = y - 10;
                rainPositions[baseIndex + 5] = z;
                
                // å€‹åˆ¥ã®é›¨ç²’ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®š
                rainSpeeds[i] = 20.0 + Math.random() * 10.0;
                rainSwayFactors[i] = 0.1 + Math.random() * 0.2;
                rainPhases[i] = Math.random() * Math.PI * 2;
            }
            
            rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
            
            const rainMaterial = new THREE.LineBasicMaterial({
                color: 0x99ccff,
                opacity: 0.4,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            rainParticles = new THREE.LineSegments(rainGeometry, rainMaterial);
            rainParticles.visible = false;
            scene.add(rainParticles);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ä¿å­˜
            rainParticles.userData = {
                positions: rainPositions,
                speeds: rainSpeeds,
                swayFactors: rainSwayFactors,
                phases: rainPhases
            };
        }

        // é›ªã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œæˆ
        function createSnowParticles() {
            const snowGeometry = new THREE.BufferGeometry();
            const snowCount = 5000; // 10000ã‹ã‚‰5000ã«æ¸›ã‚‰ã™
            
            // é›ªç‰‡ã®ä½ç½®é…åˆ—ã‚’ä½œæˆ
            const snowPositions = new Float32Array(snowCount * 3);
            const snowSpeeds = new Float32Array(snowCount); // å€‹åˆ¥ã®é€Ÿåº¦ã‚’ä¿å­˜
            const snowSwayFactors = new Float32Array(snowCount); // æºã‚Œã®ä¿‚æ•°ã‚’ä¿å­˜
            const snowPhases = new Float32Array(snowCount); // ä½ç›¸ã®ãšã‚Œã‚’ä¿å­˜
            
            for (let i = 0; i < snowCount * 3; i += 3) {
                snowPositions[i] = Math.random() * 2000 - 1000;     // X
                snowPositions[i + 1] = Math.random() * 1000;        // Y
                snowPositions[i + 2] = Math.random() * 2000 - 1000; // Z
                
                // å€‹åˆ¥ã®é›ªç‰‡ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®š
                const index = i / 3;
                snowSpeeds[index] = 0.5 + Math.random() * 1.0; // 0.5ã€œ1.5ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦
                snowSwayFactors[index] = 0.3 + Math.random() * 0.4; // 0.3ã€œ0.7ã®ç¯„å›²ã§æºã‚Œã®å¤§ãã•
                snowPhases[index] = Math.random() * Math.PI * 2; // 0ã€œ2Ï€ã®ç¯„å›²ã§åˆæœŸä½ç›¸
            }
            
            snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            
            const snowMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                opacity: 0.8,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            snowParticles = new THREE.Points(snowGeometry, snowMaterial);
            snowParticles.visible = false;
            scene.add(snowParticles);
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã«ä¿å­˜
            snowParticles.userData = {
                positions: snowPositions,
                speeds: snowSpeeds,
                swayFactors: snowSwayFactors,
                phases: snowPhases
            };
        }

        // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®æ›´æ–°é–¢æ•°
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // èƒŒæ™¯è‰²
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ãƒ‘ã‚¹ã®æç”»ã«å¿…è¦ãªå¤‰æ•°
            const margin = 10;
            const pathPoints = [];
            
            // ãƒ‘ã‚¹ã®åº§æ¨™ã‚’å–å¾—
            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const point = carPath.getPointAt(t);
                pathPoints.push(point);
            }
            
            // åº§æ¨™ã®æœ€å°å€¤ã¨æœ€å¤§å€¤ã‚’è¨ˆç®—
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            for (const point of pathPoints) {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minZ = Math.min(minZ, point.z);
                maxZ = Math.max(maxZ, point.z);
            }
            
            // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—ï¼ˆä½™ç™½ã‚’è€ƒæ…®ï¼‰
            const width = canvas.width - margin * 2;
            const height = canvas.height - margin * 2;
            const scaleX = width / (maxX - minX);
            const scaleZ = height / (maxZ - minZ);
            const scale = Math.min(scaleX, scaleZ);
            
            // ãƒ‘ã‚¹ã‚’æç”»
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const x = margin + (point.x - minX) * scale;
                const z = margin + (point.z - minZ) * scale;
                
                if (i === 0) {
                    ctx.moveTo(x, z);
                } else {
                    ctx.lineTo(x, z);
                }
            }
            
            ctx.closePath();
            ctx.stroke();
            
            // è»Šã®ä½ç½®ã‚’ãƒŸãƒ‹ãƒãƒƒãƒ—ä¸Šã§è¡¨ç¤º
            for (let i = 0; i < cars.length; i++) {
                const car = cars[i];
                const point = carPath.getPointAt(car.position);
                const x = margin + (point.x - minX) * scale;
                const y = margin + (point.z - minZ) * scale;
                
                // è»Šã®å‘ãã‚’è¨ˆç®—
                const tangent = carPath.getTangentAt(car.position).normalize();
                const angle = Math.atan2(tangent.z, tangent.x) + Math.PI/2;
                
                // è»Šã‚’ä¸‰è§’å½¢ã§æç”»
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -5);  // å…ˆç«¯
                ctx.lineTo(-3, 3);  // å·¦ä¸‹
                ctx.lineTo(3, 3);   // å³ä¸‹
                ctx.closePath();
                ctx.fillStyle = (i === currentCarIndex) ? 'red' : 'white';
                ctx.fill();
                ctx.restore();
            }
        }

        // è»Šã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆç”¨ã®å¤‰æ•°ã‚’åˆæœŸåŒ–
        let lastCarChangeTime = Date.now();
        let carChangeInterval = 20000 + Math.random() * 10000; // 20-30ç§’ã®ãƒ©ãƒ³ãƒ€ãƒ ãªé–“éš”
    </script>
</body>
</html> 